
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Etiqueta
 * 
 */
export type Etiqueta = $Result.DefaultSelection<Prisma.$EtiquetaPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model EstadoProyecto
 * 
 */
export type EstadoProyecto = $Result.DefaultSelection<Prisma.$EstadoProyectoPayload>
/**
 * Model UnidadMunicipal
 * 
 */
export type UnidadMunicipal = $Result.DefaultSelection<Prisma.$UnidadMunicipalPayload>
/**
 * Model TipologiaProyecto
 * 
 */
export type TipologiaProyecto = $Result.DefaultSelection<Prisma.$TipologiaProyectoPayload>
/**
 * Model Sector
 * 
 */
export type Sector = $Result.DefaultSelection<Prisma.$SectorPayload>
/**
 * Model LineaFinanciamiento
 * 
 */
export type LineaFinanciamiento = $Result.DefaultSelection<Prisma.$LineaFinanciamientoPayload>
/**
 * Model Programa
 * 
 */
export type Programa = $Result.DefaultSelection<Prisma.$ProgramaPayload>
/**
 * Model EtapaFinanciamiento
 * 
 */
export type EtapaFinanciamiento = $Result.DefaultSelection<Prisma.$EtapaFinanciamientoPayload>
/**
 * Model Tarea
 * 
 */
export type Tarea = $Result.DefaultSelection<Prisma.$TareaPayload>
/**
 * Model ComentarioBitacora
 * 
 */
export type ComentarioBitacora = $Result.DefaultSelection<Prisma.$ComentarioBitacoraPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  COORDINADOR: 'COORDINADOR',
  USUARIO: 'USUARIO'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TipoMoneda: {
  CLP: 'CLP',
  UF: 'UF'
};

export type TipoMoneda = (typeof TipoMoneda)[keyof typeof TipoMoneda]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TipoMoneda = $Enums.TipoMoneda

export const TipoMoneda: typeof $Enums.TipoMoneda

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.etiqueta`: Exposes CRUD operations for the **Etiqueta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etiquetas
    * const etiquetas = await prisma.etiqueta.findMany()
    * ```
    */
  get etiqueta(): Prisma.EtiquetaDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.estadoProyecto`: Exposes CRUD operations for the **EstadoProyecto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoProyectos
    * const estadoProyectos = await prisma.estadoProyecto.findMany()
    * ```
    */
  get estadoProyecto(): Prisma.EstadoProyectoDelegate<ExtArgs>;

  /**
   * `prisma.unidadMunicipal`: Exposes CRUD operations for the **UnidadMunicipal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnidadMunicipals
    * const unidadMunicipals = await prisma.unidadMunicipal.findMany()
    * ```
    */
  get unidadMunicipal(): Prisma.UnidadMunicipalDelegate<ExtArgs>;

  /**
   * `prisma.tipologiaProyecto`: Exposes CRUD operations for the **TipologiaProyecto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipologiaProyectos
    * const tipologiaProyectos = await prisma.tipologiaProyecto.findMany()
    * ```
    */
  get tipologiaProyecto(): Prisma.TipologiaProyectoDelegate<ExtArgs>;

  /**
   * `prisma.sector`: Exposes CRUD operations for the **Sector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sector.findMany()
    * ```
    */
  get sector(): Prisma.SectorDelegate<ExtArgs>;

  /**
   * `prisma.lineaFinanciamiento`: Exposes CRUD operations for the **LineaFinanciamiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineaFinanciamientos
    * const lineaFinanciamientos = await prisma.lineaFinanciamiento.findMany()
    * ```
    */
  get lineaFinanciamiento(): Prisma.LineaFinanciamientoDelegate<ExtArgs>;

  /**
   * `prisma.programa`: Exposes CRUD operations for the **Programa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programas
    * const programas = await prisma.programa.findMany()
    * ```
    */
  get programa(): Prisma.ProgramaDelegate<ExtArgs>;

  /**
   * `prisma.etapaFinanciamiento`: Exposes CRUD operations for the **EtapaFinanciamiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EtapaFinanciamientos
    * const etapaFinanciamientos = await prisma.etapaFinanciamiento.findMany()
    * ```
    */
  get etapaFinanciamiento(): Prisma.EtapaFinanciamientoDelegate<ExtArgs>;

  /**
   * `prisma.tarea`: Exposes CRUD operations for the **Tarea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas
    * const tareas = await prisma.tarea.findMany()
    * ```
    */
  get tarea(): Prisma.TareaDelegate<ExtArgs>;

  /**
   * `prisma.comentarioBitacora`: Exposes CRUD operations for the **ComentarioBitacora** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComentarioBitacoras
    * const comentarioBitacoras = await prisma.comentarioBitacora.findMany()
    * ```
    */
  get comentarioBitacora(): Prisma.ComentarioBitacoraDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Etiqueta: 'Etiqueta',
    Project: 'Project',
    EstadoProyecto: 'EstadoProyecto',
    UnidadMunicipal: 'UnidadMunicipal',
    TipologiaProyecto: 'TipologiaProyecto',
    Sector: 'Sector',
    LineaFinanciamiento: 'LineaFinanciamiento',
    Programa: 'Programa',
    EtapaFinanciamiento: 'EtapaFinanciamiento',
    Tarea: 'Tarea',
    ComentarioBitacora: 'ComentarioBitacora'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "etiqueta" | "project" | "estadoProyecto" | "unidadMunicipal" | "tipologiaProyecto" | "sector" | "lineaFinanciamiento" | "programa" | "etapaFinanciamiento" | "tarea" | "comentarioBitacora"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Etiqueta: {
        payload: Prisma.$EtiquetaPayload<ExtArgs>
        fields: Prisma.EtiquetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtiquetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtiquetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          findFirst: {
            args: Prisma.EtiquetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtiquetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          findMany: {
            args: Prisma.EtiquetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>[]
          }
          create: {
            args: Prisma.EtiquetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          createMany: {
            args: Prisma.EtiquetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EtiquetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>[]
          }
          delete: {
            args: Prisma.EtiquetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          update: {
            args: Prisma.EtiquetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          deleteMany: {
            args: Prisma.EtiquetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtiquetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtiquetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          aggregate: {
            args: Prisma.EtiquetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtiqueta>
          }
          groupBy: {
            args: Prisma.EtiquetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtiquetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtiquetaCountArgs<ExtArgs>
            result: $Utils.Optional<EtiquetaCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      EstadoProyecto: {
        payload: Prisma.$EstadoProyectoPayload<ExtArgs>
        fields: Prisma.EstadoProyectoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstadoProyectoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstadoProyectoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          findFirst: {
            args: Prisma.EstadoProyectoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstadoProyectoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          findMany: {
            args: Prisma.EstadoProyectoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>[]
          }
          create: {
            args: Prisma.EstadoProyectoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          createMany: {
            args: Prisma.EstadoProyectoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstadoProyectoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>[]
          }
          delete: {
            args: Prisma.EstadoProyectoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          update: {
            args: Prisma.EstadoProyectoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          deleteMany: {
            args: Prisma.EstadoProyectoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstadoProyectoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstadoProyectoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoProyectoPayload>
          }
          aggregate: {
            args: Prisma.EstadoProyectoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstadoProyecto>
          }
          groupBy: {
            args: Prisma.EstadoProyectoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadoProyectoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstadoProyectoCountArgs<ExtArgs>
            result: $Utils.Optional<EstadoProyectoCountAggregateOutputType> | number
          }
        }
      }
      UnidadMunicipal: {
        payload: Prisma.$UnidadMunicipalPayload<ExtArgs>
        fields: Prisma.UnidadMunicipalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnidadMunicipalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnidadMunicipalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          findFirst: {
            args: Prisma.UnidadMunicipalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnidadMunicipalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          findMany: {
            args: Prisma.UnidadMunicipalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>[]
          }
          create: {
            args: Prisma.UnidadMunicipalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          createMany: {
            args: Prisma.UnidadMunicipalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnidadMunicipalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>[]
          }
          delete: {
            args: Prisma.UnidadMunicipalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          update: {
            args: Prisma.UnidadMunicipalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          deleteMany: {
            args: Prisma.UnidadMunicipalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnidadMunicipalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnidadMunicipalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadMunicipalPayload>
          }
          aggregate: {
            args: Prisma.UnidadMunicipalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnidadMunicipal>
          }
          groupBy: {
            args: Prisma.UnidadMunicipalGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnidadMunicipalGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnidadMunicipalCountArgs<ExtArgs>
            result: $Utils.Optional<UnidadMunicipalCountAggregateOutputType> | number
          }
        }
      }
      TipologiaProyecto: {
        payload: Prisma.$TipologiaProyectoPayload<ExtArgs>
        fields: Prisma.TipologiaProyectoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipologiaProyectoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipologiaProyectoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          findFirst: {
            args: Prisma.TipologiaProyectoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipologiaProyectoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          findMany: {
            args: Prisma.TipologiaProyectoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>[]
          }
          create: {
            args: Prisma.TipologiaProyectoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          createMany: {
            args: Prisma.TipologiaProyectoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipologiaProyectoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>[]
          }
          delete: {
            args: Prisma.TipologiaProyectoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          update: {
            args: Prisma.TipologiaProyectoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          deleteMany: {
            args: Prisma.TipologiaProyectoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipologiaProyectoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TipologiaProyectoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipologiaProyectoPayload>
          }
          aggregate: {
            args: Prisma.TipologiaProyectoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipologiaProyecto>
          }
          groupBy: {
            args: Prisma.TipologiaProyectoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipologiaProyectoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipologiaProyectoCountArgs<ExtArgs>
            result: $Utils.Optional<TipologiaProyectoCountAggregateOutputType> | number
          }
        }
      }
      Sector: {
        payload: Prisma.$SectorPayload<ExtArgs>
        fields: Prisma.SectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findFirst: {
            args: Prisma.SectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findMany: {
            args: Prisma.SectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>[]
          }
          create: {
            args: Prisma.SectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          createMany: {
            args: Prisma.SectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>[]
          }
          delete: {
            args: Prisma.SectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          update: {
            args: Prisma.SectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          deleteMany: {
            args: Prisma.SectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          aggregate: {
            args: Prisma.SectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSector>
          }
          groupBy: {
            args: Prisma.SectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectorCountArgs<ExtArgs>
            result: $Utils.Optional<SectorCountAggregateOutputType> | number
          }
        }
      }
      LineaFinanciamiento: {
        payload: Prisma.$LineaFinanciamientoPayload<ExtArgs>
        fields: Prisma.LineaFinanciamientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineaFinanciamientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineaFinanciamientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          findFirst: {
            args: Prisma.LineaFinanciamientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineaFinanciamientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          findMany: {
            args: Prisma.LineaFinanciamientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>[]
          }
          create: {
            args: Prisma.LineaFinanciamientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          createMany: {
            args: Prisma.LineaFinanciamientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineaFinanciamientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>[]
          }
          delete: {
            args: Prisma.LineaFinanciamientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          update: {
            args: Prisma.LineaFinanciamientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          deleteMany: {
            args: Prisma.LineaFinanciamientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineaFinanciamientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LineaFinanciamientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineaFinanciamientoPayload>
          }
          aggregate: {
            args: Prisma.LineaFinanciamientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineaFinanciamiento>
          }
          groupBy: {
            args: Prisma.LineaFinanciamientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineaFinanciamientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineaFinanciamientoCountArgs<ExtArgs>
            result: $Utils.Optional<LineaFinanciamientoCountAggregateOutputType> | number
          }
        }
      }
      Programa: {
        payload: Prisma.$ProgramaPayload<ExtArgs>
        fields: Prisma.ProgramaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          findFirst: {
            args: Prisma.ProgramaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          findMany: {
            args: Prisma.ProgramaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>[]
          }
          create: {
            args: Prisma.ProgramaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          createMany: {
            args: Prisma.ProgramaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>[]
          }
          delete: {
            args: Prisma.ProgramaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          update: {
            args: Prisma.ProgramaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          deleteMany: {
            args: Prisma.ProgramaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          aggregate: {
            args: Prisma.ProgramaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrograma>
          }
          groupBy: {
            args: Prisma.ProgramaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramaCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramaCountAggregateOutputType> | number
          }
        }
      }
      EtapaFinanciamiento: {
        payload: Prisma.$EtapaFinanciamientoPayload<ExtArgs>
        fields: Prisma.EtapaFinanciamientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtapaFinanciamientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtapaFinanciamientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          findFirst: {
            args: Prisma.EtapaFinanciamientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtapaFinanciamientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          findMany: {
            args: Prisma.EtapaFinanciamientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>[]
          }
          create: {
            args: Prisma.EtapaFinanciamientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          createMany: {
            args: Prisma.EtapaFinanciamientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EtapaFinanciamientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>[]
          }
          delete: {
            args: Prisma.EtapaFinanciamientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          update: {
            args: Prisma.EtapaFinanciamientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          deleteMany: {
            args: Prisma.EtapaFinanciamientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtapaFinanciamientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtapaFinanciamientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaFinanciamientoPayload>
          }
          aggregate: {
            args: Prisma.EtapaFinanciamientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtapaFinanciamiento>
          }
          groupBy: {
            args: Prisma.EtapaFinanciamientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtapaFinanciamientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtapaFinanciamientoCountArgs<ExtArgs>
            result: $Utils.Optional<EtapaFinanciamientoCountAggregateOutputType> | number
          }
        }
      }
      Tarea: {
        payload: Prisma.$TareaPayload<ExtArgs>
        fields: Prisma.TareaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TareaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TareaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          findFirst: {
            args: Prisma.TareaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TareaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          findMany: {
            args: Prisma.TareaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>[]
          }
          create: {
            args: Prisma.TareaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          createMany: {
            args: Prisma.TareaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TareaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>[]
          }
          delete: {
            args: Prisma.TareaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          update: {
            args: Prisma.TareaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          deleteMany: {
            args: Prisma.TareaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TareaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TareaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TareaPayload>
          }
          aggregate: {
            args: Prisma.TareaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarea>
          }
          groupBy: {
            args: Prisma.TareaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TareaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TareaCountArgs<ExtArgs>
            result: $Utils.Optional<TareaCountAggregateOutputType> | number
          }
        }
      }
      ComentarioBitacora: {
        payload: Prisma.$ComentarioBitacoraPayload<ExtArgs>
        fields: Prisma.ComentarioBitacoraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioBitacoraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioBitacoraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          findFirst: {
            args: Prisma.ComentarioBitacoraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioBitacoraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          findMany: {
            args: Prisma.ComentarioBitacoraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>[]
          }
          create: {
            args: Prisma.ComentarioBitacoraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          createMany: {
            args: Prisma.ComentarioBitacoraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComentarioBitacoraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>[]
          }
          delete: {
            args: Prisma.ComentarioBitacoraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          update: {
            args: Prisma.ComentarioBitacoraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioBitacoraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioBitacoraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioBitacoraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioBitacoraPayload>
          }
          aggregate: {
            args: Prisma.ComentarioBitacoraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentarioBitacora>
          }
          groupBy: {
            args: Prisma.ComentarioBitacoraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioBitacoraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioBitacoraCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioBitacoraCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    etiquetas: number
    proyectosAsignadosComoProyectista: number
    proyectosAsignadosComoFormulador: number
    proyectosComoColaborador: number
    tareasCreadas: number
    tareasAsignadas: number
    comentariosBitacora: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etiquetas?: boolean | UserCountOutputTypeCountEtiquetasArgs
    proyectosAsignadosComoProyectista?: boolean | UserCountOutputTypeCountProyectosAsignadosComoProyectistaArgs
    proyectosAsignadosComoFormulador?: boolean | UserCountOutputTypeCountProyectosAsignadosComoFormuladorArgs
    proyectosComoColaborador?: boolean | UserCountOutputTypeCountProyectosComoColaboradorArgs
    tareasCreadas?: boolean | UserCountOutputTypeCountTareasCreadasArgs
    tareasAsignadas?: boolean | UserCountOutputTypeCountTareasAsignadasArgs
    comentariosBitacora?: boolean | UserCountOutputTypeCountComentariosBitacoraArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEtiquetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtiquetaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProyectosAsignadosComoProyectistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProyectosAsignadosComoFormuladorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProyectosComoColaboradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTareasCreadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TareaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTareasAsignadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TareaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComentariosBitacoraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioBitacoraWhereInput
  }


  /**
   * Count Type EtiquetaCountOutputType
   */

  export type EtiquetaCountOutputType = {
    usuarios: number
  }

  export type EtiquetaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | EtiquetaCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * EtiquetaCountOutputType without action
   */
  export type EtiquetaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtiquetaCountOutputType
     */
    select?: EtiquetaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtiquetaCountOutputType without action
   */
  export type EtiquetaCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    colaboradores: number
    tareas: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colaboradores?: boolean | ProjectCountOutputTypeCountColaboradoresArgs
    tareas?: boolean | ProjectCountOutputTypeCountTareasArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountColaboradoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTareasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TareaWhereInput
  }


  /**
   * Count Type EstadoProyectoCountOutputType
   */

  export type EstadoProyectoCountOutputType = {
    proyectos: number
  }

  export type EstadoProyectoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | EstadoProyectoCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * EstadoProyectoCountOutputType without action
   */
  export type EstadoProyectoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyectoCountOutputType
     */
    select?: EstadoProyectoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstadoProyectoCountOutputType without action
   */
  export type EstadoProyectoCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type UnidadMunicipalCountOutputType
   */

  export type UnidadMunicipalCountOutputType = {
    proyectos: number
  }

  export type UnidadMunicipalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | UnidadMunicipalCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * UnidadMunicipalCountOutputType without action
   */
  export type UnidadMunicipalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipalCountOutputType
     */
    select?: UnidadMunicipalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnidadMunicipalCountOutputType without action
   */
  export type UnidadMunicipalCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type TipologiaProyectoCountOutputType
   */

  export type TipologiaProyectoCountOutputType = {
    proyectos: number
  }

  export type TipologiaProyectoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | TipologiaProyectoCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * TipologiaProyectoCountOutputType without action
   */
  export type TipologiaProyectoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyectoCountOutputType
     */
    select?: TipologiaProyectoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipologiaProyectoCountOutputType without action
   */
  export type TipologiaProyectoCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type SectorCountOutputType
   */

  export type SectorCountOutputType = {
    proyectos: number
  }

  export type SectorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | SectorCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * SectorCountOutputType without action
   */
  export type SectorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectorCountOutputType
     */
    select?: SectorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectorCountOutputType without action
   */
  export type SectorCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type LineaFinanciamientoCountOutputType
   */

  export type LineaFinanciamientoCountOutputType = {
    programas: number
    proyectos: number
  }

  export type LineaFinanciamientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programas?: boolean | LineaFinanciamientoCountOutputTypeCountProgramasArgs
    proyectos?: boolean | LineaFinanciamientoCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * LineaFinanciamientoCountOutputType without action
   */
  export type LineaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamientoCountOutputType
     */
    select?: LineaFinanciamientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LineaFinanciamientoCountOutputType without action
   */
  export type LineaFinanciamientoCountOutputTypeCountProgramasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramaWhereInput
  }

  /**
   * LineaFinanciamientoCountOutputType without action
   */
  export type LineaFinanciamientoCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProgramaCountOutputType
   */

  export type ProgramaCountOutputType = {
    proyectos: number
  }

  export type ProgramaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | ProgramaCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * ProgramaCountOutputType without action
   */
  export type ProgramaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaCountOutputType
     */
    select?: ProgramaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramaCountOutputType without action
   */
  export type ProgramaCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type EtapaFinanciamientoCountOutputType
   */

  export type EtapaFinanciamientoCountOutputType = {
    proyectos: number
  }

  export type EtapaFinanciamientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | EtapaFinanciamientoCountOutputTypeCountProyectosArgs
  }

  // Custom InputTypes
  /**
   * EtapaFinanciamientoCountOutputType without action
   */
  export type EtapaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamientoCountOutputType
     */
    select?: EtapaFinanciamientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtapaFinanciamientoCountOutputType without action
   */
  export type EtapaFinanciamientoCountOutputTypeCountProyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type TareaCountOutputType
   */

  export type TareaCountOutputType = {
    comentarios: number
  }

  export type TareaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentarios?: boolean | TareaCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * TareaCountOutputType without action
   */
  export type TareaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TareaCountOutputType
     */
    select?: TareaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TareaCountOutputType without action
   */
  export type TareaCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioBitacoraWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    etiquetas?: boolean | User$etiquetasArgs<ExtArgs>
    proyectosAsignadosComoProyectista?: boolean | User$proyectosAsignadosComoProyectistaArgs<ExtArgs>
    proyectosAsignadosComoFormulador?: boolean | User$proyectosAsignadosComoFormuladorArgs<ExtArgs>
    proyectosComoColaborador?: boolean | User$proyectosComoColaboradorArgs<ExtArgs>
    tareasCreadas?: boolean | User$tareasCreadasArgs<ExtArgs>
    tareasAsignadas?: boolean | User$tareasAsignadasArgs<ExtArgs>
    comentariosBitacora?: boolean | User$comentariosBitacoraArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etiquetas?: boolean | User$etiquetasArgs<ExtArgs>
    proyectosAsignadosComoProyectista?: boolean | User$proyectosAsignadosComoProyectistaArgs<ExtArgs>
    proyectosAsignadosComoFormulador?: boolean | User$proyectosAsignadosComoFormuladorArgs<ExtArgs>
    proyectosComoColaborador?: boolean | User$proyectosComoColaboradorArgs<ExtArgs>
    tareasCreadas?: boolean | User$tareasCreadasArgs<ExtArgs>
    tareasAsignadas?: boolean | User$tareasAsignadasArgs<ExtArgs>
    comentariosBitacora?: boolean | User$comentariosBitacoraArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      etiquetas: Prisma.$EtiquetaPayload<ExtArgs>[]
      proyectosAsignadosComoProyectista: Prisma.$ProjectPayload<ExtArgs>[]
      proyectosAsignadosComoFormulador: Prisma.$ProjectPayload<ExtArgs>[]
      proyectosComoColaborador: Prisma.$ProjectPayload<ExtArgs>[]
      tareasCreadas: Prisma.$TareaPayload<ExtArgs>[]
      tareasAsignadas: Prisma.$TareaPayload<ExtArgs>[]
      comentariosBitacora: Prisma.$ComentarioBitacoraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etiquetas<T extends User$etiquetasArgs<ExtArgs> = {}>(args?: Subset<T, User$etiquetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findMany"> | Null>
    proyectosAsignadosComoProyectista<T extends User$proyectosAsignadosComoProyectistaArgs<ExtArgs> = {}>(args?: Subset<T, User$proyectosAsignadosComoProyectistaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    proyectosAsignadosComoFormulador<T extends User$proyectosAsignadosComoFormuladorArgs<ExtArgs> = {}>(args?: Subset<T, User$proyectosAsignadosComoFormuladorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    proyectosComoColaborador<T extends User$proyectosComoColaboradorArgs<ExtArgs> = {}>(args?: Subset<T, User$proyectosComoColaboradorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    tareasCreadas<T extends User$tareasCreadasArgs<ExtArgs> = {}>(args?: Subset<T, User$tareasCreadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findMany"> | Null>
    tareasAsignadas<T extends User$tareasAsignadasArgs<ExtArgs> = {}>(args?: Subset<T, User$tareasAsignadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findMany"> | Null>
    comentariosBitacora<T extends User$comentariosBitacoraArgs<ExtArgs> = {}>(args?: Subset<T, User$comentariosBitacoraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.etiquetas
   */
  export type User$etiquetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    where?: EtiquetaWhereInput
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    cursor?: EtiquetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * User.proyectosAsignadosComoProyectista
   */
  export type User$proyectosAsignadosComoProyectistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.proyectosAsignadosComoFormulador
   */
  export type User$proyectosAsignadosComoFormuladorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.proyectosComoColaborador
   */
  export type User$proyectosComoColaboradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.tareasCreadas
   */
  export type User$tareasCreadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    where?: TareaWhereInput
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    cursor?: TareaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * User.tareasAsignadas
   */
  export type User$tareasAsignadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    where?: TareaWhereInput
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    cursor?: TareaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * User.comentariosBitacora
   */
  export type User$comentariosBitacoraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    where?: ComentarioBitacoraWhereInput
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    cursor?: ComentarioBitacoraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioBitacoraScalarFieldEnum | ComentarioBitacoraScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Etiqueta
   */

  export type AggregateEtiqueta = {
    _count: EtiquetaCountAggregateOutputType | null
    _avg: EtiquetaAvgAggregateOutputType | null
    _sum: EtiquetaSumAggregateOutputType | null
    _min: EtiquetaMinAggregateOutputType | null
    _max: EtiquetaMaxAggregateOutputType | null
  }

  export type EtiquetaAvgAggregateOutputType = {
    id: number | null
  }

  export type EtiquetaSumAggregateOutputType = {
    id: number | null
  }

  export type EtiquetaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    color: string | null
  }

  export type EtiquetaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    color: string | null
  }

  export type EtiquetaCountAggregateOutputType = {
    id: number
    nombre: number
    color: number
    _all: number
  }


  export type EtiquetaAvgAggregateInputType = {
    id?: true
  }

  export type EtiquetaSumAggregateInputType = {
    id?: true
  }

  export type EtiquetaMinAggregateInputType = {
    id?: true
    nombre?: true
    color?: true
  }

  export type EtiquetaMaxAggregateInputType = {
    id?: true
    nombre?: true
    color?: true
  }

  export type EtiquetaCountAggregateInputType = {
    id?: true
    nombre?: true
    color?: true
    _all?: true
  }

  export type EtiquetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etiqueta to aggregate.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etiquetas
    **/
    _count?: true | EtiquetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtiquetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtiquetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtiquetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtiquetaMaxAggregateInputType
  }

  export type GetEtiquetaAggregateType<T extends EtiquetaAggregateArgs> = {
        [P in keyof T & keyof AggregateEtiqueta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtiqueta[P]>
      : GetScalarType<T[P], AggregateEtiqueta[P]>
  }




  export type EtiquetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtiquetaWhereInput
    orderBy?: EtiquetaOrderByWithAggregationInput | EtiquetaOrderByWithAggregationInput[]
    by: EtiquetaScalarFieldEnum[] | EtiquetaScalarFieldEnum
    having?: EtiquetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtiquetaCountAggregateInputType | true
    _avg?: EtiquetaAvgAggregateInputType
    _sum?: EtiquetaSumAggregateInputType
    _min?: EtiquetaMinAggregateInputType
    _max?: EtiquetaMaxAggregateInputType
  }

  export type EtiquetaGroupByOutputType = {
    id: number
    nombre: string
    color: string
    _count: EtiquetaCountAggregateOutputType | null
    _avg: EtiquetaAvgAggregateOutputType | null
    _sum: EtiquetaSumAggregateOutputType | null
    _min: EtiquetaMinAggregateOutputType | null
    _max: EtiquetaMaxAggregateOutputType | null
  }

  type GetEtiquetaGroupByPayload<T extends EtiquetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtiquetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtiquetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtiquetaGroupByOutputType[P]>
            : GetScalarType<T[P], EtiquetaGroupByOutputType[P]>
        }
      >
    >


  export type EtiquetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    color?: boolean
    usuarios?: boolean | Etiqueta$usuariosArgs<ExtArgs>
    _count?: boolean | EtiquetaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etiqueta"]>

  export type EtiquetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    color?: boolean
  }, ExtArgs["result"]["etiqueta"]>

  export type EtiquetaSelectScalar = {
    id?: boolean
    nombre?: boolean
    color?: boolean
  }

  export type EtiquetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | Etiqueta$usuariosArgs<ExtArgs>
    _count?: boolean | EtiquetaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EtiquetaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EtiquetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etiqueta"
    objects: {
      usuarios: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      color: string
    }, ExtArgs["result"]["etiqueta"]>
    composites: {}
  }

  type EtiquetaGetPayload<S extends boolean | null | undefined | EtiquetaDefaultArgs> = $Result.GetResult<Prisma.$EtiquetaPayload, S>

  type EtiquetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtiquetaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtiquetaCountAggregateInputType | true
    }

  export interface EtiquetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etiqueta'], meta: { name: 'Etiqueta' } }
    /**
     * Find zero or one Etiqueta that matches the filter.
     * @param {EtiquetaFindUniqueArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtiquetaFindUniqueArgs>(args: SelectSubset<T, EtiquetaFindUniqueArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Etiqueta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EtiquetaFindUniqueOrThrowArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtiquetaFindUniqueOrThrowArgs>(args: SelectSubset<T, EtiquetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Etiqueta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindFirstArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtiquetaFindFirstArgs>(args?: SelectSubset<T, EtiquetaFindFirstArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Etiqueta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindFirstOrThrowArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtiquetaFindFirstOrThrowArgs>(args?: SelectSubset<T, EtiquetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Etiquetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etiquetas
     * const etiquetas = await prisma.etiqueta.findMany()
     * 
     * // Get first 10 Etiquetas
     * const etiquetas = await prisma.etiqueta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etiquetaWithIdOnly = await prisma.etiqueta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtiquetaFindManyArgs>(args?: SelectSubset<T, EtiquetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Etiqueta.
     * @param {EtiquetaCreateArgs} args - Arguments to create a Etiqueta.
     * @example
     * // Create one Etiqueta
     * const Etiqueta = await prisma.etiqueta.create({
     *   data: {
     *     // ... data to create a Etiqueta
     *   }
     * })
     * 
     */
    create<T extends EtiquetaCreateArgs>(args: SelectSubset<T, EtiquetaCreateArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Etiquetas.
     * @param {EtiquetaCreateManyArgs} args - Arguments to create many Etiquetas.
     * @example
     * // Create many Etiquetas
     * const etiqueta = await prisma.etiqueta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtiquetaCreateManyArgs>(args?: SelectSubset<T, EtiquetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Etiquetas and returns the data saved in the database.
     * @param {EtiquetaCreateManyAndReturnArgs} args - Arguments to create many Etiquetas.
     * @example
     * // Create many Etiquetas
     * const etiqueta = await prisma.etiqueta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Etiquetas and only return the `id`
     * const etiquetaWithIdOnly = await prisma.etiqueta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EtiquetaCreateManyAndReturnArgs>(args?: SelectSubset<T, EtiquetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Etiqueta.
     * @param {EtiquetaDeleteArgs} args - Arguments to delete one Etiqueta.
     * @example
     * // Delete one Etiqueta
     * const Etiqueta = await prisma.etiqueta.delete({
     *   where: {
     *     // ... filter to delete one Etiqueta
     *   }
     * })
     * 
     */
    delete<T extends EtiquetaDeleteArgs>(args: SelectSubset<T, EtiquetaDeleteArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Etiqueta.
     * @param {EtiquetaUpdateArgs} args - Arguments to update one Etiqueta.
     * @example
     * // Update one Etiqueta
     * const etiqueta = await prisma.etiqueta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtiquetaUpdateArgs>(args: SelectSubset<T, EtiquetaUpdateArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Etiquetas.
     * @param {EtiquetaDeleteManyArgs} args - Arguments to filter Etiquetas to delete.
     * @example
     * // Delete a few Etiquetas
     * const { count } = await prisma.etiqueta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtiquetaDeleteManyArgs>(args?: SelectSubset<T, EtiquetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etiquetas
     * const etiqueta = await prisma.etiqueta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtiquetaUpdateManyArgs>(args: SelectSubset<T, EtiquetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etiqueta.
     * @param {EtiquetaUpsertArgs} args - Arguments to update or create a Etiqueta.
     * @example
     * // Update or create a Etiqueta
     * const etiqueta = await prisma.etiqueta.upsert({
     *   create: {
     *     // ... data to create a Etiqueta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etiqueta we want to update
     *   }
     * })
     */
    upsert<T extends EtiquetaUpsertArgs>(args: SelectSubset<T, EtiquetaUpsertArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Etiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaCountArgs} args - Arguments to filter Etiquetas to count.
     * @example
     * // Count the number of Etiquetas
     * const count = await prisma.etiqueta.count({
     *   where: {
     *     // ... the filter for the Etiquetas we want to count
     *   }
     * })
    **/
    count<T extends EtiquetaCountArgs>(
      args?: Subset<T, EtiquetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtiquetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtiquetaAggregateArgs>(args: Subset<T, EtiquetaAggregateArgs>): Prisma.PrismaPromise<GetEtiquetaAggregateType<T>>

    /**
     * Group by Etiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtiquetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtiquetaGroupByArgs['orderBy'] }
        : { orderBy?: EtiquetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtiquetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtiquetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etiqueta model
   */
  readonly fields: EtiquetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etiqueta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtiquetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends Etiqueta$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Etiqueta$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Etiqueta model
   */ 
  interface EtiquetaFieldRefs {
    readonly id: FieldRef<"Etiqueta", 'Int'>
    readonly nombre: FieldRef<"Etiqueta", 'String'>
    readonly color: FieldRef<"Etiqueta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Etiqueta findUnique
   */
  export type EtiquetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta findUniqueOrThrow
   */
  export type EtiquetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta findFirst
   */
  export type EtiquetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etiquetas.
     */
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta findFirstOrThrow
   */
  export type EtiquetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etiquetas.
     */
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta findMany
   */
  export type EtiquetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiquetas to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta create
   */
  export type EtiquetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to create a Etiqueta.
     */
    data: XOR<EtiquetaCreateInput, EtiquetaUncheckedCreateInput>
  }

  /**
   * Etiqueta createMany
   */
  export type EtiquetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etiquetas.
     */
    data: EtiquetaCreateManyInput | EtiquetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Etiqueta createManyAndReturn
   */
  export type EtiquetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Etiquetas.
     */
    data: EtiquetaCreateManyInput | EtiquetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Etiqueta update
   */
  export type EtiquetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to update a Etiqueta.
     */
    data: XOR<EtiquetaUpdateInput, EtiquetaUncheckedUpdateInput>
    /**
     * Choose, which Etiqueta to update.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta updateMany
   */
  export type EtiquetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etiquetas.
     */
    data: XOR<EtiquetaUpdateManyMutationInput, EtiquetaUncheckedUpdateManyInput>
    /**
     * Filter which Etiquetas to update
     */
    where?: EtiquetaWhereInput
  }

  /**
   * Etiqueta upsert
   */
  export type EtiquetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The filter to search for the Etiqueta to update in case it exists.
     */
    where: EtiquetaWhereUniqueInput
    /**
     * In case the Etiqueta found by the `where` argument doesn't exist, create a new Etiqueta with this data.
     */
    create: XOR<EtiquetaCreateInput, EtiquetaUncheckedCreateInput>
    /**
     * In case the Etiqueta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtiquetaUpdateInput, EtiquetaUncheckedUpdateInput>
  }

  /**
   * Etiqueta delete
   */
  export type EtiquetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter which Etiqueta to delete.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta deleteMany
   */
  export type EtiquetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etiquetas to delete
     */
    where?: EtiquetaWhereInput
  }

  /**
   * Etiqueta.usuarios
   */
  export type Etiqueta$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Etiqueta without action
   */
  export type EtiquetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    superficieTerreno: number | null
    superficieEdificacion: number | null
    ano: number | null
    estadoId: number | null
    unidadId: number | null
    tipologiaId: number | null
    sectorId: number | null
    proyectistaId: number | null
    formuladorId: number | null
    lineaFinanciamientoId: number | null
    programaId: number | null
    etapaFinanciamientoId: number | null
    monto: Decimal | null
    montoAdjudicado: Decimal | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    superficieTerreno: number | null
    superficieEdificacion: number | null
    ano: number | null
    estadoId: number | null
    unidadId: number | null
    tipologiaId: number | null
    sectorId: number | null
    proyectistaId: number | null
    formuladorId: number | null
    lineaFinanciamientoId: number | null
    programaId: number | null
    etapaFinanciamientoId: number | null
    monto: Decimal | null
    montoAdjudicado: Decimal | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    codigoUnico: string | null
    nombre: string | null
    descripcion: string | null
    direccion: string | null
    superficieTerreno: number | null
    superficieEdificacion: number | null
    ano: number | null
    proyectoPriorizado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    estadoId: number | null
    unidadId: number | null
    tipologiaId: number | null
    sectorId: number | null
    proyectistaId: number | null
    formuladorId: number | null
    lineaFinanciamientoId: number | null
    programaId: number | null
    etapaFinanciamientoId: number | null
    codigoExpediente: string | null
    fechaPostulacion: Date | null
    monto: Decimal | null
    tipoMoneda: $Enums.TipoMoneda | null
    montoAdjudicado: Decimal | null
    codigoLicitacion: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    codigoUnico: string | null
    nombre: string | null
    descripcion: string | null
    direccion: string | null
    superficieTerreno: number | null
    superficieEdificacion: number | null
    ano: number | null
    proyectoPriorizado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    estadoId: number | null
    unidadId: number | null
    tipologiaId: number | null
    sectorId: number | null
    proyectistaId: number | null
    formuladorId: number | null
    lineaFinanciamientoId: number | null
    programaId: number | null
    etapaFinanciamientoId: number | null
    codigoExpediente: string | null
    fechaPostulacion: Date | null
    monto: Decimal | null
    tipoMoneda: $Enums.TipoMoneda | null
    montoAdjudicado: Decimal | null
    codigoLicitacion: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    codigoUnico: number
    nombre: number
    descripcion: number
    direccion: number
    superficieTerreno: number
    superficieEdificacion: number
    ano: number
    proyectoPriorizado: number
    createdAt: number
    updatedAt: number
    estadoId: number
    unidadId: number
    tipologiaId: number
    sectorId: number
    proyectistaId: number
    formuladorId: number
    lineaFinanciamientoId: number
    programaId: number
    etapaFinanciamientoId: number
    codigoExpediente: number
    fechaPostulacion: number
    monto: number
    tipoMoneda: number
    montoAdjudicado: number
    codigoLicitacion: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    superficieTerreno?: true
    superficieEdificacion?: true
    ano?: true
    estadoId?: true
    unidadId?: true
    tipologiaId?: true
    sectorId?: true
    proyectistaId?: true
    formuladorId?: true
    lineaFinanciamientoId?: true
    programaId?: true
    etapaFinanciamientoId?: true
    monto?: true
    montoAdjudicado?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    superficieTerreno?: true
    superficieEdificacion?: true
    ano?: true
    estadoId?: true
    unidadId?: true
    tipologiaId?: true
    sectorId?: true
    proyectistaId?: true
    formuladorId?: true
    lineaFinanciamientoId?: true
    programaId?: true
    etapaFinanciamientoId?: true
    monto?: true
    montoAdjudicado?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    codigoUnico?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    superficieTerreno?: true
    superficieEdificacion?: true
    ano?: true
    proyectoPriorizado?: true
    createdAt?: true
    updatedAt?: true
    estadoId?: true
    unidadId?: true
    tipologiaId?: true
    sectorId?: true
    proyectistaId?: true
    formuladorId?: true
    lineaFinanciamientoId?: true
    programaId?: true
    etapaFinanciamientoId?: true
    codigoExpediente?: true
    fechaPostulacion?: true
    monto?: true
    tipoMoneda?: true
    montoAdjudicado?: true
    codigoLicitacion?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    codigoUnico?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    superficieTerreno?: true
    superficieEdificacion?: true
    ano?: true
    proyectoPriorizado?: true
    createdAt?: true
    updatedAt?: true
    estadoId?: true
    unidadId?: true
    tipologiaId?: true
    sectorId?: true
    proyectistaId?: true
    formuladorId?: true
    lineaFinanciamientoId?: true
    programaId?: true
    etapaFinanciamientoId?: true
    codigoExpediente?: true
    fechaPostulacion?: true
    monto?: true
    tipoMoneda?: true
    montoAdjudicado?: true
    codigoLicitacion?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    codigoUnico?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    superficieTerreno?: true
    superficieEdificacion?: true
    ano?: true
    proyectoPriorizado?: true
    createdAt?: true
    updatedAt?: true
    estadoId?: true
    unidadId?: true
    tipologiaId?: true
    sectorId?: true
    proyectistaId?: true
    formuladorId?: true
    lineaFinanciamientoId?: true
    programaId?: true
    etapaFinanciamientoId?: true
    codigoExpediente?: true
    fechaPostulacion?: true
    monto?: true
    tipoMoneda?: true
    montoAdjudicado?: true
    codigoLicitacion?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    codigoUnico: string
    nombre: string
    descripcion: string | null
    direccion: string | null
    superficieTerreno: number | null
    superficieEdificacion: number | null
    ano: number | null
    proyectoPriorizado: boolean
    createdAt: Date
    updatedAt: Date
    estadoId: number | null
    unidadId: number | null
    tipologiaId: number | null
    sectorId: number | null
    proyectistaId: number | null
    formuladorId: number | null
    lineaFinanciamientoId: number | null
    programaId: number | null
    etapaFinanciamientoId: number | null
    codigoExpediente: string | null
    fechaPostulacion: Date | null
    monto: Decimal | null
    tipoMoneda: $Enums.TipoMoneda
    montoAdjudicado: Decimal | null
    codigoLicitacion: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    superficieTerreno?: boolean
    superficieEdificacion?: boolean
    ano?: boolean
    proyectoPriorizado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estadoId?: boolean
    unidadId?: boolean
    tipologiaId?: boolean
    sectorId?: boolean
    proyectistaId?: boolean
    formuladorId?: boolean
    lineaFinanciamientoId?: boolean
    programaId?: boolean
    etapaFinanciamientoId?: boolean
    codigoExpediente?: boolean
    fechaPostulacion?: boolean
    monto?: boolean
    tipoMoneda?: boolean
    montoAdjudicado?: boolean
    codigoLicitacion?: boolean
    estado?: boolean | Project$estadoArgs<ExtArgs>
    unidad?: boolean | Project$unidadArgs<ExtArgs>
    tipologia?: boolean | Project$tipologiaArgs<ExtArgs>
    sector?: boolean | Project$sectorArgs<ExtArgs>
    proyectista?: boolean | Project$proyectistaArgs<ExtArgs>
    formulador?: boolean | Project$formuladorArgs<ExtArgs>
    colaboradores?: boolean | Project$colaboradoresArgs<ExtArgs>
    lineaFinanciamiento?: boolean | Project$lineaFinanciamientoArgs<ExtArgs>
    programa?: boolean | Project$programaArgs<ExtArgs>
    etapaActualFinanciamiento?: boolean | Project$etapaActualFinanciamientoArgs<ExtArgs>
    tareas?: boolean | Project$tareasArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    superficieTerreno?: boolean
    superficieEdificacion?: boolean
    ano?: boolean
    proyectoPriorizado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estadoId?: boolean
    unidadId?: boolean
    tipologiaId?: boolean
    sectorId?: boolean
    proyectistaId?: boolean
    formuladorId?: boolean
    lineaFinanciamientoId?: boolean
    programaId?: boolean
    etapaFinanciamientoId?: boolean
    codigoExpediente?: boolean
    fechaPostulacion?: boolean
    monto?: boolean
    tipoMoneda?: boolean
    montoAdjudicado?: boolean
    codigoLicitacion?: boolean
    estado?: boolean | Project$estadoArgs<ExtArgs>
    unidad?: boolean | Project$unidadArgs<ExtArgs>
    tipologia?: boolean | Project$tipologiaArgs<ExtArgs>
    sector?: boolean | Project$sectorArgs<ExtArgs>
    proyectista?: boolean | Project$proyectistaArgs<ExtArgs>
    formulador?: boolean | Project$formuladorArgs<ExtArgs>
    lineaFinanciamiento?: boolean | Project$lineaFinanciamientoArgs<ExtArgs>
    programa?: boolean | Project$programaArgs<ExtArgs>
    etapaActualFinanciamiento?: boolean | Project$etapaActualFinanciamientoArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    codigoUnico?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    superficieTerreno?: boolean
    superficieEdificacion?: boolean
    ano?: boolean
    proyectoPriorizado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estadoId?: boolean
    unidadId?: boolean
    tipologiaId?: boolean
    sectorId?: boolean
    proyectistaId?: boolean
    formuladorId?: boolean
    lineaFinanciamientoId?: boolean
    programaId?: boolean
    etapaFinanciamientoId?: boolean
    codigoExpediente?: boolean
    fechaPostulacion?: boolean
    monto?: boolean
    tipoMoneda?: boolean
    montoAdjudicado?: boolean
    codigoLicitacion?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | Project$estadoArgs<ExtArgs>
    unidad?: boolean | Project$unidadArgs<ExtArgs>
    tipologia?: boolean | Project$tipologiaArgs<ExtArgs>
    sector?: boolean | Project$sectorArgs<ExtArgs>
    proyectista?: boolean | Project$proyectistaArgs<ExtArgs>
    formulador?: boolean | Project$formuladorArgs<ExtArgs>
    colaboradores?: boolean | Project$colaboradoresArgs<ExtArgs>
    lineaFinanciamiento?: boolean | Project$lineaFinanciamientoArgs<ExtArgs>
    programa?: boolean | Project$programaArgs<ExtArgs>
    etapaActualFinanciamiento?: boolean | Project$etapaActualFinanciamientoArgs<ExtArgs>
    tareas?: boolean | Project$tareasArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | Project$estadoArgs<ExtArgs>
    unidad?: boolean | Project$unidadArgs<ExtArgs>
    tipologia?: boolean | Project$tipologiaArgs<ExtArgs>
    sector?: boolean | Project$sectorArgs<ExtArgs>
    proyectista?: boolean | Project$proyectistaArgs<ExtArgs>
    formulador?: boolean | Project$formuladorArgs<ExtArgs>
    lineaFinanciamiento?: boolean | Project$lineaFinanciamientoArgs<ExtArgs>
    programa?: boolean | Project$programaArgs<ExtArgs>
    etapaActualFinanciamiento?: boolean | Project$etapaActualFinanciamientoArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      estado: Prisma.$EstadoProyectoPayload<ExtArgs> | null
      unidad: Prisma.$UnidadMunicipalPayload<ExtArgs> | null
      tipologia: Prisma.$TipologiaProyectoPayload<ExtArgs> | null
      sector: Prisma.$SectorPayload<ExtArgs> | null
      proyectista: Prisma.$UserPayload<ExtArgs> | null
      formulador: Prisma.$UserPayload<ExtArgs> | null
      colaboradores: Prisma.$UserPayload<ExtArgs>[]
      lineaFinanciamiento: Prisma.$LineaFinanciamientoPayload<ExtArgs> | null
      programa: Prisma.$ProgramaPayload<ExtArgs> | null
      etapaActualFinanciamiento: Prisma.$EtapaFinanciamientoPayload<ExtArgs> | null
      tareas: Prisma.$TareaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoUnico: string
      nombre: string
      descripcion: string | null
      direccion: string | null
      superficieTerreno: number | null
      superficieEdificacion: number | null
      ano: number | null
      proyectoPriorizado: boolean
      createdAt: Date
      updatedAt: Date
      estadoId: number | null
      unidadId: number | null
      tipologiaId: number | null
      sectorId: number | null
      proyectistaId: number | null
      formuladorId: number | null
      lineaFinanciamientoId: number | null
      programaId: number | null
      etapaFinanciamientoId: number | null
      codigoExpediente: string | null
      fechaPostulacion: Date | null
      monto: Prisma.Decimal | null
      tipoMoneda: $Enums.TipoMoneda
      montoAdjudicado: Prisma.Decimal | null
      codigoLicitacion: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estado<T extends Project$estadoArgs<ExtArgs> = {}>(args?: Subset<T, Project$estadoArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    unidad<T extends Project$unidadArgs<ExtArgs> = {}>(args?: Subset<T, Project$unidadArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tipologia<T extends Project$tipologiaArgs<ExtArgs> = {}>(args?: Subset<T, Project$tipologiaArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sector<T extends Project$sectorArgs<ExtArgs> = {}>(args?: Subset<T, Project$sectorArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    proyectista<T extends Project$proyectistaArgs<ExtArgs> = {}>(args?: Subset<T, Project$proyectistaArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    formulador<T extends Project$formuladorArgs<ExtArgs> = {}>(args?: Subset<T, Project$formuladorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    colaboradores<T extends Project$colaboradoresArgs<ExtArgs> = {}>(args?: Subset<T, Project$colaboradoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    lineaFinanciamiento<T extends Project$lineaFinanciamientoArgs<ExtArgs> = {}>(args?: Subset<T, Project$lineaFinanciamientoArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    programa<T extends Project$programaArgs<ExtArgs> = {}>(args?: Subset<T, Project$programaArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    etapaActualFinanciamiento<T extends Project$etapaActualFinanciamientoArgs<ExtArgs> = {}>(args?: Subset<T, Project$etapaActualFinanciamientoArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tareas<T extends Project$tareasArgs<ExtArgs> = {}>(args?: Subset<T, Project$tareasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly codigoUnico: FieldRef<"Project", 'String'>
    readonly nombre: FieldRef<"Project", 'String'>
    readonly descripcion: FieldRef<"Project", 'String'>
    readonly direccion: FieldRef<"Project", 'String'>
    readonly superficieTerreno: FieldRef<"Project", 'Float'>
    readonly superficieEdificacion: FieldRef<"Project", 'Float'>
    readonly ano: FieldRef<"Project", 'Int'>
    readonly proyectoPriorizado: FieldRef<"Project", 'Boolean'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly estadoId: FieldRef<"Project", 'Int'>
    readonly unidadId: FieldRef<"Project", 'Int'>
    readonly tipologiaId: FieldRef<"Project", 'Int'>
    readonly sectorId: FieldRef<"Project", 'Int'>
    readonly proyectistaId: FieldRef<"Project", 'Int'>
    readonly formuladorId: FieldRef<"Project", 'Int'>
    readonly lineaFinanciamientoId: FieldRef<"Project", 'Int'>
    readonly programaId: FieldRef<"Project", 'Int'>
    readonly etapaFinanciamientoId: FieldRef<"Project", 'Int'>
    readonly codigoExpediente: FieldRef<"Project", 'String'>
    readonly fechaPostulacion: FieldRef<"Project", 'DateTime'>
    readonly monto: FieldRef<"Project", 'Decimal'>
    readonly tipoMoneda: FieldRef<"Project", 'TipoMoneda'>
    readonly montoAdjudicado: FieldRef<"Project", 'Decimal'>
    readonly codigoLicitacion: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.estado
   */
  export type Project$estadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    where?: EstadoProyectoWhereInput
  }

  /**
   * Project.unidad
   */
  export type Project$unidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    where?: UnidadMunicipalWhereInput
  }

  /**
   * Project.tipologia
   */
  export type Project$tipologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    where?: TipologiaProyectoWhereInput
  }

  /**
   * Project.sector
   */
  export type Project$sectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    where?: SectorWhereInput
  }

  /**
   * Project.proyectista
   */
  export type Project$proyectistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.formulador
   */
  export type Project$formuladorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.colaboradores
   */
  export type Project$colaboradoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Project.lineaFinanciamiento
   */
  export type Project$lineaFinanciamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    where?: LineaFinanciamientoWhereInput
  }

  /**
   * Project.programa
   */
  export type Project$programaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    where?: ProgramaWhereInput
  }

  /**
   * Project.etapaActualFinanciamiento
   */
  export type Project$etapaActualFinanciamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    where?: EtapaFinanciamientoWhereInput
  }

  /**
   * Project.tareas
   */
  export type Project$tareasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    where?: TareaWhereInput
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    cursor?: TareaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model EstadoProyecto
   */

  export type AggregateEstadoProyecto = {
    _count: EstadoProyectoCountAggregateOutputType | null
    _avg: EstadoProyectoAvgAggregateOutputType | null
    _sum: EstadoProyectoSumAggregateOutputType | null
    _min: EstadoProyectoMinAggregateOutputType | null
    _max: EstadoProyectoMaxAggregateOutputType | null
  }

  export type EstadoProyectoAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoProyectoSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoProyectoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EstadoProyectoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EstadoProyectoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type EstadoProyectoAvgAggregateInputType = {
    id?: true
  }

  export type EstadoProyectoSumAggregateInputType = {
    id?: true
  }

  export type EstadoProyectoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EstadoProyectoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EstadoProyectoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type EstadoProyectoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstadoProyecto to aggregate.
     */
    where?: EstadoProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoProyectos to fetch.
     */
    orderBy?: EstadoProyectoOrderByWithRelationInput | EstadoProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstadoProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstadoProyectos
    **/
    _count?: true | EstadoProyectoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoProyectoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoProyectoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoProyectoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoProyectoMaxAggregateInputType
  }

  export type GetEstadoProyectoAggregateType<T extends EstadoProyectoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoProyecto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoProyecto[P]>
      : GetScalarType<T[P], AggregateEstadoProyecto[P]>
  }




  export type EstadoProyectoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstadoProyectoWhereInput
    orderBy?: EstadoProyectoOrderByWithAggregationInput | EstadoProyectoOrderByWithAggregationInput[]
    by: EstadoProyectoScalarFieldEnum[] | EstadoProyectoScalarFieldEnum
    having?: EstadoProyectoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoProyectoCountAggregateInputType | true
    _avg?: EstadoProyectoAvgAggregateInputType
    _sum?: EstadoProyectoSumAggregateInputType
    _min?: EstadoProyectoMinAggregateInputType
    _max?: EstadoProyectoMaxAggregateInputType
  }

  export type EstadoProyectoGroupByOutputType = {
    id: number
    nombre: string
    _count: EstadoProyectoCountAggregateOutputType | null
    _avg: EstadoProyectoAvgAggregateOutputType | null
    _sum: EstadoProyectoSumAggregateOutputType | null
    _min: EstadoProyectoMinAggregateOutputType | null
    _max: EstadoProyectoMaxAggregateOutputType | null
  }

  type GetEstadoProyectoGroupByPayload<T extends EstadoProyectoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoProyectoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoProyectoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoProyectoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoProyectoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoProyectoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proyectos?: boolean | EstadoProyecto$proyectosArgs<ExtArgs>
    _count?: boolean | EstadoProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estadoProyecto"]>

  export type EstadoProyectoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["estadoProyecto"]>

  export type EstadoProyectoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type EstadoProyectoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | EstadoProyecto$proyectosArgs<ExtArgs>
    _count?: boolean | EstadoProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstadoProyectoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EstadoProyectoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EstadoProyecto"
    objects: {
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["estadoProyecto"]>
    composites: {}
  }

  type EstadoProyectoGetPayload<S extends boolean | null | undefined | EstadoProyectoDefaultArgs> = $Result.GetResult<Prisma.$EstadoProyectoPayload, S>

  type EstadoProyectoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstadoProyectoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadoProyectoCountAggregateInputType | true
    }

  export interface EstadoProyectoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EstadoProyecto'], meta: { name: 'EstadoProyecto' } }
    /**
     * Find zero or one EstadoProyecto that matches the filter.
     * @param {EstadoProyectoFindUniqueArgs} args - Arguments to find a EstadoProyecto
     * @example
     * // Get one EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstadoProyectoFindUniqueArgs>(args: SelectSubset<T, EstadoProyectoFindUniqueArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EstadoProyecto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstadoProyectoFindUniqueOrThrowArgs} args - Arguments to find a EstadoProyecto
     * @example
     * // Get one EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstadoProyectoFindUniqueOrThrowArgs>(args: SelectSubset<T, EstadoProyectoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EstadoProyecto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoFindFirstArgs} args - Arguments to find a EstadoProyecto
     * @example
     * // Get one EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstadoProyectoFindFirstArgs>(args?: SelectSubset<T, EstadoProyectoFindFirstArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EstadoProyecto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoFindFirstOrThrowArgs} args - Arguments to find a EstadoProyecto
     * @example
     * // Get one EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstadoProyectoFindFirstOrThrowArgs>(args?: SelectSubset<T, EstadoProyectoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EstadoProyectos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoProyectos
     * const estadoProyectos = await prisma.estadoProyecto.findMany()
     * 
     * // Get first 10 EstadoProyectos
     * const estadoProyectos = await prisma.estadoProyecto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoProyectoWithIdOnly = await prisma.estadoProyecto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstadoProyectoFindManyArgs>(args?: SelectSubset<T, EstadoProyectoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EstadoProyecto.
     * @param {EstadoProyectoCreateArgs} args - Arguments to create a EstadoProyecto.
     * @example
     * // Create one EstadoProyecto
     * const EstadoProyecto = await prisma.estadoProyecto.create({
     *   data: {
     *     // ... data to create a EstadoProyecto
     *   }
     * })
     * 
     */
    create<T extends EstadoProyectoCreateArgs>(args: SelectSubset<T, EstadoProyectoCreateArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EstadoProyectos.
     * @param {EstadoProyectoCreateManyArgs} args - Arguments to create many EstadoProyectos.
     * @example
     * // Create many EstadoProyectos
     * const estadoProyecto = await prisma.estadoProyecto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstadoProyectoCreateManyArgs>(args?: SelectSubset<T, EstadoProyectoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EstadoProyectos and returns the data saved in the database.
     * @param {EstadoProyectoCreateManyAndReturnArgs} args - Arguments to create many EstadoProyectos.
     * @example
     * // Create many EstadoProyectos
     * const estadoProyecto = await prisma.estadoProyecto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EstadoProyectos and only return the `id`
     * const estadoProyectoWithIdOnly = await prisma.estadoProyecto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstadoProyectoCreateManyAndReturnArgs>(args?: SelectSubset<T, EstadoProyectoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EstadoProyecto.
     * @param {EstadoProyectoDeleteArgs} args - Arguments to delete one EstadoProyecto.
     * @example
     * // Delete one EstadoProyecto
     * const EstadoProyecto = await prisma.estadoProyecto.delete({
     *   where: {
     *     // ... filter to delete one EstadoProyecto
     *   }
     * })
     * 
     */
    delete<T extends EstadoProyectoDeleteArgs>(args: SelectSubset<T, EstadoProyectoDeleteArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EstadoProyecto.
     * @param {EstadoProyectoUpdateArgs} args - Arguments to update one EstadoProyecto.
     * @example
     * // Update one EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstadoProyectoUpdateArgs>(args: SelectSubset<T, EstadoProyectoUpdateArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EstadoProyectos.
     * @param {EstadoProyectoDeleteManyArgs} args - Arguments to filter EstadoProyectos to delete.
     * @example
     * // Delete a few EstadoProyectos
     * const { count } = await prisma.estadoProyecto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstadoProyectoDeleteManyArgs>(args?: SelectSubset<T, EstadoProyectoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoProyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoProyectos
     * const estadoProyecto = await prisma.estadoProyecto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstadoProyectoUpdateManyArgs>(args: SelectSubset<T, EstadoProyectoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EstadoProyecto.
     * @param {EstadoProyectoUpsertArgs} args - Arguments to update or create a EstadoProyecto.
     * @example
     * // Update or create a EstadoProyecto
     * const estadoProyecto = await prisma.estadoProyecto.upsert({
     *   create: {
     *     // ... data to create a EstadoProyecto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoProyecto we want to update
     *   }
     * })
     */
    upsert<T extends EstadoProyectoUpsertArgs>(args: SelectSubset<T, EstadoProyectoUpsertArgs<ExtArgs>>): Prisma__EstadoProyectoClient<$Result.GetResult<Prisma.$EstadoProyectoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EstadoProyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoCountArgs} args - Arguments to filter EstadoProyectos to count.
     * @example
     * // Count the number of EstadoProyectos
     * const count = await prisma.estadoProyecto.count({
     *   where: {
     *     // ... the filter for the EstadoProyectos we want to count
     *   }
     * })
    **/
    count<T extends EstadoProyectoCountArgs>(
      args?: Subset<T, EstadoProyectoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoProyectoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoProyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoProyectoAggregateArgs>(args: Subset<T, EstadoProyectoAggregateArgs>): Prisma.PrismaPromise<GetEstadoProyectoAggregateType<T>>

    /**
     * Group by EstadoProyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoProyectoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoProyectoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoProyectoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoProyectoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoProyectoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoProyectoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EstadoProyecto model
   */
  readonly fields: EstadoProyectoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstadoProyecto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstadoProyectoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyectos<T extends EstadoProyecto$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, EstadoProyecto$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EstadoProyecto model
   */ 
  interface EstadoProyectoFieldRefs {
    readonly id: FieldRef<"EstadoProyecto", 'Int'>
    readonly nombre: FieldRef<"EstadoProyecto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EstadoProyecto findUnique
   */
  export type EstadoProyectoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter, which EstadoProyecto to fetch.
     */
    where: EstadoProyectoWhereUniqueInput
  }

  /**
   * EstadoProyecto findUniqueOrThrow
   */
  export type EstadoProyectoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter, which EstadoProyecto to fetch.
     */
    where: EstadoProyectoWhereUniqueInput
  }

  /**
   * EstadoProyecto findFirst
   */
  export type EstadoProyectoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter, which EstadoProyecto to fetch.
     */
    where?: EstadoProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoProyectos to fetch.
     */
    orderBy?: EstadoProyectoOrderByWithRelationInput | EstadoProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoProyectos.
     */
    cursor?: EstadoProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoProyectos.
     */
    distinct?: EstadoProyectoScalarFieldEnum | EstadoProyectoScalarFieldEnum[]
  }

  /**
   * EstadoProyecto findFirstOrThrow
   */
  export type EstadoProyectoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter, which EstadoProyecto to fetch.
     */
    where?: EstadoProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoProyectos to fetch.
     */
    orderBy?: EstadoProyectoOrderByWithRelationInput | EstadoProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoProyectos.
     */
    cursor?: EstadoProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoProyectos.
     */
    distinct?: EstadoProyectoScalarFieldEnum | EstadoProyectoScalarFieldEnum[]
  }

  /**
   * EstadoProyecto findMany
   */
  export type EstadoProyectoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter, which EstadoProyectos to fetch.
     */
    where?: EstadoProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoProyectos to fetch.
     */
    orderBy?: EstadoProyectoOrderByWithRelationInput | EstadoProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstadoProyectos.
     */
    cursor?: EstadoProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoProyectos.
     */
    skip?: number
    distinct?: EstadoProyectoScalarFieldEnum | EstadoProyectoScalarFieldEnum[]
  }

  /**
   * EstadoProyecto create
   */
  export type EstadoProyectoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * The data needed to create a EstadoProyecto.
     */
    data: XOR<EstadoProyectoCreateInput, EstadoProyectoUncheckedCreateInput>
  }

  /**
   * EstadoProyecto createMany
   */
  export type EstadoProyectoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EstadoProyectos.
     */
    data: EstadoProyectoCreateManyInput | EstadoProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EstadoProyecto createManyAndReturn
   */
  export type EstadoProyectoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EstadoProyectos.
     */
    data: EstadoProyectoCreateManyInput | EstadoProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EstadoProyecto update
   */
  export type EstadoProyectoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * The data needed to update a EstadoProyecto.
     */
    data: XOR<EstadoProyectoUpdateInput, EstadoProyectoUncheckedUpdateInput>
    /**
     * Choose, which EstadoProyecto to update.
     */
    where: EstadoProyectoWhereUniqueInput
  }

  /**
   * EstadoProyecto updateMany
   */
  export type EstadoProyectoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EstadoProyectos.
     */
    data: XOR<EstadoProyectoUpdateManyMutationInput, EstadoProyectoUncheckedUpdateManyInput>
    /**
     * Filter which EstadoProyectos to update
     */
    where?: EstadoProyectoWhereInput
  }

  /**
   * EstadoProyecto upsert
   */
  export type EstadoProyectoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * The filter to search for the EstadoProyecto to update in case it exists.
     */
    where: EstadoProyectoWhereUniqueInput
    /**
     * In case the EstadoProyecto found by the `where` argument doesn't exist, create a new EstadoProyecto with this data.
     */
    create: XOR<EstadoProyectoCreateInput, EstadoProyectoUncheckedCreateInput>
    /**
     * In case the EstadoProyecto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstadoProyectoUpdateInput, EstadoProyectoUncheckedUpdateInput>
  }

  /**
   * EstadoProyecto delete
   */
  export type EstadoProyectoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
    /**
     * Filter which EstadoProyecto to delete.
     */
    where: EstadoProyectoWhereUniqueInput
  }

  /**
   * EstadoProyecto deleteMany
   */
  export type EstadoProyectoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstadoProyectos to delete
     */
    where?: EstadoProyectoWhereInput
  }

  /**
   * EstadoProyecto.proyectos
   */
  export type EstadoProyecto$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * EstadoProyecto without action
   */
  export type EstadoProyectoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoProyecto
     */
    select?: EstadoProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoProyectoInclude<ExtArgs> | null
  }


  /**
   * Model UnidadMunicipal
   */

  export type AggregateUnidadMunicipal = {
    _count: UnidadMunicipalCountAggregateOutputType | null
    _avg: UnidadMunicipalAvgAggregateOutputType | null
    _sum: UnidadMunicipalSumAggregateOutputType | null
    _min: UnidadMunicipalMinAggregateOutputType | null
    _max: UnidadMunicipalMaxAggregateOutputType | null
  }

  export type UnidadMunicipalAvgAggregateOutputType = {
    id: number | null
  }

  export type UnidadMunicipalSumAggregateOutputType = {
    id: number | null
  }

  export type UnidadMunicipalMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    abreviacion: string | null
  }

  export type UnidadMunicipalMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    abreviacion: string | null
  }

  export type UnidadMunicipalCountAggregateOutputType = {
    id: number
    nombre: number
    abreviacion: number
    _all: number
  }


  export type UnidadMunicipalAvgAggregateInputType = {
    id?: true
  }

  export type UnidadMunicipalSumAggregateInputType = {
    id?: true
  }

  export type UnidadMunicipalMinAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
  }

  export type UnidadMunicipalMaxAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
  }

  export type UnidadMunicipalCountAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
    _all?: true
  }

  export type UnidadMunicipalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadMunicipal to aggregate.
     */
    where?: UnidadMunicipalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadMunicipals to fetch.
     */
    orderBy?: UnidadMunicipalOrderByWithRelationInput | UnidadMunicipalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnidadMunicipalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadMunicipals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadMunicipals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnidadMunicipals
    **/
    _count?: true | UnidadMunicipalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnidadMunicipalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnidadMunicipalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnidadMunicipalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnidadMunicipalMaxAggregateInputType
  }

  export type GetUnidadMunicipalAggregateType<T extends UnidadMunicipalAggregateArgs> = {
        [P in keyof T & keyof AggregateUnidadMunicipal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnidadMunicipal[P]>
      : GetScalarType<T[P], AggregateUnidadMunicipal[P]>
  }




  export type UnidadMunicipalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnidadMunicipalWhereInput
    orderBy?: UnidadMunicipalOrderByWithAggregationInput | UnidadMunicipalOrderByWithAggregationInput[]
    by: UnidadMunicipalScalarFieldEnum[] | UnidadMunicipalScalarFieldEnum
    having?: UnidadMunicipalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnidadMunicipalCountAggregateInputType | true
    _avg?: UnidadMunicipalAvgAggregateInputType
    _sum?: UnidadMunicipalSumAggregateInputType
    _min?: UnidadMunicipalMinAggregateInputType
    _max?: UnidadMunicipalMaxAggregateInputType
  }

  export type UnidadMunicipalGroupByOutputType = {
    id: number
    nombre: string
    abreviacion: string
    _count: UnidadMunicipalCountAggregateOutputType | null
    _avg: UnidadMunicipalAvgAggregateOutputType | null
    _sum: UnidadMunicipalSumAggregateOutputType | null
    _min: UnidadMunicipalMinAggregateOutputType | null
    _max: UnidadMunicipalMaxAggregateOutputType | null
  }

  type GetUnidadMunicipalGroupByPayload<T extends UnidadMunicipalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnidadMunicipalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnidadMunicipalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnidadMunicipalGroupByOutputType[P]>
            : GetScalarType<T[P], UnidadMunicipalGroupByOutputType[P]>
        }
      >
    >


  export type UnidadMunicipalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
    proyectos?: boolean | UnidadMunicipal$proyectosArgs<ExtArgs>
    _count?: boolean | UnidadMunicipalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidadMunicipal"]>

  export type UnidadMunicipalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
  }, ExtArgs["result"]["unidadMunicipal"]>

  export type UnidadMunicipalSelectScalar = {
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
  }

  export type UnidadMunicipalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | UnidadMunicipal$proyectosArgs<ExtArgs>
    _count?: boolean | UnidadMunicipalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnidadMunicipalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnidadMunicipalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnidadMunicipal"
    objects: {
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      abreviacion: string
    }, ExtArgs["result"]["unidadMunicipal"]>
    composites: {}
  }

  type UnidadMunicipalGetPayload<S extends boolean | null | undefined | UnidadMunicipalDefaultArgs> = $Result.GetResult<Prisma.$UnidadMunicipalPayload, S>

  type UnidadMunicipalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnidadMunicipalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnidadMunicipalCountAggregateInputType | true
    }

  export interface UnidadMunicipalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnidadMunicipal'], meta: { name: 'UnidadMunicipal' } }
    /**
     * Find zero or one UnidadMunicipal that matches the filter.
     * @param {UnidadMunicipalFindUniqueArgs} args - Arguments to find a UnidadMunicipal
     * @example
     * // Get one UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnidadMunicipalFindUniqueArgs>(args: SelectSubset<T, UnidadMunicipalFindUniqueArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnidadMunicipal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnidadMunicipalFindUniqueOrThrowArgs} args - Arguments to find a UnidadMunicipal
     * @example
     * // Get one UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnidadMunicipalFindUniqueOrThrowArgs>(args: SelectSubset<T, UnidadMunicipalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnidadMunicipal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalFindFirstArgs} args - Arguments to find a UnidadMunicipal
     * @example
     * // Get one UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnidadMunicipalFindFirstArgs>(args?: SelectSubset<T, UnidadMunicipalFindFirstArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnidadMunicipal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalFindFirstOrThrowArgs} args - Arguments to find a UnidadMunicipal
     * @example
     * // Get one UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnidadMunicipalFindFirstOrThrowArgs>(args?: SelectSubset<T, UnidadMunicipalFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnidadMunicipals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnidadMunicipals
     * const unidadMunicipals = await prisma.unidadMunicipal.findMany()
     * 
     * // Get first 10 UnidadMunicipals
     * const unidadMunicipals = await prisma.unidadMunicipal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unidadMunicipalWithIdOnly = await prisma.unidadMunicipal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnidadMunicipalFindManyArgs>(args?: SelectSubset<T, UnidadMunicipalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnidadMunicipal.
     * @param {UnidadMunicipalCreateArgs} args - Arguments to create a UnidadMunicipal.
     * @example
     * // Create one UnidadMunicipal
     * const UnidadMunicipal = await prisma.unidadMunicipal.create({
     *   data: {
     *     // ... data to create a UnidadMunicipal
     *   }
     * })
     * 
     */
    create<T extends UnidadMunicipalCreateArgs>(args: SelectSubset<T, UnidadMunicipalCreateArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnidadMunicipals.
     * @param {UnidadMunicipalCreateManyArgs} args - Arguments to create many UnidadMunicipals.
     * @example
     * // Create many UnidadMunicipals
     * const unidadMunicipal = await prisma.unidadMunicipal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnidadMunicipalCreateManyArgs>(args?: SelectSubset<T, UnidadMunicipalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnidadMunicipals and returns the data saved in the database.
     * @param {UnidadMunicipalCreateManyAndReturnArgs} args - Arguments to create many UnidadMunicipals.
     * @example
     * // Create many UnidadMunicipals
     * const unidadMunicipal = await prisma.unidadMunicipal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnidadMunicipals and only return the `id`
     * const unidadMunicipalWithIdOnly = await prisma.unidadMunicipal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnidadMunicipalCreateManyAndReturnArgs>(args?: SelectSubset<T, UnidadMunicipalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnidadMunicipal.
     * @param {UnidadMunicipalDeleteArgs} args - Arguments to delete one UnidadMunicipal.
     * @example
     * // Delete one UnidadMunicipal
     * const UnidadMunicipal = await prisma.unidadMunicipal.delete({
     *   where: {
     *     // ... filter to delete one UnidadMunicipal
     *   }
     * })
     * 
     */
    delete<T extends UnidadMunicipalDeleteArgs>(args: SelectSubset<T, UnidadMunicipalDeleteArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnidadMunicipal.
     * @param {UnidadMunicipalUpdateArgs} args - Arguments to update one UnidadMunicipal.
     * @example
     * // Update one UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnidadMunicipalUpdateArgs>(args: SelectSubset<T, UnidadMunicipalUpdateArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnidadMunicipals.
     * @param {UnidadMunicipalDeleteManyArgs} args - Arguments to filter UnidadMunicipals to delete.
     * @example
     * // Delete a few UnidadMunicipals
     * const { count } = await prisma.unidadMunicipal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnidadMunicipalDeleteManyArgs>(args?: SelectSubset<T, UnidadMunicipalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnidadMunicipals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnidadMunicipals
     * const unidadMunicipal = await prisma.unidadMunicipal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnidadMunicipalUpdateManyArgs>(args: SelectSubset<T, UnidadMunicipalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnidadMunicipal.
     * @param {UnidadMunicipalUpsertArgs} args - Arguments to update or create a UnidadMunicipal.
     * @example
     * // Update or create a UnidadMunicipal
     * const unidadMunicipal = await prisma.unidadMunicipal.upsert({
     *   create: {
     *     // ... data to create a UnidadMunicipal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnidadMunicipal we want to update
     *   }
     * })
     */
    upsert<T extends UnidadMunicipalUpsertArgs>(args: SelectSubset<T, UnidadMunicipalUpsertArgs<ExtArgs>>): Prisma__UnidadMunicipalClient<$Result.GetResult<Prisma.$UnidadMunicipalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnidadMunicipals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalCountArgs} args - Arguments to filter UnidadMunicipals to count.
     * @example
     * // Count the number of UnidadMunicipals
     * const count = await prisma.unidadMunicipal.count({
     *   where: {
     *     // ... the filter for the UnidadMunicipals we want to count
     *   }
     * })
    **/
    count<T extends UnidadMunicipalCountArgs>(
      args?: Subset<T, UnidadMunicipalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnidadMunicipalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnidadMunicipal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnidadMunicipalAggregateArgs>(args: Subset<T, UnidadMunicipalAggregateArgs>): Prisma.PrismaPromise<GetUnidadMunicipalAggregateType<T>>

    /**
     * Group by UnidadMunicipal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadMunicipalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnidadMunicipalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnidadMunicipalGroupByArgs['orderBy'] }
        : { orderBy?: UnidadMunicipalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnidadMunicipalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnidadMunicipalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnidadMunicipal model
   */
  readonly fields: UnidadMunicipalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnidadMunicipal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnidadMunicipalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyectos<T extends UnidadMunicipal$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, UnidadMunicipal$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnidadMunicipal model
   */ 
  interface UnidadMunicipalFieldRefs {
    readonly id: FieldRef<"UnidadMunicipal", 'Int'>
    readonly nombre: FieldRef<"UnidadMunicipal", 'String'>
    readonly abreviacion: FieldRef<"UnidadMunicipal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnidadMunicipal findUnique
   */
  export type UnidadMunicipalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter, which UnidadMunicipal to fetch.
     */
    where: UnidadMunicipalWhereUniqueInput
  }

  /**
   * UnidadMunicipal findUniqueOrThrow
   */
  export type UnidadMunicipalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter, which UnidadMunicipal to fetch.
     */
    where: UnidadMunicipalWhereUniqueInput
  }

  /**
   * UnidadMunicipal findFirst
   */
  export type UnidadMunicipalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter, which UnidadMunicipal to fetch.
     */
    where?: UnidadMunicipalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadMunicipals to fetch.
     */
    orderBy?: UnidadMunicipalOrderByWithRelationInput | UnidadMunicipalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadMunicipals.
     */
    cursor?: UnidadMunicipalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadMunicipals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadMunicipals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadMunicipals.
     */
    distinct?: UnidadMunicipalScalarFieldEnum | UnidadMunicipalScalarFieldEnum[]
  }

  /**
   * UnidadMunicipal findFirstOrThrow
   */
  export type UnidadMunicipalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter, which UnidadMunicipal to fetch.
     */
    where?: UnidadMunicipalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadMunicipals to fetch.
     */
    orderBy?: UnidadMunicipalOrderByWithRelationInput | UnidadMunicipalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadMunicipals.
     */
    cursor?: UnidadMunicipalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadMunicipals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadMunicipals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadMunicipals.
     */
    distinct?: UnidadMunicipalScalarFieldEnum | UnidadMunicipalScalarFieldEnum[]
  }

  /**
   * UnidadMunicipal findMany
   */
  export type UnidadMunicipalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter, which UnidadMunicipals to fetch.
     */
    where?: UnidadMunicipalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadMunicipals to fetch.
     */
    orderBy?: UnidadMunicipalOrderByWithRelationInput | UnidadMunicipalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnidadMunicipals.
     */
    cursor?: UnidadMunicipalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadMunicipals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadMunicipals.
     */
    skip?: number
    distinct?: UnidadMunicipalScalarFieldEnum | UnidadMunicipalScalarFieldEnum[]
  }

  /**
   * UnidadMunicipal create
   */
  export type UnidadMunicipalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * The data needed to create a UnidadMunicipal.
     */
    data: XOR<UnidadMunicipalCreateInput, UnidadMunicipalUncheckedCreateInput>
  }

  /**
   * UnidadMunicipal createMany
   */
  export type UnidadMunicipalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnidadMunicipals.
     */
    data: UnidadMunicipalCreateManyInput | UnidadMunicipalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnidadMunicipal createManyAndReturn
   */
  export type UnidadMunicipalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnidadMunicipals.
     */
    data: UnidadMunicipalCreateManyInput | UnidadMunicipalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnidadMunicipal update
   */
  export type UnidadMunicipalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * The data needed to update a UnidadMunicipal.
     */
    data: XOR<UnidadMunicipalUpdateInput, UnidadMunicipalUncheckedUpdateInput>
    /**
     * Choose, which UnidadMunicipal to update.
     */
    where: UnidadMunicipalWhereUniqueInput
  }

  /**
   * UnidadMunicipal updateMany
   */
  export type UnidadMunicipalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnidadMunicipals.
     */
    data: XOR<UnidadMunicipalUpdateManyMutationInput, UnidadMunicipalUncheckedUpdateManyInput>
    /**
     * Filter which UnidadMunicipals to update
     */
    where?: UnidadMunicipalWhereInput
  }

  /**
   * UnidadMunicipal upsert
   */
  export type UnidadMunicipalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * The filter to search for the UnidadMunicipal to update in case it exists.
     */
    where: UnidadMunicipalWhereUniqueInput
    /**
     * In case the UnidadMunicipal found by the `where` argument doesn't exist, create a new UnidadMunicipal with this data.
     */
    create: XOR<UnidadMunicipalCreateInput, UnidadMunicipalUncheckedCreateInput>
    /**
     * In case the UnidadMunicipal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnidadMunicipalUpdateInput, UnidadMunicipalUncheckedUpdateInput>
  }

  /**
   * UnidadMunicipal delete
   */
  export type UnidadMunicipalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
    /**
     * Filter which UnidadMunicipal to delete.
     */
    where: UnidadMunicipalWhereUniqueInput
  }

  /**
   * UnidadMunicipal deleteMany
   */
  export type UnidadMunicipalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadMunicipals to delete
     */
    where?: UnidadMunicipalWhereInput
  }

  /**
   * UnidadMunicipal.proyectos
   */
  export type UnidadMunicipal$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * UnidadMunicipal without action
   */
  export type UnidadMunicipalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadMunicipal
     */
    select?: UnidadMunicipalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadMunicipalInclude<ExtArgs> | null
  }


  /**
   * Model TipologiaProyecto
   */

  export type AggregateTipologiaProyecto = {
    _count: TipologiaProyectoCountAggregateOutputType | null
    _avg: TipologiaProyectoAvgAggregateOutputType | null
    _sum: TipologiaProyectoSumAggregateOutputType | null
    _min: TipologiaProyectoMinAggregateOutputType | null
    _max: TipologiaProyectoMaxAggregateOutputType | null
  }

  export type TipologiaProyectoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipologiaProyectoSumAggregateOutputType = {
    id: number | null
  }

  export type TipologiaProyectoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    abreviacion: string | null
    colorChip: string | null
  }

  export type TipologiaProyectoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    abreviacion: string | null
    colorChip: string | null
  }

  export type TipologiaProyectoCountAggregateOutputType = {
    id: number
    nombre: number
    abreviacion: number
    colorChip: number
    _all: number
  }


  export type TipologiaProyectoAvgAggregateInputType = {
    id?: true
  }

  export type TipologiaProyectoSumAggregateInputType = {
    id?: true
  }

  export type TipologiaProyectoMinAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
    colorChip?: true
  }

  export type TipologiaProyectoMaxAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
    colorChip?: true
  }

  export type TipologiaProyectoCountAggregateInputType = {
    id?: true
    nombre?: true
    abreviacion?: true
    colorChip?: true
    _all?: true
  }

  export type TipologiaProyectoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipologiaProyecto to aggregate.
     */
    where?: TipologiaProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipologiaProyectos to fetch.
     */
    orderBy?: TipologiaProyectoOrderByWithRelationInput | TipologiaProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipologiaProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipologiaProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipologiaProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipologiaProyectos
    **/
    _count?: true | TipologiaProyectoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipologiaProyectoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipologiaProyectoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipologiaProyectoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipologiaProyectoMaxAggregateInputType
  }

  export type GetTipologiaProyectoAggregateType<T extends TipologiaProyectoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipologiaProyecto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipologiaProyecto[P]>
      : GetScalarType<T[P], AggregateTipologiaProyecto[P]>
  }




  export type TipologiaProyectoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipologiaProyectoWhereInput
    orderBy?: TipologiaProyectoOrderByWithAggregationInput | TipologiaProyectoOrderByWithAggregationInput[]
    by: TipologiaProyectoScalarFieldEnum[] | TipologiaProyectoScalarFieldEnum
    having?: TipologiaProyectoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipologiaProyectoCountAggregateInputType | true
    _avg?: TipologiaProyectoAvgAggregateInputType
    _sum?: TipologiaProyectoSumAggregateInputType
    _min?: TipologiaProyectoMinAggregateInputType
    _max?: TipologiaProyectoMaxAggregateInputType
  }

  export type TipologiaProyectoGroupByOutputType = {
    id: number
    nombre: string
    abreviacion: string
    colorChip: string
    _count: TipologiaProyectoCountAggregateOutputType | null
    _avg: TipologiaProyectoAvgAggregateOutputType | null
    _sum: TipologiaProyectoSumAggregateOutputType | null
    _min: TipologiaProyectoMinAggregateOutputType | null
    _max: TipologiaProyectoMaxAggregateOutputType | null
  }

  type GetTipologiaProyectoGroupByPayload<T extends TipologiaProyectoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipologiaProyectoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipologiaProyectoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipologiaProyectoGroupByOutputType[P]>
            : GetScalarType<T[P], TipologiaProyectoGroupByOutputType[P]>
        }
      >
    >


  export type TipologiaProyectoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
    colorChip?: boolean
    proyectos?: boolean | TipologiaProyecto$proyectosArgs<ExtArgs>
    _count?: boolean | TipologiaProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipologiaProyecto"]>

  export type TipologiaProyectoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
    colorChip?: boolean
  }, ExtArgs["result"]["tipologiaProyecto"]>

  export type TipologiaProyectoSelectScalar = {
    id?: boolean
    nombre?: boolean
    abreviacion?: boolean
    colorChip?: boolean
  }

  export type TipologiaProyectoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | TipologiaProyecto$proyectosArgs<ExtArgs>
    _count?: boolean | TipologiaProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipologiaProyectoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipologiaProyectoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipologiaProyecto"
    objects: {
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      abreviacion: string
      colorChip: string
    }, ExtArgs["result"]["tipologiaProyecto"]>
    composites: {}
  }

  type TipologiaProyectoGetPayload<S extends boolean | null | undefined | TipologiaProyectoDefaultArgs> = $Result.GetResult<Prisma.$TipologiaProyectoPayload, S>

  type TipologiaProyectoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TipologiaProyectoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipologiaProyectoCountAggregateInputType | true
    }

  export interface TipologiaProyectoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipologiaProyecto'], meta: { name: 'TipologiaProyecto' } }
    /**
     * Find zero or one TipologiaProyecto that matches the filter.
     * @param {TipologiaProyectoFindUniqueArgs} args - Arguments to find a TipologiaProyecto
     * @example
     * // Get one TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipologiaProyectoFindUniqueArgs>(args: SelectSubset<T, TipologiaProyectoFindUniqueArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TipologiaProyecto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TipologiaProyectoFindUniqueOrThrowArgs} args - Arguments to find a TipologiaProyecto
     * @example
     * // Get one TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipologiaProyectoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipologiaProyectoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TipologiaProyecto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoFindFirstArgs} args - Arguments to find a TipologiaProyecto
     * @example
     * // Get one TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipologiaProyectoFindFirstArgs>(args?: SelectSubset<T, TipologiaProyectoFindFirstArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TipologiaProyecto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoFindFirstOrThrowArgs} args - Arguments to find a TipologiaProyecto
     * @example
     * // Get one TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipologiaProyectoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipologiaProyectoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TipologiaProyectos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipologiaProyectos
     * const tipologiaProyectos = await prisma.tipologiaProyecto.findMany()
     * 
     * // Get first 10 TipologiaProyectos
     * const tipologiaProyectos = await prisma.tipologiaProyecto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipologiaProyectoWithIdOnly = await prisma.tipologiaProyecto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipologiaProyectoFindManyArgs>(args?: SelectSubset<T, TipologiaProyectoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TipologiaProyecto.
     * @param {TipologiaProyectoCreateArgs} args - Arguments to create a TipologiaProyecto.
     * @example
     * // Create one TipologiaProyecto
     * const TipologiaProyecto = await prisma.tipologiaProyecto.create({
     *   data: {
     *     // ... data to create a TipologiaProyecto
     *   }
     * })
     * 
     */
    create<T extends TipologiaProyectoCreateArgs>(args: SelectSubset<T, TipologiaProyectoCreateArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TipologiaProyectos.
     * @param {TipologiaProyectoCreateManyArgs} args - Arguments to create many TipologiaProyectos.
     * @example
     * // Create many TipologiaProyectos
     * const tipologiaProyecto = await prisma.tipologiaProyecto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipologiaProyectoCreateManyArgs>(args?: SelectSubset<T, TipologiaProyectoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipologiaProyectos and returns the data saved in the database.
     * @param {TipologiaProyectoCreateManyAndReturnArgs} args - Arguments to create many TipologiaProyectos.
     * @example
     * // Create many TipologiaProyectos
     * const tipologiaProyecto = await prisma.tipologiaProyecto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipologiaProyectos and only return the `id`
     * const tipologiaProyectoWithIdOnly = await prisma.tipologiaProyecto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipologiaProyectoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipologiaProyectoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TipologiaProyecto.
     * @param {TipologiaProyectoDeleteArgs} args - Arguments to delete one TipologiaProyecto.
     * @example
     * // Delete one TipologiaProyecto
     * const TipologiaProyecto = await prisma.tipologiaProyecto.delete({
     *   where: {
     *     // ... filter to delete one TipologiaProyecto
     *   }
     * })
     * 
     */
    delete<T extends TipologiaProyectoDeleteArgs>(args: SelectSubset<T, TipologiaProyectoDeleteArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TipologiaProyecto.
     * @param {TipologiaProyectoUpdateArgs} args - Arguments to update one TipologiaProyecto.
     * @example
     * // Update one TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipologiaProyectoUpdateArgs>(args: SelectSubset<T, TipologiaProyectoUpdateArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TipologiaProyectos.
     * @param {TipologiaProyectoDeleteManyArgs} args - Arguments to filter TipologiaProyectos to delete.
     * @example
     * // Delete a few TipologiaProyectos
     * const { count } = await prisma.tipologiaProyecto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipologiaProyectoDeleteManyArgs>(args?: SelectSubset<T, TipologiaProyectoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipologiaProyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipologiaProyectos
     * const tipologiaProyecto = await prisma.tipologiaProyecto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipologiaProyectoUpdateManyArgs>(args: SelectSubset<T, TipologiaProyectoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipologiaProyecto.
     * @param {TipologiaProyectoUpsertArgs} args - Arguments to update or create a TipologiaProyecto.
     * @example
     * // Update or create a TipologiaProyecto
     * const tipologiaProyecto = await prisma.tipologiaProyecto.upsert({
     *   create: {
     *     // ... data to create a TipologiaProyecto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipologiaProyecto we want to update
     *   }
     * })
     */
    upsert<T extends TipologiaProyectoUpsertArgs>(args: SelectSubset<T, TipologiaProyectoUpsertArgs<ExtArgs>>): Prisma__TipologiaProyectoClient<$Result.GetResult<Prisma.$TipologiaProyectoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TipologiaProyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoCountArgs} args - Arguments to filter TipologiaProyectos to count.
     * @example
     * // Count the number of TipologiaProyectos
     * const count = await prisma.tipologiaProyecto.count({
     *   where: {
     *     // ... the filter for the TipologiaProyectos we want to count
     *   }
     * })
    **/
    count<T extends TipologiaProyectoCountArgs>(
      args?: Subset<T, TipologiaProyectoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipologiaProyectoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipologiaProyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipologiaProyectoAggregateArgs>(args: Subset<T, TipologiaProyectoAggregateArgs>): Prisma.PrismaPromise<GetTipologiaProyectoAggregateType<T>>

    /**
     * Group by TipologiaProyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipologiaProyectoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipologiaProyectoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipologiaProyectoGroupByArgs['orderBy'] }
        : { orderBy?: TipologiaProyectoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipologiaProyectoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipologiaProyectoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipologiaProyecto model
   */
  readonly fields: TipologiaProyectoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipologiaProyecto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipologiaProyectoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyectos<T extends TipologiaProyecto$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, TipologiaProyecto$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipologiaProyecto model
   */ 
  interface TipologiaProyectoFieldRefs {
    readonly id: FieldRef<"TipologiaProyecto", 'Int'>
    readonly nombre: FieldRef<"TipologiaProyecto", 'String'>
    readonly abreviacion: FieldRef<"TipologiaProyecto", 'String'>
    readonly colorChip: FieldRef<"TipologiaProyecto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipologiaProyecto findUnique
   */
  export type TipologiaProyectoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter, which TipologiaProyecto to fetch.
     */
    where: TipologiaProyectoWhereUniqueInput
  }

  /**
   * TipologiaProyecto findUniqueOrThrow
   */
  export type TipologiaProyectoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter, which TipologiaProyecto to fetch.
     */
    where: TipologiaProyectoWhereUniqueInput
  }

  /**
   * TipologiaProyecto findFirst
   */
  export type TipologiaProyectoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter, which TipologiaProyecto to fetch.
     */
    where?: TipologiaProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipologiaProyectos to fetch.
     */
    orderBy?: TipologiaProyectoOrderByWithRelationInput | TipologiaProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipologiaProyectos.
     */
    cursor?: TipologiaProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipologiaProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipologiaProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipologiaProyectos.
     */
    distinct?: TipologiaProyectoScalarFieldEnum | TipologiaProyectoScalarFieldEnum[]
  }

  /**
   * TipologiaProyecto findFirstOrThrow
   */
  export type TipologiaProyectoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter, which TipologiaProyecto to fetch.
     */
    where?: TipologiaProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipologiaProyectos to fetch.
     */
    orderBy?: TipologiaProyectoOrderByWithRelationInput | TipologiaProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipologiaProyectos.
     */
    cursor?: TipologiaProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipologiaProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipologiaProyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipologiaProyectos.
     */
    distinct?: TipologiaProyectoScalarFieldEnum | TipologiaProyectoScalarFieldEnum[]
  }

  /**
   * TipologiaProyecto findMany
   */
  export type TipologiaProyectoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter, which TipologiaProyectos to fetch.
     */
    where?: TipologiaProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipologiaProyectos to fetch.
     */
    orderBy?: TipologiaProyectoOrderByWithRelationInput | TipologiaProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipologiaProyectos.
     */
    cursor?: TipologiaProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipologiaProyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipologiaProyectos.
     */
    skip?: number
    distinct?: TipologiaProyectoScalarFieldEnum | TipologiaProyectoScalarFieldEnum[]
  }

  /**
   * TipologiaProyecto create
   */
  export type TipologiaProyectoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipologiaProyecto.
     */
    data: XOR<TipologiaProyectoCreateInput, TipologiaProyectoUncheckedCreateInput>
  }

  /**
   * TipologiaProyecto createMany
   */
  export type TipologiaProyectoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipologiaProyectos.
     */
    data: TipologiaProyectoCreateManyInput | TipologiaProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipologiaProyecto createManyAndReturn
   */
  export type TipologiaProyectoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TipologiaProyectos.
     */
    data: TipologiaProyectoCreateManyInput | TipologiaProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipologiaProyecto update
   */
  export type TipologiaProyectoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipologiaProyecto.
     */
    data: XOR<TipologiaProyectoUpdateInput, TipologiaProyectoUncheckedUpdateInput>
    /**
     * Choose, which TipologiaProyecto to update.
     */
    where: TipologiaProyectoWhereUniqueInput
  }

  /**
   * TipologiaProyecto updateMany
   */
  export type TipologiaProyectoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipologiaProyectos.
     */
    data: XOR<TipologiaProyectoUpdateManyMutationInput, TipologiaProyectoUncheckedUpdateManyInput>
    /**
     * Filter which TipologiaProyectos to update
     */
    where?: TipologiaProyectoWhereInput
  }

  /**
   * TipologiaProyecto upsert
   */
  export type TipologiaProyectoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipologiaProyecto to update in case it exists.
     */
    where: TipologiaProyectoWhereUniqueInput
    /**
     * In case the TipologiaProyecto found by the `where` argument doesn't exist, create a new TipologiaProyecto with this data.
     */
    create: XOR<TipologiaProyectoCreateInput, TipologiaProyectoUncheckedCreateInput>
    /**
     * In case the TipologiaProyecto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipologiaProyectoUpdateInput, TipologiaProyectoUncheckedUpdateInput>
  }

  /**
   * TipologiaProyecto delete
   */
  export type TipologiaProyectoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
    /**
     * Filter which TipologiaProyecto to delete.
     */
    where: TipologiaProyectoWhereUniqueInput
  }

  /**
   * TipologiaProyecto deleteMany
   */
  export type TipologiaProyectoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipologiaProyectos to delete
     */
    where?: TipologiaProyectoWhereInput
  }

  /**
   * TipologiaProyecto.proyectos
   */
  export type TipologiaProyecto$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * TipologiaProyecto without action
   */
  export type TipologiaProyectoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipologiaProyecto
     */
    select?: TipologiaProyectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipologiaProyectoInclude<ExtArgs> | null
  }


  /**
   * Model Sector
   */

  export type AggregateSector = {
    _count: SectorCountAggregateOutputType | null
    _avg: SectorAvgAggregateOutputType | null
    _sum: SectorSumAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  export type SectorAvgAggregateOutputType = {
    id: number | null
  }

  export type SectorSumAggregateOutputType = {
    id: number | null
  }

  export type SectorMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SectorMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SectorCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type SectorAvgAggregateInputType = {
    id?: true
  }

  export type SectorSumAggregateInputType = {
    id?: true
  }

  export type SectorMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SectorMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SectorCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type SectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sector to aggregate.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sectors
    **/
    _count?: true | SectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorMaxAggregateInputType
  }

  export type GetSectorAggregateType<T extends SectorAggregateArgs> = {
        [P in keyof T & keyof AggregateSector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSector[P]>
      : GetScalarType<T[P], AggregateSector[P]>
  }




  export type SectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectorWhereInput
    orderBy?: SectorOrderByWithAggregationInput | SectorOrderByWithAggregationInput[]
    by: SectorScalarFieldEnum[] | SectorScalarFieldEnum
    having?: SectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorCountAggregateInputType | true
    _avg?: SectorAvgAggregateInputType
    _sum?: SectorSumAggregateInputType
    _min?: SectorMinAggregateInputType
    _max?: SectorMaxAggregateInputType
  }

  export type SectorGroupByOutputType = {
    id: number
    nombre: string
    _count: SectorCountAggregateOutputType | null
    _avg: SectorAvgAggregateOutputType | null
    _sum: SectorSumAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  type GetSectorGroupByPayload<T extends SectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorGroupByOutputType[P]>
            : GetScalarType<T[P], SectorGroupByOutputType[P]>
        }
      >
    >


  export type SectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proyectos?: boolean | Sector$proyectosArgs<ExtArgs>
    _count?: boolean | SectorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sector"]>

  export type SectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["sector"]>

  export type SectorSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type SectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | Sector$proyectosArgs<ExtArgs>
    _count?: boolean | SectorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sector"
    objects: {
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["sector"]>
    composites: {}
  }

  type SectorGetPayload<S extends boolean | null | undefined | SectorDefaultArgs> = $Result.GetResult<Prisma.$SectorPayload, S>

  type SectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectorCountAggregateInputType | true
    }

  export interface SectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sector'], meta: { name: 'Sector' } }
    /**
     * Find zero or one Sector that matches the filter.
     * @param {SectorFindUniqueArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectorFindUniqueArgs>(args: SelectSubset<T, SectorFindUniqueArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectorFindUniqueOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectorFindUniqueOrThrowArgs>(args: SelectSubset<T, SectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectorFindFirstArgs>(args?: SelectSubset<T, SectorFindFirstArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectorFindFirstOrThrowArgs>(args?: SelectSubset<T, SectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sector.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorWithIdOnly = await prisma.sector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectorFindManyArgs>(args?: SelectSubset<T, SectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sector.
     * @param {SectorCreateArgs} args - Arguments to create a Sector.
     * @example
     * // Create one Sector
     * const Sector = await prisma.sector.create({
     *   data: {
     *     // ... data to create a Sector
     *   }
     * })
     * 
     */
    create<T extends SectorCreateArgs>(args: SelectSubset<T, SectorCreateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sectors.
     * @param {SectorCreateManyArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sector = await prisma.sector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectorCreateManyArgs>(args?: SelectSubset<T, SectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sectors and returns the data saved in the database.
     * @param {SectorCreateManyAndReturnArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sector = await prisma.sector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sectors and only return the `id`
     * const sectorWithIdOnly = await prisma.sector.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectorCreateManyAndReturnArgs>(args?: SelectSubset<T, SectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sector.
     * @param {SectorDeleteArgs} args - Arguments to delete one Sector.
     * @example
     * // Delete one Sector
     * const Sector = await prisma.sector.delete({
     *   where: {
     *     // ... filter to delete one Sector
     *   }
     * })
     * 
     */
    delete<T extends SectorDeleteArgs>(args: SelectSubset<T, SectorDeleteArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sector.
     * @param {SectorUpdateArgs} args - Arguments to update one Sector.
     * @example
     * // Update one Sector
     * const sector = await prisma.sector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectorUpdateArgs>(args: SelectSubset<T, SectorUpdateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sectors.
     * @param {SectorDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectorDeleteManyArgs>(args?: SelectSubset<T, SectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sector = await prisma.sector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectorUpdateManyArgs>(args: SelectSubset<T, SectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sector.
     * @param {SectorUpsertArgs} args - Arguments to update or create a Sector.
     * @example
     * // Update or create a Sector
     * const sector = await prisma.sector.upsert({
     *   create: {
     *     // ... data to create a Sector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sector we want to update
     *   }
     * })
     */
    upsert<T extends SectorUpsertArgs>(args: SelectSubset<T, SectorUpsertArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sector.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends SectorCountArgs>(
      args?: Subset<T, SectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorAggregateArgs>(args: Subset<T, SectorAggregateArgs>): Prisma.PrismaPromise<GetSectorAggregateType<T>>

    /**
     * Group by Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectorGroupByArgs['orderBy'] }
        : { orderBy?: SectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sector model
   */
  readonly fields: SectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyectos<T extends Sector$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, Sector$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sector model
   */ 
  interface SectorFieldRefs {
    readonly id: FieldRef<"Sector", 'Int'>
    readonly nombre: FieldRef<"Sector", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sector findUnique
   */
  export type SectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findUniqueOrThrow
   */
  export type SectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findFirst
   */
  export type SectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findFirstOrThrow
   */
  export type SectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findMany
   */
  export type SectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sectors to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector create
   */
  export type SectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sector.
     */
    data: XOR<SectorCreateInput, SectorUncheckedCreateInput>
  }

  /**
   * Sector createMany
   */
  export type SectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sectors.
     */
    data: SectorCreateManyInput | SectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sector createManyAndReturn
   */
  export type SectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sectors.
     */
    data: SectorCreateManyInput | SectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sector update
   */
  export type SectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sector.
     */
    data: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
    /**
     * Choose, which Sector to update.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector updateMany
   */
  export type SectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sectors.
     */
    data: XOR<SectorUpdateManyMutationInput, SectorUncheckedUpdateManyInput>
    /**
     * Filter which Sectors to update
     */
    where?: SectorWhereInput
  }

  /**
   * Sector upsert
   */
  export type SectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sector to update in case it exists.
     */
    where: SectorWhereUniqueInput
    /**
     * In case the Sector found by the `where` argument doesn't exist, create a new Sector with this data.
     */
    create: XOR<SectorCreateInput, SectorUncheckedCreateInput>
    /**
     * In case the Sector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
  }

  /**
   * Sector delete
   */
  export type SectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter which Sector to delete.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector deleteMany
   */
  export type SectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sectors to delete
     */
    where?: SectorWhereInput
  }

  /**
   * Sector.proyectos
   */
  export type Sector$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Sector without action
   */
  export type SectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
  }


  /**
   * Model LineaFinanciamiento
   */

  export type AggregateLineaFinanciamiento = {
    _count: LineaFinanciamientoCountAggregateOutputType | null
    _avg: LineaFinanciamientoAvgAggregateOutputType | null
    _sum: LineaFinanciamientoSumAggregateOutputType | null
    _min: LineaFinanciamientoMinAggregateOutputType | null
    _max: LineaFinanciamientoMaxAggregateOutputType | null
  }

  export type LineaFinanciamientoAvgAggregateOutputType = {
    id: number | null
  }

  export type LineaFinanciamientoSumAggregateOutputType = {
    id: number | null
  }

  export type LineaFinanciamientoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type LineaFinanciamientoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type LineaFinanciamientoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type LineaFinanciamientoAvgAggregateInputType = {
    id?: true
  }

  export type LineaFinanciamientoSumAggregateInputType = {
    id?: true
  }

  export type LineaFinanciamientoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type LineaFinanciamientoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type LineaFinanciamientoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type LineaFinanciamientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineaFinanciamiento to aggregate.
     */
    where?: LineaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineaFinanciamientos to fetch.
     */
    orderBy?: LineaFinanciamientoOrderByWithRelationInput | LineaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineaFinanciamientos
    **/
    _count?: true | LineaFinanciamientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineaFinanciamientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineaFinanciamientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineaFinanciamientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineaFinanciamientoMaxAggregateInputType
  }

  export type GetLineaFinanciamientoAggregateType<T extends LineaFinanciamientoAggregateArgs> = {
        [P in keyof T & keyof AggregateLineaFinanciamiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineaFinanciamiento[P]>
      : GetScalarType<T[P], AggregateLineaFinanciamiento[P]>
  }




  export type LineaFinanciamientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineaFinanciamientoWhereInput
    orderBy?: LineaFinanciamientoOrderByWithAggregationInput | LineaFinanciamientoOrderByWithAggregationInput[]
    by: LineaFinanciamientoScalarFieldEnum[] | LineaFinanciamientoScalarFieldEnum
    having?: LineaFinanciamientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineaFinanciamientoCountAggregateInputType | true
    _avg?: LineaFinanciamientoAvgAggregateInputType
    _sum?: LineaFinanciamientoSumAggregateInputType
    _min?: LineaFinanciamientoMinAggregateInputType
    _max?: LineaFinanciamientoMaxAggregateInputType
  }

  export type LineaFinanciamientoGroupByOutputType = {
    id: number
    nombre: string
    _count: LineaFinanciamientoCountAggregateOutputType | null
    _avg: LineaFinanciamientoAvgAggregateOutputType | null
    _sum: LineaFinanciamientoSumAggregateOutputType | null
    _min: LineaFinanciamientoMinAggregateOutputType | null
    _max: LineaFinanciamientoMaxAggregateOutputType | null
  }

  type GetLineaFinanciamientoGroupByPayload<T extends LineaFinanciamientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineaFinanciamientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineaFinanciamientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineaFinanciamientoGroupByOutputType[P]>
            : GetScalarType<T[P], LineaFinanciamientoGroupByOutputType[P]>
        }
      >
    >


  export type LineaFinanciamientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    programas?: boolean | LineaFinanciamiento$programasArgs<ExtArgs>
    proyectos?: boolean | LineaFinanciamiento$proyectosArgs<ExtArgs>
    _count?: boolean | LineaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineaFinanciamiento"]>

  export type LineaFinanciamientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["lineaFinanciamiento"]>

  export type LineaFinanciamientoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type LineaFinanciamientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programas?: boolean | LineaFinanciamiento$programasArgs<ExtArgs>
    proyectos?: boolean | LineaFinanciamiento$proyectosArgs<ExtArgs>
    _count?: boolean | LineaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LineaFinanciamientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LineaFinanciamientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LineaFinanciamiento"
    objects: {
      programas: Prisma.$ProgramaPayload<ExtArgs>[]
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["lineaFinanciamiento"]>
    composites: {}
  }

  type LineaFinanciamientoGetPayload<S extends boolean | null | undefined | LineaFinanciamientoDefaultArgs> = $Result.GetResult<Prisma.$LineaFinanciamientoPayload, S>

  type LineaFinanciamientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LineaFinanciamientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LineaFinanciamientoCountAggregateInputType | true
    }

  export interface LineaFinanciamientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LineaFinanciamiento'], meta: { name: 'LineaFinanciamiento' } }
    /**
     * Find zero or one LineaFinanciamiento that matches the filter.
     * @param {LineaFinanciamientoFindUniqueArgs} args - Arguments to find a LineaFinanciamiento
     * @example
     * // Get one LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineaFinanciamientoFindUniqueArgs>(args: SelectSubset<T, LineaFinanciamientoFindUniqueArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LineaFinanciamiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LineaFinanciamientoFindUniqueOrThrowArgs} args - Arguments to find a LineaFinanciamiento
     * @example
     * // Get one LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineaFinanciamientoFindUniqueOrThrowArgs>(args: SelectSubset<T, LineaFinanciamientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LineaFinanciamiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoFindFirstArgs} args - Arguments to find a LineaFinanciamiento
     * @example
     * // Get one LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineaFinanciamientoFindFirstArgs>(args?: SelectSubset<T, LineaFinanciamientoFindFirstArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LineaFinanciamiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoFindFirstOrThrowArgs} args - Arguments to find a LineaFinanciamiento
     * @example
     * // Get one LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineaFinanciamientoFindFirstOrThrowArgs>(args?: SelectSubset<T, LineaFinanciamientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LineaFinanciamientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineaFinanciamientos
     * const lineaFinanciamientos = await prisma.lineaFinanciamiento.findMany()
     * 
     * // Get first 10 LineaFinanciamientos
     * const lineaFinanciamientos = await prisma.lineaFinanciamiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineaFinanciamientoWithIdOnly = await prisma.lineaFinanciamiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineaFinanciamientoFindManyArgs>(args?: SelectSubset<T, LineaFinanciamientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LineaFinanciamiento.
     * @param {LineaFinanciamientoCreateArgs} args - Arguments to create a LineaFinanciamiento.
     * @example
     * // Create one LineaFinanciamiento
     * const LineaFinanciamiento = await prisma.lineaFinanciamiento.create({
     *   data: {
     *     // ... data to create a LineaFinanciamiento
     *   }
     * })
     * 
     */
    create<T extends LineaFinanciamientoCreateArgs>(args: SelectSubset<T, LineaFinanciamientoCreateArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LineaFinanciamientos.
     * @param {LineaFinanciamientoCreateManyArgs} args - Arguments to create many LineaFinanciamientos.
     * @example
     * // Create many LineaFinanciamientos
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineaFinanciamientoCreateManyArgs>(args?: SelectSubset<T, LineaFinanciamientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LineaFinanciamientos and returns the data saved in the database.
     * @param {LineaFinanciamientoCreateManyAndReturnArgs} args - Arguments to create many LineaFinanciamientos.
     * @example
     * // Create many LineaFinanciamientos
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LineaFinanciamientos and only return the `id`
     * const lineaFinanciamientoWithIdOnly = await prisma.lineaFinanciamiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineaFinanciamientoCreateManyAndReturnArgs>(args?: SelectSubset<T, LineaFinanciamientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LineaFinanciamiento.
     * @param {LineaFinanciamientoDeleteArgs} args - Arguments to delete one LineaFinanciamiento.
     * @example
     * // Delete one LineaFinanciamiento
     * const LineaFinanciamiento = await prisma.lineaFinanciamiento.delete({
     *   where: {
     *     // ... filter to delete one LineaFinanciamiento
     *   }
     * })
     * 
     */
    delete<T extends LineaFinanciamientoDeleteArgs>(args: SelectSubset<T, LineaFinanciamientoDeleteArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LineaFinanciamiento.
     * @param {LineaFinanciamientoUpdateArgs} args - Arguments to update one LineaFinanciamiento.
     * @example
     * // Update one LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineaFinanciamientoUpdateArgs>(args: SelectSubset<T, LineaFinanciamientoUpdateArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LineaFinanciamientos.
     * @param {LineaFinanciamientoDeleteManyArgs} args - Arguments to filter LineaFinanciamientos to delete.
     * @example
     * // Delete a few LineaFinanciamientos
     * const { count } = await prisma.lineaFinanciamiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineaFinanciamientoDeleteManyArgs>(args?: SelectSubset<T, LineaFinanciamientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineaFinanciamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineaFinanciamientos
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineaFinanciamientoUpdateManyArgs>(args: SelectSubset<T, LineaFinanciamientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LineaFinanciamiento.
     * @param {LineaFinanciamientoUpsertArgs} args - Arguments to update or create a LineaFinanciamiento.
     * @example
     * // Update or create a LineaFinanciamiento
     * const lineaFinanciamiento = await prisma.lineaFinanciamiento.upsert({
     *   create: {
     *     // ... data to create a LineaFinanciamiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineaFinanciamiento we want to update
     *   }
     * })
     */
    upsert<T extends LineaFinanciamientoUpsertArgs>(args: SelectSubset<T, LineaFinanciamientoUpsertArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LineaFinanciamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoCountArgs} args - Arguments to filter LineaFinanciamientos to count.
     * @example
     * // Count the number of LineaFinanciamientos
     * const count = await prisma.lineaFinanciamiento.count({
     *   where: {
     *     // ... the filter for the LineaFinanciamientos we want to count
     *   }
     * })
    **/
    count<T extends LineaFinanciamientoCountArgs>(
      args?: Subset<T, LineaFinanciamientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineaFinanciamientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineaFinanciamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineaFinanciamientoAggregateArgs>(args: Subset<T, LineaFinanciamientoAggregateArgs>): Prisma.PrismaPromise<GetLineaFinanciamientoAggregateType<T>>

    /**
     * Group by LineaFinanciamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineaFinanciamientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineaFinanciamientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineaFinanciamientoGroupByArgs['orderBy'] }
        : { orderBy?: LineaFinanciamientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineaFinanciamientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineaFinanciamientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LineaFinanciamiento model
   */
  readonly fields: LineaFinanciamientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineaFinanciamiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineaFinanciamientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programas<T extends LineaFinanciamiento$programasArgs<ExtArgs> = {}>(args?: Subset<T, LineaFinanciamiento$programasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findMany"> | Null>
    proyectos<T extends LineaFinanciamiento$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, LineaFinanciamiento$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LineaFinanciamiento model
   */ 
  interface LineaFinanciamientoFieldRefs {
    readonly id: FieldRef<"LineaFinanciamiento", 'Int'>
    readonly nombre: FieldRef<"LineaFinanciamiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LineaFinanciamiento findUnique
   */
  export type LineaFinanciamientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which LineaFinanciamiento to fetch.
     */
    where: LineaFinanciamientoWhereUniqueInput
  }

  /**
   * LineaFinanciamiento findUniqueOrThrow
   */
  export type LineaFinanciamientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which LineaFinanciamiento to fetch.
     */
    where: LineaFinanciamientoWhereUniqueInput
  }

  /**
   * LineaFinanciamiento findFirst
   */
  export type LineaFinanciamientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which LineaFinanciamiento to fetch.
     */
    where?: LineaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineaFinanciamientos to fetch.
     */
    orderBy?: LineaFinanciamientoOrderByWithRelationInput | LineaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineaFinanciamientos.
     */
    cursor?: LineaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineaFinanciamientos.
     */
    distinct?: LineaFinanciamientoScalarFieldEnum | LineaFinanciamientoScalarFieldEnum[]
  }

  /**
   * LineaFinanciamiento findFirstOrThrow
   */
  export type LineaFinanciamientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which LineaFinanciamiento to fetch.
     */
    where?: LineaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineaFinanciamientos to fetch.
     */
    orderBy?: LineaFinanciamientoOrderByWithRelationInput | LineaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineaFinanciamientos.
     */
    cursor?: LineaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineaFinanciamientos.
     */
    distinct?: LineaFinanciamientoScalarFieldEnum | LineaFinanciamientoScalarFieldEnum[]
  }

  /**
   * LineaFinanciamiento findMany
   */
  export type LineaFinanciamientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which LineaFinanciamientos to fetch.
     */
    where?: LineaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineaFinanciamientos to fetch.
     */
    orderBy?: LineaFinanciamientoOrderByWithRelationInput | LineaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineaFinanciamientos.
     */
    cursor?: LineaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineaFinanciamientos.
     */
    skip?: number
    distinct?: LineaFinanciamientoScalarFieldEnum | LineaFinanciamientoScalarFieldEnum[]
  }

  /**
   * LineaFinanciamiento create
   */
  export type LineaFinanciamientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * The data needed to create a LineaFinanciamiento.
     */
    data: XOR<LineaFinanciamientoCreateInput, LineaFinanciamientoUncheckedCreateInput>
  }

  /**
   * LineaFinanciamiento createMany
   */
  export type LineaFinanciamientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LineaFinanciamientos.
     */
    data: LineaFinanciamientoCreateManyInput | LineaFinanciamientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineaFinanciamiento createManyAndReturn
   */
  export type LineaFinanciamientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LineaFinanciamientos.
     */
    data: LineaFinanciamientoCreateManyInput | LineaFinanciamientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineaFinanciamiento update
   */
  export type LineaFinanciamientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * The data needed to update a LineaFinanciamiento.
     */
    data: XOR<LineaFinanciamientoUpdateInput, LineaFinanciamientoUncheckedUpdateInput>
    /**
     * Choose, which LineaFinanciamiento to update.
     */
    where: LineaFinanciamientoWhereUniqueInput
  }

  /**
   * LineaFinanciamiento updateMany
   */
  export type LineaFinanciamientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LineaFinanciamientos.
     */
    data: XOR<LineaFinanciamientoUpdateManyMutationInput, LineaFinanciamientoUncheckedUpdateManyInput>
    /**
     * Filter which LineaFinanciamientos to update
     */
    where?: LineaFinanciamientoWhereInput
  }

  /**
   * LineaFinanciamiento upsert
   */
  export type LineaFinanciamientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * The filter to search for the LineaFinanciamiento to update in case it exists.
     */
    where: LineaFinanciamientoWhereUniqueInput
    /**
     * In case the LineaFinanciamiento found by the `where` argument doesn't exist, create a new LineaFinanciamiento with this data.
     */
    create: XOR<LineaFinanciamientoCreateInput, LineaFinanciamientoUncheckedCreateInput>
    /**
     * In case the LineaFinanciamiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineaFinanciamientoUpdateInput, LineaFinanciamientoUncheckedUpdateInput>
  }

  /**
   * LineaFinanciamiento delete
   */
  export type LineaFinanciamientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter which LineaFinanciamiento to delete.
     */
    where: LineaFinanciamientoWhereUniqueInput
  }

  /**
   * LineaFinanciamiento deleteMany
   */
  export type LineaFinanciamientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineaFinanciamientos to delete
     */
    where?: LineaFinanciamientoWhereInput
  }

  /**
   * LineaFinanciamiento.programas
   */
  export type LineaFinanciamiento$programasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    where?: ProgramaWhereInput
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    cursor?: ProgramaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * LineaFinanciamiento.proyectos
   */
  export type LineaFinanciamiento$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * LineaFinanciamiento without action
   */
  export type LineaFinanciamientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineaFinanciamiento
     */
    select?: LineaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineaFinanciamientoInclude<ExtArgs> | null
  }


  /**
   * Model Programa
   */

  export type AggregatePrograma = {
    _count: ProgramaCountAggregateOutputType | null
    _avg: ProgramaAvgAggregateOutputType | null
    _sum: ProgramaSumAggregateOutputType | null
    _min: ProgramaMinAggregateOutputType | null
    _max: ProgramaMaxAggregateOutputType | null
  }

  export type ProgramaAvgAggregateOutputType = {
    id: number | null
    lineaFinanciamientoId: number | null
  }

  export type ProgramaSumAggregateOutputType = {
    id: number | null
    lineaFinanciamientoId: number | null
  }

  export type ProgramaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    lineaFinanciamientoId: number | null
  }

  export type ProgramaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    lineaFinanciamientoId: number | null
  }

  export type ProgramaCountAggregateOutputType = {
    id: number
    nombre: number
    lineaFinanciamientoId: number
    _all: number
  }


  export type ProgramaAvgAggregateInputType = {
    id?: true
    lineaFinanciamientoId?: true
  }

  export type ProgramaSumAggregateInputType = {
    id?: true
    lineaFinanciamientoId?: true
  }

  export type ProgramaMinAggregateInputType = {
    id?: true
    nombre?: true
    lineaFinanciamientoId?: true
  }

  export type ProgramaMaxAggregateInputType = {
    id?: true
    nombre?: true
    lineaFinanciamientoId?: true
  }

  export type ProgramaCountAggregateInputType = {
    id?: true
    nombre?: true
    lineaFinanciamientoId?: true
    _all?: true
  }

  export type ProgramaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programa to aggregate.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programas
    **/
    _count?: true | ProgramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramaMaxAggregateInputType
  }

  export type GetProgramaAggregateType<T extends ProgramaAggregateArgs> = {
        [P in keyof T & keyof AggregatePrograma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrograma[P]>
      : GetScalarType<T[P], AggregatePrograma[P]>
  }




  export type ProgramaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramaWhereInput
    orderBy?: ProgramaOrderByWithAggregationInput | ProgramaOrderByWithAggregationInput[]
    by: ProgramaScalarFieldEnum[] | ProgramaScalarFieldEnum
    having?: ProgramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramaCountAggregateInputType | true
    _avg?: ProgramaAvgAggregateInputType
    _sum?: ProgramaSumAggregateInputType
    _min?: ProgramaMinAggregateInputType
    _max?: ProgramaMaxAggregateInputType
  }

  export type ProgramaGroupByOutputType = {
    id: number
    nombre: string
    lineaFinanciamientoId: number
    _count: ProgramaCountAggregateOutputType | null
    _avg: ProgramaAvgAggregateOutputType | null
    _sum: ProgramaSumAggregateOutputType | null
    _min: ProgramaMinAggregateOutputType | null
    _max: ProgramaMaxAggregateOutputType | null
  }

  type GetProgramaGroupByPayload<T extends ProgramaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramaGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramaGroupByOutputType[P]>
        }
      >
    >


  export type ProgramaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    lineaFinanciamientoId?: boolean
    lineaFinanciamiento?: boolean | LineaFinanciamientoDefaultArgs<ExtArgs>
    proyectos?: boolean | Programa$proyectosArgs<ExtArgs>
    _count?: boolean | ProgramaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programa"]>

  export type ProgramaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    lineaFinanciamientoId?: boolean
    lineaFinanciamiento?: boolean | LineaFinanciamientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programa"]>

  export type ProgramaSelectScalar = {
    id?: boolean
    nombre?: boolean
    lineaFinanciamientoId?: boolean
  }

  export type ProgramaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineaFinanciamiento?: boolean | LineaFinanciamientoDefaultArgs<ExtArgs>
    proyectos?: boolean | Programa$proyectosArgs<ExtArgs>
    _count?: boolean | ProgramaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineaFinanciamiento?: boolean | LineaFinanciamientoDefaultArgs<ExtArgs>
  }

  export type $ProgramaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Programa"
    objects: {
      lineaFinanciamiento: Prisma.$LineaFinanciamientoPayload<ExtArgs>
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      lineaFinanciamientoId: number
    }, ExtArgs["result"]["programa"]>
    composites: {}
  }

  type ProgramaGetPayload<S extends boolean | null | undefined | ProgramaDefaultArgs> = $Result.GetResult<Prisma.$ProgramaPayload, S>

  type ProgramaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramaCountAggregateInputType | true
    }

  export interface ProgramaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Programa'], meta: { name: 'Programa' } }
    /**
     * Find zero or one Programa that matches the filter.
     * @param {ProgramaFindUniqueArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramaFindUniqueArgs>(args: SelectSubset<T, ProgramaFindUniqueArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Programa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramaFindUniqueOrThrowArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Programa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindFirstArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramaFindFirstArgs>(args?: SelectSubset<T, ProgramaFindFirstArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Programa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindFirstOrThrowArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programas
     * const programas = await prisma.programa.findMany()
     * 
     * // Get first 10 Programas
     * const programas = await prisma.programa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programaWithIdOnly = await prisma.programa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramaFindManyArgs>(args?: SelectSubset<T, ProgramaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Programa.
     * @param {ProgramaCreateArgs} args - Arguments to create a Programa.
     * @example
     * // Create one Programa
     * const Programa = await prisma.programa.create({
     *   data: {
     *     // ... data to create a Programa
     *   }
     * })
     * 
     */
    create<T extends ProgramaCreateArgs>(args: SelectSubset<T, ProgramaCreateArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programas.
     * @param {ProgramaCreateManyArgs} args - Arguments to create many Programas.
     * @example
     * // Create many Programas
     * const programa = await prisma.programa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramaCreateManyArgs>(args?: SelectSubset<T, ProgramaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programas and returns the data saved in the database.
     * @param {ProgramaCreateManyAndReturnArgs} args - Arguments to create many Programas.
     * @example
     * // Create many Programas
     * const programa = await prisma.programa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programas and only return the `id`
     * const programaWithIdOnly = await prisma.programa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Programa.
     * @param {ProgramaDeleteArgs} args - Arguments to delete one Programa.
     * @example
     * // Delete one Programa
     * const Programa = await prisma.programa.delete({
     *   where: {
     *     // ... filter to delete one Programa
     *   }
     * })
     * 
     */
    delete<T extends ProgramaDeleteArgs>(args: SelectSubset<T, ProgramaDeleteArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Programa.
     * @param {ProgramaUpdateArgs} args - Arguments to update one Programa.
     * @example
     * // Update one Programa
     * const programa = await prisma.programa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramaUpdateArgs>(args: SelectSubset<T, ProgramaUpdateArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programas.
     * @param {ProgramaDeleteManyArgs} args - Arguments to filter Programas to delete.
     * @example
     * // Delete a few Programas
     * const { count } = await prisma.programa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramaDeleteManyArgs>(args?: SelectSubset<T, ProgramaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programas
     * const programa = await prisma.programa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramaUpdateManyArgs>(args: SelectSubset<T, ProgramaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Programa.
     * @param {ProgramaUpsertArgs} args - Arguments to update or create a Programa.
     * @example
     * // Update or create a Programa
     * const programa = await prisma.programa.upsert({
     *   create: {
     *     // ... data to create a Programa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programa we want to update
     *   }
     * })
     */
    upsert<T extends ProgramaUpsertArgs>(args: SelectSubset<T, ProgramaUpsertArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaCountArgs} args - Arguments to filter Programas to count.
     * @example
     * // Count the number of Programas
     * const count = await prisma.programa.count({
     *   where: {
     *     // ... the filter for the Programas we want to count
     *   }
     * })
    **/
    count<T extends ProgramaCountArgs>(
      args?: Subset<T, ProgramaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramaAggregateArgs>(args: Subset<T, ProgramaAggregateArgs>): Prisma.PrismaPromise<GetProgramaAggregateType<T>>

    /**
     * Group by Programa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramaGroupByArgs['orderBy'] }
        : { orderBy?: ProgramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Programa model
   */
  readonly fields: ProgramaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineaFinanciamiento<T extends LineaFinanciamientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LineaFinanciamientoDefaultArgs<ExtArgs>>): Prisma__LineaFinanciamientoClient<$Result.GetResult<Prisma.$LineaFinanciamientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proyectos<T extends Programa$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, Programa$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Programa model
   */ 
  interface ProgramaFieldRefs {
    readonly id: FieldRef<"Programa", 'Int'>
    readonly nombre: FieldRef<"Programa", 'String'>
    readonly lineaFinanciamientoId: FieldRef<"Programa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Programa findUnique
   */
  export type ProgramaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa findUniqueOrThrow
   */
  export type ProgramaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa findFirst
   */
  export type ProgramaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programas.
     */
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa findFirstOrThrow
   */
  export type ProgramaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programas.
     */
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa findMany
   */
  export type ProgramaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programas to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa create
   */
  export type ProgramaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The data needed to create a Programa.
     */
    data: XOR<ProgramaCreateInput, ProgramaUncheckedCreateInput>
  }

  /**
   * Programa createMany
   */
  export type ProgramaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programas.
     */
    data: ProgramaCreateManyInput | ProgramaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programa createManyAndReturn
   */
  export type ProgramaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programas.
     */
    data: ProgramaCreateManyInput | ProgramaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Programa update
   */
  export type ProgramaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The data needed to update a Programa.
     */
    data: XOR<ProgramaUpdateInput, ProgramaUncheckedUpdateInput>
    /**
     * Choose, which Programa to update.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa updateMany
   */
  export type ProgramaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programas.
     */
    data: XOR<ProgramaUpdateManyMutationInput, ProgramaUncheckedUpdateManyInput>
    /**
     * Filter which Programas to update
     */
    where?: ProgramaWhereInput
  }

  /**
   * Programa upsert
   */
  export type ProgramaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The filter to search for the Programa to update in case it exists.
     */
    where: ProgramaWhereUniqueInput
    /**
     * In case the Programa found by the `where` argument doesn't exist, create a new Programa with this data.
     */
    create: XOR<ProgramaCreateInput, ProgramaUncheckedCreateInput>
    /**
     * In case the Programa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramaUpdateInput, ProgramaUncheckedUpdateInput>
  }

  /**
   * Programa delete
   */
  export type ProgramaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter which Programa to delete.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa deleteMany
   */
  export type ProgramaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programas to delete
     */
    where?: ProgramaWhereInput
  }

  /**
   * Programa.proyectos
   */
  export type Programa$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Programa without action
   */
  export type ProgramaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
  }


  /**
   * Model EtapaFinanciamiento
   */

  export type AggregateEtapaFinanciamiento = {
    _count: EtapaFinanciamientoCountAggregateOutputType | null
    _avg: EtapaFinanciamientoAvgAggregateOutputType | null
    _sum: EtapaFinanciamientoSumAggregateOutputType | null
    _min: EtapaFinanciamientoMinAggregateOutputType | null
    _max: EtapaFinanciamientoMaxAggregateOutputType | null
  }

  export type EtapaFinanciamientoAvgAggregateOutputType = {
    id: number | null
  }

  export type EtapaFinanciamientoSumAggregateOutputType = {
    id: number | null
  }

  export type EtapaFinanciamientoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EtapaFinanciamientoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EtapaFinanciamientoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type EtapaFinanciamientoAvgAggregateInputType = {
    id?: true
  }

  export type EtapaFinanciamientoSumAggregateInputType = {
    id?: true
  }

  export type EtapaFinanciamientoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EtapaFinanciamientoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EtapaFinanciamientoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type EtapaFinanciamientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtapaFinanciamiento to aggregate.
     */
    where?: EtapaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaFinanciamientos to fetch.
     */
    orderBy?: EtapaFinanciamientoOrderByWithRelationInput | EtapaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtapaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EtapaFinanciamientos
    **/
    _count?: true | EtapaFinanciamientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtapaFinanciamientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtapaFinanciamientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtapaFinanciamientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtapaFinanciamientoMaxAggregateInputType
  }

  export type GetEtapaFinanciamientoAggregateType<T extends EtapaFinanciamientoAggregateArgs> = {
        [P in keyof T & keyof AggregateEtapaFinanciamiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtapaFinanciamiento[P]>
      : GetScalarType<T[P], AggregateEtapaFinanciamiento[P]>
  }




  export type EtapaFinanciamientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtapaFinanciamientoWhereInput
    orderBy?: EtapaFinanciamientoOrderByWithAggregationInput | EtapaFinanciamientoOrderByWithAggregationInput[]
    by: EtapaFinanciamientoScalarFieldEnum[] | EtapaFinanciamientoScalarFieldEnum
    having?: EtapaFinanciamientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtapaFinanciamientoCountAggregateInputType | true
    _avg?: EtapaFinanciamientoAvgAggregateInputType
    _sum?: EtapaFinanciamientoSumAggregateInputType
    _min?: EtapaFinanciamientoMinAggregateInputType
    _max?: EtapaFinanciamientoMaxAggregateInputType
  }

  export type EtapaFinanciamientoGroupByOutputType = {
    id: number
    nombre: string
    _count: EtapaFinanciamientoCountAggregateOutputType | null
    _avg: EtapaFinanciamientoAvgAggregateOutputType | null
    _sum: EtapaFinanciamientoSumAggregateOutputType | null
    _min: EtapaFinanciamientoMinAggregateOutputType | null
    _max: EtapaFinanciamientoMaxAggregateOutputType | null
  }

  type GetEtapaFinanciamientoGroupByPayload<T extends EtapaFinanciamientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtapaFinanciamientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtapaFinanciamientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtapaFinanciamientoGroupByOutputType[P]>
            : GetScalarType<T[P], EtapaFinanciamientoGroupByOutputType[P]>
        }
      >
    >


  export type EtapaFinanciamientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proyectos?: boolean | EtapaFinanciamiento$proyectosArgs<ExtArgs>
    _count?: boolean | EtapaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etapaFinanciamiento"]>

  export type EtapaFinanciamientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["etapaFinanciamiento"]>

  export type EtapaFinanciamientoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type EtapaFinanciamientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyectos?: boolean | EtapaFinanciamiento$proyectosArgs<ExtArgs>
    _count?: boolean | EtapaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EtapaFinanciamientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EtapaFinanciamientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EtapaFinanciamiento"
    objects: {
      proyectos: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["etapaFinanciamiento"]>
    composites: {}
  }

  type EtapaFinanciamientoGetPayload<S extends boolean | null | undefined | EtapaFinanciamientoDefaultArgs> = $Result.GetResult<Prisma.$EtapaFinanciamientoPayload, S>

  type EtapaFinanciamientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtapaFinanciamientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtapaFinanciamientoCountAggregateInputType | true
    }

  export interface EtapaFinanciamientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EtapaFinanciamiento'], meta: { name: 'EtapaFinanciamiento' } }
    /**
     * Find zero or one EtapaFinanciamiento that matches the filter.
     * @param {EtapaFinanciamientoFindUniqueArgs} args - Arguments to find a EtapaFinanciamiento
     * @example
     * // Get one EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtapaFinanciamientoFindUniqueArgs>(args: SelectSubset<T, EtapaFinanciamientoFindUniqueArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EtapaFinanciamiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EtapaFinanciamientoFindUniqueOrThrowArgs} args - Arguments to find a EtapaFinanciamiento
     * @example
     * // Get one EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtapaFinanciamientoFindUniqueOrThrowArgs>(args: SelectSubset<T, EtapaFinanciamientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EtapaFinanciamiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoFindFirstArgs} args - Arguments to find a EtapaFinanciamiento
     * @example
     * // Get one EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtapaFinanciamientoFindFirstArgs>(args?: SelectSubset<T, EtapaFinanciamientoFindFirstArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EtapaFinanciamiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoFindFirstOrThrowArgs} args - Arguments to find a EtapaFinanciamiento
     * @example
     * // Get one EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtapaFinanciamientoFindFirstOrThrowArgs>(args?: SelectSubset<T, EtapaFinanciamientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EtapaFinanciamientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EtapaFinanciamientos
     * const etapaFinanciamientos = await prisma.etapaFinanciamiento.findMany()
     * 
     * // Get first 10 EtapaFinanciamientos
     * const etapaFinanciamientos = await prisma.etapaFinanciamiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etapaFinanciamientoWithIdOnly = await prisma.etapaFinanciamiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtapaFinanciamientoFindManyArgs>(args?: SelectSubset<T, EtapaFinanciamientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EtapaFinanciamiento.
     * @param {EtapaFinanciamientoCreateArgs} args - Arguments to create a EtapaFinanciamiento.
     * @example
     * // Create one EtapaFinanciamiento
     * const EtapaFinanciamiento = await prisma.etapaFinanciamiento.create({
     *   data: {
     *     // ... data to create a EtapaFinanciamiento
     *   }
     * })
     * 
     */
    create<T extends EtapaFinanciamientoCreateArgs>(args: SelectSubset<T, EtapaFinanciamientoCreateArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EtapaFinanciamientos.
     * @param {EtapaFinanciamientoCreateManyArgs} args - Arguments to create many EtapaFinanciamientos.
     * @example
     * // Create many EtapaFinanciamientos
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtapaFinanciamientoCreateManyArgs>(args?: SelectSubset<T, EtapaFinanciamientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EtapaFinanciamientos and returns the data saved in the database.
     * @param {EtapaFinanciamientoCreateManyAndReturnArgs} args - Arguments to create many EtapaFinanciamientos.
     * @example
     * // Create many EtapaFinanciamientos
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EtapaFinanciamientos and only return the `id`
     * const etapaFinanciamientoWithIdOnly = await prisma.etapaFinanciamiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EtapaFinanciamientoCreateManyAndReturnArgs>(args?: SelectSubset<T, EtapaFinanciamientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EtapaFinanciamiento.
     * @param {EtapaFinanciamientoDeleteArgs} args - Arguments to delete one EtapaFinanciamiento.
     * @example
     * // Delete one EtapaFinanciamiento
     * const EtapaFinanciamiento = await prisma.etapaFinanciamiento.delete({
     *   where: {
     *     // ... filter to delete one EtapaFinanciamiento
     *   }
     * })
     * 
     */
    delete<T extends EtapaFinanciamientoDeleteArgs>(args: SelectSubset<T, EtapaFinanciamientoDeleteArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EtapaFinanciamiento.
     * @param {EtapaFinanciamientoUpdateArgs} args - Arguments to update one EtapaFinanciamiento.
     * @example
     * // Update one EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtapaFinanciamientoUpdateArgs>(args: SelectSubset<T, EtapaFinanciamientoUpdateArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EtapaFinanciamientos.
     * @param {EtapaFinanciamientoDeleteManyArgs} args - Arguments to filter EtapaFinanciamientos to delete.
     * @example
     * // Delete a few EtapaFinanciamientos
     * const { count } = await prisma.etapaFinanciamiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtapaFinanciamientoDeleteManyArgs>(args?: SelectSubset<T, EtapaFinanciamientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EtapaFinanciamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EtapaFinanciamientos
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtapaFinanciamientoUpdateManyArgs>(args: SelectSubset<T, EtapaFinanciamientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EtapaFinanciamiento.
     * @param {EtapaFinanciamientoUpsertArgs} args - Arguments to update or create a EtapaFinanciamiento.
     * @example
     * // Update or create a EtapaFinanciamiento
     * const etapaFinanciamiento = await prisma.etapaFinanciamiento.upsert({
     *   create: {
     *     // ... data to create a EtapaFinanciamiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EtapaFinanciamiento we want to update
     *   }
     * })
     */
    upsert<T extends EtapaFinanciamientoUpsertArgs>(args: SelectSubset<T, EtapaFinanciamientoUpsertArgs<ExtArgs>>): Prisma__EtapaFinanciamientoClient<$Result.GetResult<Prisma.$EtapaFinanciamientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EtapaFinanciamientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoCountArgs} args - Arguments to filter EtapaFinanciamientos to count.
     * @example
     * // Count the number of EtapaFinanciamientos
     * const count = await prisma.etapaFinanciamiento.count({
     *   where: {
     *     // ... the filter for the EtapaFinanciamientos we want to count
     *   }
     * })
    **/
    count<T extends EtapaFinanciamientoCountArgs>(
      args?: Subset<T, EtapaFinanciamientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtapaFinanciamientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EtapaFinanciamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtapaFinanciamientoAggregateArgs>(args: Subset<T, EtapaFinanciamientoAggregateArgs>): Prisma.PrismaPromise<GetEtapaFinanciamientoAggregateType<T>>

    /**
     * Group by EtapaFinanciamiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaFinanciamientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtapaFinanciamientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtapaFinanciamientoGroupByArgs['orderBy'] }
        : { orderBy?: EtapaFinanciamientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtapaFinanciamientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtapaFinanciamientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EtapaFinanciamiento model
   */
  readonly fields: EtapaFinanciamientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EtapaFinanciamiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtapaFinanciamientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyectos<T extends EtapaFinanciamiento$proyectosArgs<ExtArgs> = {}>(args?: Subset<T, EtapaFinanciamiento$proyectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EtapaFinanciamiento model
   */ 
  interface EtapaFinanciamientoFieldRefs {
    readonly id: FieldRef<"EtapaFinanciamiento", 'Int'>
    readonly nombre: FieldRef<"EtapaFinanciamiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EtapaFinanciamiento findUnique
   */
  export type EtapaFinanciamientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which EtapaFinanciamiento to fetch.
     */
    where: EtapaFinanciamientoWhereUniqueInput
  }

  /**
   * EtapaFinanciamiento findUniqueOrThrow
   */
  export type EtapaFinanciamientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which EtapaFinanciamiento to fetch.
     */
    where: EtapaFinanciamientoWhereUniqueInput
  }

  /**
   * EtapaFinanciamiento findFirst
   */
  export type EtapaFinanciamientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which EtapaFinanciamiento to fetch.
     */
    where?: EtapaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaFinanciamientos to fetch.
     */
    orderBy?: EtapaFinanciamientoOrderByWithRelationInput | EtapaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtapaFinanciamientos.
     */
    cursor?: EtapaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtapaFinanciamientos.
     */
    distinct?: EtapaFinanciamientoScalarFieldEnum | EtapaFinanciamientoScalarFieldEnum[]
  }

  /**
   * EtapaFinanciamiento findFirstOrThrow
   */
  export type EtapaFinanciamientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which EtapaFinanciamiento to fetch.
     */
    where?: EtapaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaFinanciamientos to fetch.
     */
    orderBy?: EtapaFinanciamientoOrderByWithRelationInput | EtapaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtapaFinanciamientos.
     */
    cursor?: EtapaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaFinanciamientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtapaFinanciamientos.
     */
    distinct?: EtapaFinanciamientoScalarFieldEnum | EtapaFinanciamientoScalarFieldEnum[]
  }

  /**
   * EtapaFinanciamiento findMany
   */
  export type EtapaFinanciamientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter, which EtapaFinanciamientos to fetch.
     */
    where?: EtapaFinanciamientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaFinanciamientos to fetch.
     */
    orderBy?: EtapaFinanciamientoOrderByWithRelationInput | EtapaFinanciamientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EtapaFinanciamientos.
     */
    cursor?: EtapaFinanciamientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaFinanciamientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaFinanciamientos.
     */
    skip?: number
    distinct?: EtapaFinanciamientoScalarFieldEnum | EtapaFinanciamientoScalarFieldEnum[]
  }

  /**
   * EtapaFinanciamiento create
   */
  export type EtapaFinanciamientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * The data needed to create a EtapaFinanciamiento.
     */
    data: XOR<EtapaFinanciamientoCreateInput, EtapaFinanciamientoUncheckedCreateInput>
  }

  /**
   * EtapaFinanciamiento createMany
   */
  export type EtapaFinanciamientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EtapaFinanciamientos.
     */
    data: EtapaFinanciamientoCreateManyInput | EtapaFinanciamientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtapaFinanciamiento createManyAndReturn
   */
  export type EtapaFinanciamientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EtapaFinanciamientos.
     */
    data: EtapaFinanciamientoCreateManyInput | EtapaFinanciamientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtapaFinanciamiento update
   */
  export type EtapaFinanciamientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * The data needed to update a EtapaFinanciamiento.
     */
    data: XOR<EtapaFinanciamientoUpdateInput, EtapaFinanciamientoUncheckedUpdateInput>
    /**
     * Choose, which EtapaFinanciamiento to update.
     */
    where: EtapaFinanciamientoWhereUniqueInput
  }

  /**
   * EtapaFinanciamiento updateMany
   */
  export type EtapaFinanciamientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EtapaFinanciamientos.
     */
    data: XOR<EtapaFinanciamientoUpdateManyMutationInput, EtapaFinanciamientoUncheckedUpdateManyInput>
    /**
     * Filter which EtapaFinanciamientos to update
     */
    where?: EtapaFinanciamientoWhereInput
  }

  /**
   * EtapaFinanciamiento upsert
   */
  export type EtapaFinanciamientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * The filter to search for the EtapaFinanciamiento to update in case it exists.
     */
    where: EtapaFinanciamientoWhereUniqueInput
    /**
     * In case the EtapaFinanciamiento found by the `where` argument doesn't exist, create a new EtapaFinanciamiento with this data.
     */
    create: XOR<EtapaFinanciamientoCreateInput, EtapaFinanciamientoUncheckedCreateInput>
    /**
     * In case the EtapaFinanciamiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtapaFinanciamientoUpdateInput, EtapaFinanciamientoUncheckedUpdateInput>
  }

  /**
   * EtapaFinanciamiento delete
   */
  export type EtapaFinanciamientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
    /**
     * Filter which EtapaFinanciamiento to delete.
     */
    where: EtapaFinanciamientoWhereUniqueInput
  }

  /**
   * EtapaFinanciamiento deleteMany
   */
  export type EtapaFinanciamientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtapaFinanciamientos to delete
     */
    where?: EtapaFinanciamientoWhereInput
  }

  /**
   * EtapaFinanciamiento.proyectos
   */
  export type EtapaFinanciamiento$proyectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * EtapaFinanciamiento without action
   */
  export type EtapaFinanciamientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaFinanciamiento
     */
    select?: EtapaFinanciamientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaFinanciamientoInclude<ExtArgs> | null
  }


  /**
   * Model Tarea
   */

  export type AggregateTarea = {
    _count: TareaCountAggregateOutputType | null
    _avg: TareaAvgAggregateOutputType | null
    _sum: TareaSumAggregateOutputType | null
    _min: TareaMinAggregateOutputType | null
    _max: TareaMaxAggregateOutputType | null
  }

  export type TareaAvgAggregateOutputType = {
    id: number | null
    proyectoId: number | null
    creadaPorId: number | null
    asignadoAId: number | null
  }

  export type TareaSumAggregateOutputType = {
    id: number | null
    proyectoId: number | null
    creadaPorId: number | null
    asignadoAId: number | null
  }

  export type TareaMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaPlazo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proyectoId: number | null
    creadaPorId: number | null
    asignadoAId: number | null
  }

  export type TareaMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaPlazo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proyectoId: number | null
    creadaPorId: number | null
    asignadoAId: number | null
  }

  export type TareaCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    fechaPlazo: number
    createdAt: number
    updatedAt: number
    proyectoId: number
    creadaPorId: number
    asignadoAId: number
    _all: number
  }


  export type TareaAvgAggregateInputType = {
    id?: true
    proyectoId?: true
    creadaPorId?: true
    asignadoAId?: true
  }

  export type TareaSumAggregateInputType = {
    id?: true
    proyectoId?: true
    creadaPorId?: true
    asignadoAId?: true
  }

  export type TareaMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaPlazo?: true
    createdAt?: true
    updatedAt?: true
    proyectoId?: true
    creadaPorId?: true
    asignadoAId?: true
  }

  export type TareaMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaPlazo?: true
    createdAt?: true
    updatedAt?: true
    proyectoId?: true
    creadaPorId?: true
    asignadoAId?: true
  }

  export type TareaCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaPlazo?: true
    createdAt?: true
    updatedAt?: true
    proyectoId?: true
    creadaPorId?: true
    asignadoAId?: true
    _all?: true
  }

  export type TareaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarea to aggregate.
     */
    where?: TareaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tareas to fetch.
     */
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TareaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tareas
    **/
    _count?: true | TareaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TareaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TareaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TareaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TareaMaxAggregateInputType
  }

  export type GetTareaAggregateType<T extends TareaAggregateArgs> = {
        [P in keyof T & keyof AggregateTarea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarea[P]>
      : GetScalarType<T[P], AggregateTarea[P]>
  }




  export type TareaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TareaWhereInput
    orderBy?: TareaOrderByWithAggregationInput | TareaOrderByWithAggregationInput[]
    by: TareaScalarFieldEnum[] | TareaScalarFieldEnum
    having?: TareaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TareaCountAggregateInputType | true
    _avg?: TareaAvgAggregateInputType
    _sum?: TareaSumAggregateInputType
    _min?: TareaMinAggregateInputType
    _max?: TareaMaxAggregateInputType
  }

  export type TareaGroupByOutputType = {
    id: number
    titulo: string
    descripcion: string | null
    fechaPlazo: Date | null
    createdAt: Date
    updatedAt: Date
    proyectoId: number
    creadaPorId: number
    asignadoAId: number | null
    _count: TareaCountAggregateOutputType | null
    _avg: TareaAvgAggregateOutputType | null
    _sum: TareaSumAggregateOutputType | null
    _min: TareaMinAggregateOutputType | null
    _max: TareaMaxAggregateOutputType | null
  }

  type GetTareaGroupByPayload<T extends TareaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TareaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TareaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TareaGroupByOutputType[P]>
            : GetScalarType<T[P], TareaGroupByOutputType[P]>
        }
      >
    >


  export type TareaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaPlazo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proyectoId?: boolean
    creadaPorId?: boolean
    asignadoAId?: boolean
    proyecto?: boolean | ProjectDefaultArgs<ExtArgs>
    creadaPor?: boolean | UserDefaultArgs<ExtArgs>
    asignadoA?: boolean | Tarea$asignadoAArgs<ExtArgs>
    comentarios?: boolean | Tarea$comentariosArgs<ExtArgs>
    _count?: boolean | TareaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tarea"]>

  export type TareaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaPlazo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proyectoId?: boolean
    creadaPorId?: boolean
    asignadoAId?: boolean
    proyecto?: boolean | ProjectDefaultArgs<ExtArgs>
    creadaPor?: boolean | UserDefaultArgs<ExtArgs>
    asignadoA?: boolean | Tarea$asignadoAArgs<ExtArgs>
  }, ExtArgs["result"]["tarea"]>

  export type TareaSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaPlazo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proyectoId?: boolean
    creadaPorId?: boolean
    asignadoAId?: boolean
  }

  export type TareaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyecto?: boolean | ProjectDefaultArgs<ExtArgs>
    creadaPor?: boolean | UserDefaultArgs<ExtArgs>
    asignadoA?: boolean | Tarea$asignadoAArgs<ExtArgs>
    comentarios?: boolean | Tarea$comentariosArgs<ExtArgs>
    _count?: boolean | TareaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TareaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyecto?: boolean | ProjectDefaultArgs<ExtArgs>
    creadaPor?: boolean | UserDefaultArgs<ExtArgs>
    asignadoA?: boolean | Tarea$asignadoAArgs<ExtArgs>
  }

  export type $TareaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tarea"
    objects: {
      proyecto: Prisma.$ProjectPayload<ExtArgs>
      creadaPor: Prisma.$UserPayload<ExtArgs>
      asignadoA: Prisma.$UserPayload<ExtArgs> | null
      comentarios: Prisma.$ComentarioBitacoraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      descripcion: string | null
      fechaPlazo: Date | null
      createdAt: Date
      updatedAt: Date
      proyectoId: number
      creadaPorId: number
      asignadoAId: number | null
    }, ExtArgs["result"]["tarea"]>
    composites: {}
  }

  type TareaGetPayload<S extends boolean | null | undefined | TareaDefaultArgs> = $Result.GetResult<Prisma.$TareaPayload, S>

  type TareaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TareaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TareaCountAggregateInputType | true
    }

  export interface TareaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tarea'], meta: { name: 'Tarea' } }
    /**
     * Find zero or one Tarea that matches the filter.
     * @param {TareaFindUniqueArgs} args - Arguments to find a Tarea
     * @example
     * // Get one Tarea
     * const tarea = await prisma.tarea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TareaFindUniqueArgs>(args: SelectSubset<T, TareaFindUniqueArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tarea that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TareaFindUniqueOrThrowArgs} args - Arguments to find a Tarea
     * @example
     * // Get one Tarea
     * const tarea = await prisma.tarea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TareaFindUniqueOrThrowArgs>(args: SelectSubset<T, TareaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tarea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaFindFirstArgs} args - Arguments to find a Tarea
     * @example
     * // Get one Tarea
     * const tarea = await prisma.tarea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TareaFindFirstArgs>(args?: SelectSubset<T, TareaFindFirstArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tarea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaFindFirstOrThrowArgs} args - Arguments to find a Tarea
     * @example
     * // Get one Tarea
     * const tarea = await prisma.tarea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TareaFindFirstOrThrowArgs>(args?: SelectSubset<T, TareaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas
     * const tareas = await prisma.tarea.findMany()
     * 
     * // Get first 10 Tareas
     * const tareas = await prisma.tarea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tareaWithIdOnly = await prisma.tarea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TareaFindManyArgs>(args?: SelectSubset<T, TareaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tarea.
     * @param {TareaCreateArgs} args - Arguments to create a Tarea.
     * @example
     * // Create one Tarea
     * const Tarea = await prisma.tarea.create({
     *   data: {
     *     // ... data to create a Tarea
     *   }
     * })
     * 
     */
    create<T extends TareaCreateArgs>(args: SelectSubset<T, TareaCreateArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tareas.
     * @param {TareaCreateManyArgs} args - Arguments to create many Tareas.
     * @example
     * // Create many Tareas
     * const tarea = await prisma.tarea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TareaCreateManyArgs>(args?: SelectSubset<T, TareaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tareas and returns the data saved in the database.
     * @param {TareaCreateManyAndReturnArgs} args - Arguments to create many Tareas.
     * @example
     * // Create many Tareas
     * const tarea = await prisma.tarea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tareas and only return the `id`
     * const tareaWithIdOnly = await prisma.tarea.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TareaCreateManyAndReturnArgs>(args?: SelectSubset<T, TareaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tarea.
     * @param {TareaDeleteArgs} args - Arguments to delete one Tarea.
     * @example
     * // Delete one Tarea
     * const Tarea = await prisma.tarea.delete({
     *   where: {
     *     // ... filter to delete one Tarea
     *   }
     * })
     * 
     */
    delete<T extends TareaDeleteArgs>(args: SelectSubset<T, TareaDeleteArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tarea.
     * @param {TareaUpdateArgs} args - Arguments to update one Tarea.
     * @example
     * // Update one Tarea
     * const tarea = await prisma.tarea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TareaUpdateArgs>(args: SelectSubset<T, TareaUpdateArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tareas.
     * @param {TareaDeleteManyArgs} args - Arguments to filter Tareas to delete.
     * @example
     * // Delete a few Tareas
     * const { count } = await prisma.tarea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TareaDeleteManyArgs>(args?: SelectSubset<T, TareaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas
     * const tarea = await prisma.tarea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TareaUpdateManyArgs>(args: SelectSubset<T, TareaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tarea.
     * @param {TareaUpsertArgs} args - Arguments to update or create a Tarea.
     * @example
     * // Update or create a Tarea
     * const tarea = await prisma.tarea.upsert({
     *   create: {
     *     // ... data to create a Tarea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarea we want to update
     *   }
     * })
     */
    upsert<T extends TareaUpsertArgs>(args: SelectSubset<T, TareaUpsertArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaCountArgs} args - Arguments to filter Tareas to count.
     * @example
     * // Count the number of Tareas
     * const count = await prisma.tarea.count({
     *   where: {
     *     // ... the filter for the Tareas we want to count
     *   }
     * })
    **/
    count<T extends TareaCountArgs>(
      args?: Subset<T, TareaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TareaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TareaAggregateArgs>(args: Subset<T, TareaAggregateArgs>): Prisma.PrismaPromise<GetTareaAggregateType<T>>

    /**
     * Group by Tarea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TareaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TareaGroupByArgs['orderBy'] }
        : { orderBy?: TareaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TareaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tarea model
   */
  readonly fields: TareaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tarea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TareaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyecto<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creadaPor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    asignadoA<T extends Tarea$asignadoAArgs<ExtArgs> = {}>(args?: Subset<T, Tarea$asignadoAArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comentarios<T extends Tarea$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Tarea$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tarea model
   */ 
  interface TareaFieldRefs {
    readonly id: FieldRef<"Tarea", 'Int'>
    readonly titulo: FieldRef<"Tarea", 'String'>
    readonly descripcion: FieldRef<"Tarea", 'String'>
    readonly fechaPlazo: FieldRef<"Tarea", 'DateTime'>
    readonly createdAt: FieldRef<"Tarea", 'DateTime'>
    readonly updatedAt: FieldRef<"Tarea", 'DateTime'>
    readonly proyectoId: FieldRef<"Tarea", 'Int'>
    readonly creadaPorId: FieldRef<"Tarea", 'Int'>
    readonly asignadoAId: FieldRef<"Tarea", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tarea findUnique
   */
  export type TareaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter, which Tarea to fetch.
     */
    where: TareaWhereUniqueInput
  }

  /**
   * Tarea findUniqueOrThrow
   */
  export type TareaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter, which Tarea to fetch.
     */
    where: TareaWhereUniqueInput
  }

  /**
   * Tarea findFirst
   */
  export type TareaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter, which Tarea to fetch.
     */
    where?: TareaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tareas to fetch.
     */
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tareas.
     */
    cursor?: TareaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tareas.
     */
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * Tarea findFirstOrThrow
   */
  export type TareaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter, which Tarea to fetch.
     */
    where?: TareaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tareas to fetch.
     */
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tareas.
     */
    cursor?: TareaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tareas.
     */
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * Tarea findMany
   */
  export type TareaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter, which Tareas to fetch.
     */
    where?: TareaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tareas to fetch.
     */
    orderBy?: TareaOrderByWithRelationInput | TareaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tareas.
     */
    cursor?: TareaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tareas.
     */
    skip?: number
    distinct?: TareaScalarFieldEnum | TareaScalarFieldEnum[]
  }

  /**
   * Tarea create
   */
  export type TareaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * The data needed to create a Tarea.
     */
    data: XOR<TareaCreateInput, TareaUncheckedCreateInput>
  }

  /**
   * Tarea createMany
   */
  export type TareaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tareas.
     */
    data: TareaCreateManyInput | TareaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tarea createManyAndReturn
   */
  export type TareaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tareas.
     */
    data: TareaCreateManyInput | TareaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tarea update
   */
  export type TareaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * The data needed to update a Tarea.
     */
    data: XOR<TareaUpdateInput, TareaUncheckedUpdateInput>
    /**
     * Choose, which Tarea to update.
     */
    where: TareaWhereUniqueInput
  }

  /**
   * Tarea updateMany
   */
  export type TareaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tareas.
     */
    data: XOR<TareaUpdateManyMutationInput, TareaUncheckedUpdateManyInput>
    /**
     * Filter which Tareas to update
     */
    where?: TareaWhereInput
  }

  /**
   * Tarea upsert
   */
  export type TareaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * The filter to search for the Tarea to update in case it exists.
     */
    where: TareaWhereUniqueInput
    /**
     * In case the Tarea found by the `where` argument doesn't exist, create a new Tarea with this data.
     */
    create: XOR<TareaCreateInput, TareaUncheckedCreateInput>
    /**
     * In case the Tarea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TareaUpdateInput, TareaUncheckedUpdateInput>
  }

  /**
   * Tarea delete
   */
  export type TareaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
    /**
     * Filter which Tarea to delete.
     */
    where: TareaWhereUniqueInput
  }

  /**
   * Tarea deleteMany
   */
  export type TareaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tareas to delete
     */
    where?: TareaWhereInput
  }

  /**
   * Tarea.asignadoA
   */
  export type Tarea$asignadoAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Tarea.comentarios
   */
  export type Tarea$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    where?: ComentarioBitacoraWhereInput
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    cursor?: ComentarioBitacoraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioBitacoraScalarFieldEnum | ComentarioBitacoraScalarFieldEnum[]
  }

  /**
   * Tarea without action
   */
  export type TareaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarea
     */
    select?: TareaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TareaInclude<ExtArgs> | null
  }


  /**
   * Model ComentarioBitacora
   */

  export type AggregateComentarioBitacora = {
    _count: ComentarioBitacoraCountAggregateOutputType | null
    _avg: ComentarioBitacoraAvgAggregateOutputType | null
    _sum: ComentarioBitacoraSumAggregateOutputType | null
    _min: ComentarioBitacoraMinAggregateOutputType | null
    _max: ComentarioBitacoraMaxAggregateOutputType | null
  }

  export type ComentarioBitacoraAvgAggregateOutputType = {
    id: number | null
    tareaId: number | null
    creadoPorId: number | null
  }

  export type ComentarioBitacoraSumAggregateOutputType = {
    id: number | null
    tareaId: number | null
    creadoPorId: number | null
  }

  export type ComentarioBitacoraMinAggregateOutputType = {
    id: number | null
    contenido: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tareaId: number | null
    creadoPorId: number | null
  }

  export type ComentarioBitacoraMaxAggregateOutputType = {
    id: number | null
    contenido: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tareaId: number | null
    creadoPorId: number | null
  }

  export type ComentarioBitacoraCountAggregateOutputType = {
    id: number
    contenido: number
    createdAt: number
    updatedAt: number
    tareaId: number
    creadoPorId: number
    _all: number
  }


  export type ComentarioBitacoraAvgAggregateInputType = {
    id?: true
    tareaId?: true
    creadoPorId?: true
  }

  export type ComentarioBitacoraSumAggregateInputType = {
    id?: true
    tareaId?: true
    creadoPorId?: true
  }

  export type ComentarioBitacoraMinAggregateInputType = {
    id?: true
    contenido?: true
    createdAt?: true
    updatedAt?: true
    tareaId?: true
    creadoPorId?: true
  }

  export type ComentarioBitacoraMaxAggregateInputType = {
    id?: true
    contenido?: true
    createdAt?: true
    updatedAt?: true
    tareaId?: true
    creadoPorId?: true
  }

  export type ComentarioBitacoraCountAggregateInputType = {
    id?: true
    contenido?: true
    createdAt?: true
    updatedAt?: true
    tareaId?: true
    creadoPorId?: true
    _all?: true
  }

  export type ComentarioBitacoraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComentarioBitacora to aggregate.
     */
    where?: ComentarioBitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioBitacoras to fetch.
     */
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioBitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioBitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioBitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComentarioBitacoras
    **/
    _count?: true | ComentarioBitacoraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioBitacoraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioBitacoraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioBitacoraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioBitacoraMaxAggregateInputType
  }

  export type GetComentarioBitacoraAggregateType<T extends ComentarioBitacoraAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarioBitacora]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarioBitacora[P]>
      : GetScalarType<T[P], AggregateComentarioBitacora[P]>
  }




  export type ComentarioBitacoraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioBitacoraWhereInput
    orderBy?: ComentarioBitacoraOrderByWithAggregationInput | ComentarioBitacoraOrderByWithAggregationInput[]
    by: ComentarioBitacoraScalarFieldEnum[] | ComentarioBitacoraScalarFieldEnum
    having?: ComentarioBitacoraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioBitacoraCountAggregateInputType | true
    _avg?: ComentarioBitacoraAvgAggregateInputType
    _sum?: ComentarioBitacoraSumAggregateInputType
    _min?: ComentarioBitacoraMinAggregateInputType
    _max?: ComentarioBitacoraMaxAggregateInputType
  }

  export type ComentarioBitacoraGroupByOutputType = {
    id: number
    contenido: string
    createdAt: Date
    updatedAt: Date
    tareaId: number
    creadoPorId: number
    _count: ComentarioBitacoraCountAggregateOutputType | null
    _avg: ComentarioBitacoraAvgAggregateOutputType | null
    _sum: ComentarioBitacoraSumAggregateOutputType | null
    _min: ComentarioBitacoraMinAggregateOutputType | null
    _max: ComentarioBitacoraMaxAggregateOutputType | null
  }

  type GetComentarioBitacoraGroupByPayload<T extends ComentarioBitacoraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioBitacoraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioBitacoraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioBitacoraGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioBitacoraGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioBitacoraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contenido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tareaId?: boolean
    creadoPorId?: boolean
    tarea?: boolean | TareaDefaultArgs<ExtArgs>
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarioBitacora"]>

  export type ComentarioBitacoraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contenido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tareaId?: boolean
    creadoPorId?: boolean
    tarea?: boolean | TareaDefaultArgs<ExtArgs>
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarioBitacora"]>

  export type ComentarioBitacoraSelectScalar = {
    id?: boolean
    contenido?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tareaId?: boolean
    creadoPorId?: boolean
  }

  export type ComentarioBitacoraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarea?: boolean | TareaDefaultArgs<ExtArgs>
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComentarioBitacoraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarea?: boolean | TareaDefaultArgs<ExtArgs>
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComentarioBitacoraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComentarioBitacora"
    objects: {
      tarea: Prisma.$TareaPayload<ExtArgs>
      creadoPor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contenido: string
      createdAt: Date
      updatedAt: Date
      tareaId: number
      creadoPorId: number
    }, ExtArgs["result"]["comentarioBitacora"]>
    composites: {}
  }

  type ComentarioBitacoraGetPayload<S extends boolean | null | undefined | ComentarioBitacoraDefaultArgs> = $Result.GetResult<Prisma.$ComentarioBitacoraPayload, S>

  type ComentarioBitacoraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentarioBitacoraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioBitacoraCountAggregateInputType | true
    }

  export interface ComentarioBitacoraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComentarioBitacora'], meta: { name: 'ComentarioBitacora' } }
    /**
     * Find zero or one ComentarioBitacora that matches the filter.
     * @param {ComentarioBitacoraFindUniqueArgs} args - Arguments to find a ComentarioBitacora
     * @example
     * // Get one ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioBitacoraFindUniqueArgs>(args: SelectSubset<T, ComentarioBitacoraFindUniqueArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComentarioBitacora that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComentarioBitacoraFindUniqueOrThrowArgs} args - Arguments to find a ComentarioBitacora
     * @example
     * // Get one ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioBitacoraFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioBitacoraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComentarioBitacora that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraFindFirstArgs} args - Arguments to find a ComentarioBitacora
     * @example
     * // Get one ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioBitacoraFindFirstArgs>(args?: SelectSubset<T, ComentarioBitacoraFindFirstArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComentarioBitacora that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraFindFirstOrThrowArgs} args - Arguments to find a ComentarioBitacora
     * @example
     * // Get one ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioBitacoraFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioBitacoraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComentarioBitacoras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComentarioBitacoras
     * const comentarioBitacoras = await prisma.comentarioBitacora.findMany()
     * 
     * // Get first 10 ComentarioBitacoras
     * const comentarioBitacoras = await prisma.comentarioBitacora.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioBitacoraWithIdOnly = await prisma.comentarioBitacora.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComentarioBitacoraFindManyArgs>(args?: SelectSubset<T, ComentarioBitacoraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComentarioBitacora.
     * @param {ComentarioBitacoraCreateArgs} args - Arguments to create a ComentarioBitacora.
     * @example
     * // Create one ComentarioBitacora
     * const ComentarioBitacora = await prisma.comentarioBitacora.create({
     *   data: {
     *     // ... data to create a ComentarioBitacora
     *   }
     * })
     * 
     */
    create<T extends ComentarioBitacoraCreateArgs>(args: SelectSubset<T, ComentarioBitacoraCreateArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComentarioBitacoras.
     * @param {ComentarioBitacoraCreateManyArgs} args - Arguments to create many ComentarioBitacoras.
     * @example
     * // Create many ComentarioBitacoras
     * const comentarioBitacora = await prisma.comentarioBitacora.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioBitacoraCreateManyArgs>(args?: SelectSubset<T, ComentarioBitacoraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComentarioBitacoras and returns the data saved in the database.
     * @param {ComentarioBitacoraCreateManyAndReturnArgs} args - Arguments to create many ComentarioBitacoras.
     * @example
     * // Create many ComentarioBitacoras
     * const comentarioBitacora = await prisma.comentarioBitacora.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComentarioBitacoras and only return the `id`
     * const comentarioBitacoraWithIdOnly = await prisma.comentarioBitacora.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComentarioBitacoraCreateManyAndReturnArgs>(args?: SelectSubset<T, ComentarioBitacoraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComentarioBitacora.
     * @param {ComentarioBitacoraDeleteArgs} args - Arguments to delete one ComentarioBitacora.
     * @example
     * // Delete one ComentarioBitacora
     * const ComentarioBitacora = await prisma.comentarioBitacora.delete({
     *   where: {
     *     // ... filter to delete one ComentarioBitacora
     *   }
     * })
     * 
     */
    delete<T extends ComentarioBitacoraDeleteArgs>(args: SelectSubset<T, ComentarioBitacoraDeleteArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComentarioBitacora.
     * @param {ComentarioBitacoraUpdateArgs} args - Arguments to update one ComentarioBitacora.
     * @example
     * // Update one ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioBitacoraUpdateArgs>(args: SelectSubset<T, ComentarioBitacoraUpdateArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComentarioBitacoras.
     * @param {ComentarioBitacoraDeleteManyArgs} args - Arguments to filter ComentarioBitacoras to delete.
     * @example
     * // Delete a few ComentarioBitacoras
     * const { count } = await prisma.comentarioBitacora.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioBitacoraDeleteManyArgs>(args?: SelectSubset<T, ComentarioBitacoraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComentarioBitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComentarioBitacoras
     * const comentarioBitacora = await prisma.comentarioBitacora.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioBitacoraUpdateManyArgs>(args: SelectSubset<T, ComentarioBitacoraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComentarioBitacora.
     * @param {ComentarioBitacoraUpsertArgs} args - Arguments to update or create a ComentarioBitacora.
     * @example
     * // Update or create a ComentarioBitacora
     * const comentarioBitacora = await prisma.comentarioBitacora.upsert({
     *   create: {
     *     // ... data to create a ComentarioBitacora
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComentarioBitacora we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioBitacoraUpsertArgs>(args: SelectSubset<T, ComentarioBitacoraUpsertArgs<ExtArgs>>): Prisma__ComentarioBitacoraClient<$Result.GetResult<Prisma.$ComentarioBitacoraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComentarioBitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraCountArgs} args - Arguments to filter ComentarioBitacoras to count.
     * @example
     * // Count the number of ComentarioBitacoras
     * const count = await prisma.comentarioBitacora.count({
     *   where: {
     *     // ... the filter for the ComentarioBitacoras we want to count
     *   }
     * })
    **/
    count<T extends ComentarioBitacoraCountArgs>(
      args?: Subset<T, ComentarioBitacoraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioBitacoraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComentarioBitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioBitacoraAggregateArgs>(args: Subset<T, ComentarioBitacoraAggregateArgs>): Prisma.PrismaPromise<GetComentarioBitacoraAggregateType<T>>

    /**
     * Group by ComentarioBitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioBitacoraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioBitacoraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioBitacoraGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioBitacoraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioBitacoraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioBitacoraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComentarioBitacora model
   */
  readonly fields: ComentarioBitacoraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComentarioBitacora.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioBitacoraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarea<T extends TareaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TareaDefaultArgs<ExtArgs>>): Prisma__TareaClient<$Result.GetResult<Prisma.$TareaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creadoPor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComentarioBitacora model
   */ 
  interface ComentarioBitacoraFieldRefs {
    readonly id: FieldRef<"ComentarioBitacora", 'Int'>
    readonly contenido: FieldRef<"ComentarioBitacora", 'String'>
    readonly createdAt: FieldRef<"ComentarioBitacora", 'DateTime'>
    readonly updatedAt: FieldRef<"ComentarioBitacora", 'DateTime'>
    readonly tareaId: FieldRef<"ComentarioBitacora", 'Int'>
    readonly creadoPorId: FieldRef<"ComentarioBitacora", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ComentarioBitacora findUnique
   */
  export type ComentarioBitacoraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioBitacora to fetch.
     */
    where: ComentarioBitacoraWhereUniqueInput
  }

  /**
   * ComentarioBitacora findUniqueOrThrow
   */
  export type ComentarioBitacoraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioBitacora to fetch.
     */
    where: ComentarioBitacoraWhereUniqueInput
  }

  /**
   * ComentarioBitacora findFirst
   */
  export type ComentarioBitacoraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioBitacora to fetch.
     */
    where?: ComentarioBitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioBitacoras to fetch.
     */
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComentarioBitacoras.
     */
    cursor?: ComentarioBitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioBitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioBitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComentarioBitacoras.
     */
    distinct?: ComentarioBitacoraScalarFieldEnum | ComentarioBitacoraScalarFieldEnum[]
  }

  /**
   * ComentarioBitacora findFirstOrThrow
   */
  export type ComentarioBitacoraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioBitacora to fetch.
     */
    where?: ComentarioBitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioBitacoras to fetch.
     */
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComentarioBitacoras.
     */
    cursor?: ComentarioBitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioBitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioBitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComentarioBitacoras.
     */
    distinct?: ComentarioBitacoraScalarFieldEnum | ComentarioBitacoraScalarFieldEnum[]
  }

  /**
   * ComentarioBitacora findMany
   */
  export type ComentarioBitacoraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter, which ComentarioBitacoras to fetch.
     */
    where?: ComentarioBitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComentarioBitacoras to fetch.
     */
    orderBy?: ComentarioBitacoraOrderByWithRelationInput | ComentarioBitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComentarioBitacoras.
     */
    cursor?: ComentarioBitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComentarioBitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComentarioBitacoras.
     */
    skip?: number
    distinct?: ComentarioBitacoraScalarFieldEnum | ComentarioBitacoraScalarFieldEnum[]
  }

  /**
   * ComentarioBitacora create
   */
  export type ComentarioBitacoraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * The data needed to create a ComentarioBitacora.
     */
    data: XOR<ComentarioBitacoraCreateInput, ComentarioBitacoraUncheckedCreateInput>
  }

  /**
   * ComentarioBitacora createMany
   */
  export type ComentarioBitacoraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComentarioBitacoras.
     */
    data: ComentarioBitacoraCreateManyInput | ComentarioBitacoraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComentarioBitacora createManyAndReturn
   */
  export type ComentarioBitacoraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComentarioBitacoras.
     */
    data: ComentarioBitacoraCreateManyInput | ComentarioBitacoraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComentarioBitacora update
   */
  export type ComentarioBitacoraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * The data needed to update a ComentarioBitacora.
     */
    data: XOR<ComentarioBitacoraUpdateInput, ComentarioBitacoraUncheckedUpdateInput>
    /**
     * Choose, which ComentarioBitacora to update.
     */
    where: ComentarioBitacoraWhereUniqueInput
  }

  /**
   * ComentarioBitacora updateMany
   */
  export type ComentarioBitacoraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComentarioBitacoras.
     */
    data: XOR<ComentarioBitacoraUpdateManyMutationInput, ComentarioBitacoraUncheckedUpdateManyInput>
    /**
     * Filter which ComentarioBitacoras to update
     */
    where?: ComentarioBitacoraWhereInput
  }

  /**
   * ComentarioBitacora upsert
   */
  export type ComentarioBitacoraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * The filter to search for the ComentarioBitacora to update in case it exists.
     */
    where: ComentarioBitacoraWhereUniqueInput
    /**
     * In case the ComentarioBitacora found by the `where` argument doesn't exist, create a new ComentarioBitacora with this data.
     */
    create: XOR<ComentarioBitacoraCreateInput, ComentarioBitacoraUncheckedCreateInput>
    /**
     * In case the ComentarioBitacora was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioBitacoraUpdateInput, ComentarioBitacoraUncheckedUpdateInput>
  }

  /**
   * ComentarioBitacora delete
   */
  export type ComentarioBitacoraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
    /**
     * Filter which ComentarioBitacora to delete.
     */
    where: ComentarioBitacoraWhereUniqueInput
  }

  /**
   * ComentarioBitacora deleteMany
   */
  export type ComentarioBitacoraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComentarioBitacoras to delete
     */
    where?: ComentarioBitacoraWhereInput
  }

  /**
   * ComentarioBitacora without action
   */
  export type ComentarioBitacoraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioBitacora
     */
    select?: ComentarioBitacoraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioBitacoraInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EtiquetaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    color: 'color'
  };

  export type EtiquetaScalarFieldEnum = (typeof EtiquetaScalarFieldEnum)[keyof typeof EtiquetaScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    codigoUnico: 'codigoUnico',
    nombre: 'nombre',
    descripcion: 'descripcion',
    direccion: 'direccion',
    superficieTerreno: 'superficieTerreno',
    superficieEdificacion: 'superficieEdificacion',
    ano: 'ano',
    proyectoPriorizado: 'proyectoPriorizado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    estadoId: 'estadoId',
    unidadId: 'unidadId',
    tipologiaId: 'tipologiaId',
    sectorId: 'sectorId',
    proyectistaId: 'proyectistaId',
    formuladorId: 'formuladorId',
    lineaFinanciamientoId: 'lineaFinanciamientoId',
    programaId: 'programaId',
    etapaFinanciamientoId: 'etapaFinanciamientoId',
    codigoExpediente: 'codigoExpediente',
    fechaPostulacion: 'fechaPostulacion',
    monto: 'monto',
    tipoMoneda: 'tipoMoneda',
    montoAdjudicado: 'montoAdjudicado',
    codigoLicitacion: 'codigoLicitacion'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const EstadoProyectoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type EstadoProyectoScalarFieldEnum = (typeof EstadoProyectoScalarFieldEnum)[keyof typeof EstadoProyectoScalarFieldEnum]


  export const UnidadMunicipalScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    abreviacion: 'abreviacion'
  };

  export type UnidadMunicipalScalarFieldEnum = (typeof UnidadMunicipalScalarFieldEnum)[keyof typeof UnidadMunicipalScalarFieldEnum]


  export const TipologiaProyectoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    abreviacion: 'abreviacion',
    colorChip: 'colorChip'
  };

  export type TipologiaProyectoScalarFieldEnum = (typeof TipologiaProyectoScalarFieldEnum)[keyof typeof TipologiaProyectoScalarFieldEnum]


  export const SectorScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type SectorScalarFieldEnum = (typeof SectorScalarFieldEnum)[keyof typeof SectorScalarFieldEnum]


  export const LineaFinanciamientoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type LineaFinanciamientoScalarFieldEnum = (typeof LineaFinanciamientoScalarFieldEnum)[keyof typeof LineaFinanciamientoScalarFieldEnum]


  export const ProgramaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    lineaFinanciamientoId: 'lineaFinanciamientoId'
  };

  export type ProgramaScalarFieldEnum = (typeof ProgramaScalarFieldEnum)[keyof typeof ProgramaScalarFieldEnum]


  export const EtapaFinanciamientoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type EtapaFinanciamientoScalarFieldEnum = (typeof EtapaFinanciamientoScalarFieldEnum)[keyof typeof EtapaFinanciamientoScalarFieldEnum]


  export const TareaScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    fechaPlazo: 'fechaPlazo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    proyectoId: 'proyectoId',
    creadaPorId: 'creadaPorId',
    asignadoAId: 'asignadoAId'
  };

  export type TareaScalarFieldEnum = (typeof TareaScalarFieldEnum)[keyof typeof TareaScalarFieldEnum]


  export const ComentarioBitacoraScalarFieldEnum: {
    id: 'id',
    contenido: 'contenido',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tareaId: 'tareaId',
    creadoPorId: 'creadoPorId'
  };

  export type ComentarioBitacoraScalarFieldEnum = (typeof ComentarioBitacoraScalarFieldEnum)[keyof typeof ComentarioBitacoraScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TipoMoneda'
   */
  export type EnumTipoMonedaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMoneda'>
    


  /**
   * Reference to a field of type 'TipoMoneda[]'
   */
  export type ListEnumTipoMonedaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMoneda[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    etiquetas?: EtiquetaListRelationFilter
    proyectosAsignadosComoProyectista?: ProjectListRelationFilter
    proyectosAsignadosComoFormulador?: ProjectListRelationFilter
    proyectosComoColaborador?: ProjectListRelationFilter
    tareasCreadas?: TareaListRelationFilter
    tareasAsignadas?: TareaListRelationFilter
    comentariosBitacora?: ComentarioBitacoraListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    etiquetas?: EtiquetaOrderByRelationAggregateInput
    proyectosAsignadosComoProyectista?: ProjectOrderByRelationAggregateInput
    proyectosAsignadosComoFormulador?: ProjectOrderByRelationAggregateInput
    proyectosComoColaborador?: ProjectOrderByRelationAggregateInput
    tareasCreadas?: TareaOrderByRelationAggregateInput
    tareasAsignadas?: TareaOrderByRelationAggregateInput
    comentariosBitacora?: ComentarioBitacoraOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    etiquetas?: EtiquetaListRelationFilter
    proyectosAsignadosComoProyectista?: ProjectListRelationFilter
    proyectosAsignadosComoFormulador?: ProjectListRelationFilter
    proyectosComoColaborador?: ProjectListRelationFilter
    tareasCreadas?: TareaListRelationFilter
    tareasAsignadas?: TareaListRelationFilter
    comentariosBitacora?: ComentarioBitacoraListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EtiquetaWhereInput = {
    AND?: EtiquetaWhereInput | EtiquetaWhereInput[]
    OR?: EtiquetaWhereInput[]
    NOT?: EtiquetaWhereInput | EtiquetaWhereInput[]
    id?: IntFilter<"Etiqueta"> | number
    nombre?: StringFilter<"Etiqueta"> | string
    color?: StringFilter<"Etiqueta"> | string
    usuarios?: UserListRelationFilter
  }

  export type EtiquetaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    color?: SortOrder
    usuarios?: UserOrderByRelationAggregateInput
  }

  export type EtiquetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: EtiquetaWhereInput | EtiquetaWhereInput[]
    OR?: EtiquetaWhereInput[]
    NOT?: EtiquetaWhereInput | EtiquetaWhereInput[]
    color?: StringFilter<"Etiqueta"> | string
    usuarios?: UserListRelationFilter
  }, "id" | "nombre">

  export type EtiquetaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    color?: SortOrder
    _count?: EtiquetaCountOrderByAggregateInput
    _avg?: EtiquetaAvgOrderByAggregateInput
    _max?: EtiquetaMaxOrderByAggregateInput
    _min?: EtiquetaMinOrderByAggregateInput
    _sum?: EtiquetaSumOrderByAggregateInput
  }

  export type EtiquetaScalarWhereWithAggregatesInput = {
    AND?: EtiquetaScalarWhereWithAggregatesInput | EtiquetaScalarWhereWithAggregatesInput[]
    OR?: EtiquetaScalarWhereWithAggregatesInput[]
    NOT?: EtiquetaScalarWhereWithAggregatesInput | EtiquetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etiqueta"> | number
    nombre?: StringWithAggregatesFilter<"Etiqueta"> | string
    color?: StringWithAggregatesFilter<"Etiqueta"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    codigoUnico?: StringFilter<"Project"> | string
    nombre?: StringFilter<"Project"> | string
    descripcion?: StringNullableFilter<"Project"> | string | null
    direccion?: StringNullableFilter<"Project"> | string | null
    superficieTerreno?: FloatNullableFilter<"Project"> | number | null
    superficieEdificacion?: FloatNullableFilter<"Project"> | number | null
    ano?: IntNullableFilter<"Project"> | number | null
    proyectoPriorizado?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    estadoId?: IntNullableFilter<"Project"> | number | null
    unidadId?: IntNullableFilter<"Project"> | number | null
    tipologiaId?: IntNullableFilter<"Project"> | number | null
    sectorId?: IntNullableFilter<"Project"> | number | null
    proyectistaId?: IntNullableFilter<"Project"> | number | null
    formuladorId?: IntNullableFilter<"Project"> | number | null
    lineaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    programaId?: IntNullableFilter<"Project"> | number | null
    etapaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    codigoExpediente?: StringNullableFilter<"Project"> | string | null
    fechaPostulacion?: DateTimeNullableFilter<"Project"> | Date | string | null
    monto?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFilter<"Project"> | $Enums.TipoMoneda
    montoAdjudicado?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: StringNullableFilter<"Project"> | string | null
    estado?: XOR<EstadoProyectoNullableRelationFilter, EstadoProyectoWhereInput> | null
    unidad?: XOR<UnidadMunicipalNullableRelationFilter, UnidadMunicipalWhereInput> | null
    tipologia?: XOR<TipologiaProyectoNullableRelationFilter, TipologiaProyectoWhereInput> | null
    sector?: XOR<SectorNullableRelationFilter, SectorWhereInput> | null
    proyectista?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    formulador?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    colaboradores?: UserListRelationFilter
    lineaFinanciamiento?: XOR<LineaFinanciamientoNullableRelationFilter, LineaFinanciamientoWhereInput> | null
    programa?: XOR<ProgramaNullableRelationFilter, ProgramaWhereInput> | null
    etapaActualFinanciamiento?: XOR<EtapaFinanciamientoNullableRelationFilter, EtapaFinanciamientoWhereInput> | null
    tareas?: TareaListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    superficieTerreno?: SortOrderInput | SortOrder
    superficieEdificacion?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    proyectoPriorizado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estadoId?: SortOrderInput | SortOrder
    unidadId?: SortOrderInput | SortOrder
    tipologiaId?: SortOrderInput | SortOrder
    sectorId?: SortOrderInput | SortOrder
    proyectistaId?: SortOrderInput | SortOrder
    formuladorId?: SortOrderInput | SortOrder
    lineaFinanciamientoId?: SortOrderInput | SortOrder
    programaId?: SortOrderInput | SortOrder
    etapaFinanciamientoId?: SortOrderInput | SortOrder
    codigoExpediente?: SortOrderInput | SortOrder
    fechaPostulacion?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    tipoMoneda?: SortOrder
    montoAdjudicado?: SortOrderInput | SortOrder
    codigoLicitacion?: SortOrderInput | SortOrder
    estado?: EstadoProyectoOrderByWithRelationInput
    unidad?: UnidadMunicipalOrderByWithRelationInput
    tipologia?: TipologiaProyectoOrderByWithRelationInput
    sector?: SectorOrderByWithRelationInput
    proyectista?: UserOrderByWithRelationInput
    formulador?: UserOrderByWithRelationInput
    colaboradores?: UserOrderByRelationAggregateInput
    lineaFinanciamiento?: LineaFinanciamientoOrderByWithRelationInput
    programa?: ProgramaOrderByWithRelationInput
    etapaActualFinanciamiento?: EtapaFinanciamientoOrderByWithRelationInput
    tareas?: TareaOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoUnico?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    nombre?: StringFilter<"Project"> | string
    descripcion?: StringNullableFilter<"Project"> | string | null
    direccion?: StringNullableFilter<"Project"> | string | null
    superficieTerreno?: FloatNullableFilter<"Project"> | number | null
    superficieEdificacion?: FloatNullableFilter<"Project"> | number | null
    ano?: IntNullableFilter<"Project"> | number | null
    proyectoPriorizado?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    estadoId?: IntNullableFilter<"Project"> | number | null
    unidadId?: IntNullableFilter<"Project"> | number | null
    tipologiaId?: IntNullableFilter<"Project"> | number | null
    sectorId?: IntNullableFilter<"Project"> | number | null
    proyectistaId?: IntNullableFilter<"Project"> | number | null
    formuladorId?: IntNullableFilter<"Project"> | number | null
    lineaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    programaId?: IntNullableFilter<"Project"> | number | null
    etapaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    codigoExpediente?: StringNullableFilter<"Project"> | string | null
    fechaPostulacion?: DateTimeNullableFilter<"Project"> | Date | string | null
    monto?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFilter<"Project"> | $Enums.TipoMoneda
    montoAdjudicado?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: StringNullableFilter<"Project"> | string | null
    estado?: XOR<EstadoProyectoNullableRelationFilter, EstadoProyectoWhereInput> | null
    unidad?: XOR<UnidadMunicipalNullableRelationFilter, UnidadMunicipalWhereInput> | null
    tipologia?: XOR<TipologiaProyectoNullableRelationFilter, TipologiaProyectoWhereInput> | null
    sector?: XOR<SectorNullableRelationFilter, SectorWhereInput> | null
    proyectista?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    formulador?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    colaboradores?: UserListRelationFilter
    lineaFinanciamiento?: XOR<LineaFinanciamientoNullableRelationFilter, LineaFinanciamientoWhereInput> | null
    programa?: XOR<ProgramaNullableRelationFilter, ProgramaWhereInput> | null
    etapaActualFinanciamiento?: XOR<EtapaFinanciamientoNullableRelationFilter, EtapaFinanciamientoWhereInput> | null
    tareas?: TareaListRelationFilter
  }, "id" | "codigoUnico">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    superficieTerreno?: SortOrderInput | SortOrder
    superficieEdificacion?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    proyectoPriorizado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estadoId?: SortOrderInput | SortOrder
    unidadId?: SortOrderInput | SortOrder
    tipologiaId?: SortOrderInput | SortOrder
    sectorId?: SortOrderInput | SortOrder
    proyectistaId?: SortOrderInput | SortOrder
    formuladorId?: SortOrderInput | SortOrder
    lineaFinanciamientoId?: SortOrderInput | SortOrder
    programaId?: SortOrderInput | SortOrder
    etapaFinanciamientoId?: SortOrderInput | SortOrder
    codigoExpediente?: SortOrderInput | SortOrder
    fechaPostulacion?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    tipoMoneda?: SortOrder
    montoAdjudicado?: SortOrderInput | SortOrder
    codigoLicitacion?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    codigoUnico?: StringWithAggregatesFilter<"Project"> | string
    nombre?: StringWithAggregatesFilter<"Project"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Project"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Project"> | string | null
    superficieTerreno?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    superficieEdificacion?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    ano?: IntNullableWithAggregatesFilter<"Project"> | number | null
    proyectoPriorizado?: BoolWithAggregatesFilter<"Project"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    estadoId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    unidadId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    tipologiaId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    sectorId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    proyectistaId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    formuladorId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    lineaFinanciamientoId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    programaId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    etapaFinanciamientoId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    codigoExpediente?: StringNullableWithAggregatesFilter<"Project"> | string | null
    fechaPostulacion?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    monto?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaWithAggregatesFilter<"Project"> | $Enums.TipoMoneda
    montoAdjudicado?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type EstadoProyectoWhereInput = {
    AND?: EstadoProyectoWhereInput | EstadoProyectoWhereInput[]
    OR?: EstadoProyectoWhereInput[]
    NOT?: EstadoProyectoWhereInput | EstadoProyectoWhereInput[]
    id?: IntFilter<"EstadoProyecto"> | number
    nombre?: StringFilter<"EstadoProyecto"> | string
    proyectos?: ProjectListRelationFilter
  }

  export type EstadoProyectoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type EstadoProyectoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: EstadoProyectoWhereInput | EstadoProyectoWhereInput[]
    OR?: EstadoProyectoWhereInput[]
    NOT?: EstadoProyectoWhereInput | EstadoProyectoWhereInput[]
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre">

  export type EstadoProyectoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: EstadoProyectoCountOrderByAggregateInput
    _avg?: EstadoProyectoAvgOrderByAggregateInput
    _max?: EstadoProyectoMaxOrderByAggregateInput
    _min?: EstadoProyectoMinOrderByAggregateInput
    _sum?: EstadoProyectoSumOrderByAggregateInput
  }

  export type EstadoProyectoScalarWhereWithAggregatesInput = {
    AND?: EstadoProyectoScalarWhereWithAggregatesInput | EstadoProyectoScalarWhereWithAggregatesInput[]
    OR?: EstadoProyectoScalarWhereWithAggregatesInput[]
    NOT?: EstadoProyectoScalarWhereWithAggregatesInput | EstadoProyectoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EstadoProyecto"> | number
    nombre?: StringWithAggregatesFilter<"EstadoProyecto"> | string
  }

  export type UnidadMunicipalWhereInput = {
    AND?: UnidadMunicipalWhereInput | UnidadMunicipalWhereInput[]
    OR?: UnidadMunicipalWhereInput[]
    NOT?: UnidadMunicipalWhereInput | UnidadMunicipalWhereInput[]
    id?: IntFilter<"UnidadMunicipal"> | number
    nombre?: StringFilter<"UnidadMunicipal"> | string
    abreviacion?: StringFilter<"UnidadMunicipal"> | string
    proyectos?: ProjectListRelationFilter
  }

  export type UnidadMunicipalOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type UnidadMunicipalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    abreviacion?: string
    AND?: UnidadMunicipalWhereInput | UnidadMunicipalWhereInput[]
    OR?: UnidadMunicipalWhereInput[]
    NOT?: UnidadMunicipalWhereInput | UnidadMunicipalWhereInput[]
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre" | "abreviacion">

  export type UnidadMunicipalOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    _count?: UnidadMunicipalCountOrderByAggregateInput
    _avg?: UnidadMunicipalAvgOrderByAggregateInput
    _max?: UnidadMunicipalMaxOrderByAggregateInput
    _min?: UnidadMunicipalMinOrderByAggregateInput
    _sum?: UnidadMunicipalSumOrderByAggregateInput
  }

  export type UnidadMunicipalScalarWhereWithAggregatesInput = {
    AND?: UnidadMunicipalScalarWhereWithAggregatesInput | UnidadMunicipalScalarWhereWithAggregatesInput[]
    OR?: UnidadMunicipalScalarWhereWithAggregatesInput[]
    NOT?: UnidadMunicipalScalarWhereWithAggregatesInput | UnidadMunicipalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnidadMunicipal"> | number
    nombre?: StringWithAggregatesFilter<"UnidadMunicipal"> | string
    abreviacion?: StringWithAggregatesFilter<"UnidadMunicipal"> | string
  }

  export type TipologiaProyectoWhereInput = {
    AND?: TipologiaProyectoWhereInput | TipologiaProyectoWhereInput[]
    OR?: TipologiaProyectoWhereInput[]
    NOT?: TipologiaProyectoWhereInput | TipologiaProyectoWhereInput[]
    id?: IntFilter<"TipologiaProyecto"> | number
    nombre?: StringFilter<"TipologiaProyecto"> | string
    abreviacion?: StringFilter<"TipologiaProyecto"> | string
    colorChip?: StringFilter<"TipologiaProyecto"> | string
    proyectos?: ProjectListRelationFilter
  }

  export type TipologiaProyectoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    colorChip?: SortOrder
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type TipologiaProyectoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    abreviacion?: string
    AND?: TipologiaProyectoWhereInput | TipologiaProyectoWhereInput[]
    OR?: TipologiaProyectoWhereInput[]
    NOT?: TipologiaProyectoWhereInput | TipologiaProyectoWhereInput[]
    colorChip?: StringFilter<"TipologiaProyecto"> | string
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre" | "abreviacion">

  export type TipologiaProyectoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    colorChip?: SortOrder
    _count?: TipologiaProyectoCountOrderByAggregateInput
    _avg?: TipologiaProyectoAvgOrderByAggregateInput
    _max?: TipologiaProyectoMaxOrderByAggregateInput
    _min?: TipologiaProyectoMinOrderByAggregateInput
    _sum?: TipologiaProyectoSumOrderByAggregateInput
  }

  export type TipologiaProyectoScalarWhereWithAggregatesInput = {
    AND?: TipologiaProyectoScalarWhereWithAggregatesInput | TipologiaProyectoScalarWhereWithAggregatesInput[]
    OR?: TipologiaProyectoScalarWhereWithAggregatesInput[]
    NOT?: TipologiaProyectoScalarWhereWithAggregatesInput | TipologiaProyectoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipologiaProyecto"> | number
    nombre?: StringWithAggregatesFilter<"TipologiaProyecto"> | string
    abreviacion?: StringWithAggregatesFilter<"TipologiaProyecto"> | string
    colorChip?: StringWithAggregatesFilter<"TipologiaProyecto"> | string
  }

  export type SectorWhereInput = {
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    id?: IntFilter<"Sector"> | number
    nombre?: StringFilter<"Sector"> | string
    proyectos?: ProjectListRelationFilter
  }

  export type SectorOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type SectorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre">

  export type SectorOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: SectorCountOrderByAggregateInput
    _avg?: SectorAvgOrderByAggregateInput
    _max?: SectorMaxOrderByAggregateInput
    _min?: SectorMinOrderByAggregateInput
    _sum?: SectorSumOrderByAggregateInput
  }

  export type SectorScalarWhereWithAggregatesInput = {
    AND?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    OR?: SectorScalarWhereWithAggregatesInput[]
    NOT?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sector"> | number
    nombre?: StringWithAggregatesFilter<"Sector"> | string
  }

  export type LineaFinanciamientoWhereInput = {
    AND?: LineaFinanciamientoWhereInput | LineaFinanciamientoWhereInput[]
    OR?: LineaFinanciamientoWhereInput[]
    NOT?: LineaFinanciamientoWhereInput | LineaFinanciamientoWhereInput[]
    id?: IntFilter<"LineaFinanciamiento"> | number
    nombre?: StringFilter<"LineaFinanciamiento"> | string
    programas?: ProgramaListRelationFilter
    proyectos?: ProjectListRelationFilter
  }

  export type LineaFinanciamientoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    programas?: ProgramaOrderByRelationAggregateInput
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type LineaFinanciamientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: LineaFinanciamientoWhereInput | LineaFinanciamientoWhereInput[]
    OR?: LineaFinanciamientoWhereInput[]
    NOT?: LineaFinanciamientoWhereInput | LineaFinanciamientoWhereInput[]
    programas?: ProgramaListRelationFilter
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre">

  export type LineaFinanciamientoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: LineaFinanciamientoCountOrderByAggregateInput
    _avg?: LineaFinanciamientoAvgOrderByAggregateInput
    _max?: LineaFinanciamientoMaxOrderByAggregateInput
    _min?: LineaFinanciamientoMinOrderByAggregateInput
    _sum?: LineaFinanciamientoSumOrderByAggregateInput
  }

  export type LineaFinanciamientoScalarWhereWithAggregatesInput = {
    AND?: LineaFinanciamientoScalarWhereWithAggregatesInput | LineaFinanciamientoScalarWhereWithAggregatesInput[]
    OR?: LineaFinanciamientoScalarWhereWithAggregatesInput[]
    NOT?: LineaFinanciamientoScalarWhereWithAggregatesInput | LineaFinanciamientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LineaFinanciamiento"> | number
    nombre?: StringWithAggregatesFilter<"LineaFinanciamiento"> | string
  }

  export type ProgramaWhereInput = {
    AND?: ProgramaWhereInput | ProgramaWhereInput[]
    OR?: ProgramaWhereInput[]
    NOT?: ProgramaWhereInput | ProgramaWhereInput[]
    id?: IntFilter<"Programa"> | number
    nombre?: StringFilter<"Programa"> | string
    lineaFinanciamientoId?: IntFilter<"Programa"> | number
    lineaFinanciamiento?: XOR<LineaFinanciamientoRelationFilter, LineaFinanciamientoWhereInput>
    proyectos?: ProjectListRelationFilter
  }

  export type ProgramaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    lineaFinanciamientoId?: SortOrder
    lineaFinanciamiento?: LineaFinanciamientoOrderByWithRelationInput
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type ProgramaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre_lineaFinanciamientoId?: ProgramaNombreLineaFinanciamientoIdCompoundUniqueInput
    AND?: ProgramaWhereInput | ProgramaWhereInput[]
    OR?: ProgramaWhereInput[]
    NOT?: ProgramaWhereInput | ProgramaWhereInput[]
    nombre?: StringFilter<"Programa"> | string
    lineaFinanciamientoId?: IntFilter<"Programa"> | number
    lineaFinanciamiento?: XOR<LineaFinanciamientoRelationFilter, LineaFinanciamientoWhereInput>
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre_lineaFinanciamientoId">

  export type ProgramaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    lineaFinanciamientoId?: SortOrder
    _count?: ProgramaCountOrderByAggregateInput
    _avg?: ProgramaAvgOrderByAggregateInput
    _max?: ProgramaMaxOrderByAggregateInput
    _min?: ProgramaMinOrderByAggregateInput
    _sum?: ProgramaSumOrderByAggregateInput
  }

  export type ProgramaScalarWhereWithAggregatesInput = {
    AND?: ProgramaScalarWhereWithAggregatesInput | ProgramaScalarWhereWithAggregatesInput[]
    OR?: ProgramaScalarWhereWithAggregatesInput[]
    NOT?: ProgramaScalarWhereWithAggregatesInput | ProgramaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Programa"> | number
    nombre?: StringWithAggregatesFilter<"Programa"> | string
    lineaFinanciamientoId?: IntWithAggregatesFilter<"Programa"> | number
  }

  export type EtapaFinanciamientoWhereInput = {
    AND?: EtapaFinanciamientoWhereInput | EtapaFinanciamientoWhereInput[]
    OR?: EtapaFinanciamientoWhereInput[]
    NOT?: EtapaFinanciamientoWhereInput | EtapaFinanciamientoWhereInput[]
    id?: IntFilter<"EtapaFinanciamiento"> | number
    nombre?: StringFilter<"EtapaFinanciamiento"> | string
    proyectos?: ProjectListRelationFilter
  }

  export type EtapaFinanciamientoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    proyectos?: ProjectOrderByRelationAggregateInput
  }

  export type EtapaFinanciamientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: EtapaFinanciamientoWhereInput | EtapaFinanciamientoWhereInput[]
    OR?: EtapaFinanciamientoWhereInput[]
    NOT?: EtapaFinanciamientoWhereInput | EtapaFinanciamientoWhereInput[]
    proyectos?: ProjectListRelationFilter
  }, "id" | "nombre">

  export type EtapaFinanciamientoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: EtapaFinanciamientoCountOrderByAggregateInput
    _avg?: EtapaFinanciamientoAvgOrderByAggregateInput
    _max?: EtapaFinanciamientoMaxOrderByAggregateInput
    _min?: EtapaFinanciamientoMinOrderByAggregateInput
    _sum?: EtapaFinanciamientoSumOrderByAggregateInput
  }

  export type EtapaFinanciamientoScalarWhereWithAggregatesInput = {
    AND?: EtapaFinanciamientoScalarWhereWithAggregatesInput | EtapaFinanciamientoScalarWhereWithAggregatesInput[]
    OR?: EtapaFinanciamientoScalarWhereWithAggregatesInput[]
    NOT?: EtapaFinanciamientoScalarWhereWithAggregatesInput | EtapaFinanciamientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EtapaFinanciamiento"> | number
    nombre?: StringWithAggregatesFilter<"EtapaFinanciamiento"> | string
  }

  export type TareaWhereInput = {
    AND?: TareaWhereInput | TareaWhereInput[]
    OR?: TareaWhereInput[]
    NOT?: TareaWhereInput | TareaWhereInput[]
    id?: IntFilter<"Tarea"> | number
    titulo?: StringFilter<"Tarea"> | string
    descripcion?: StringNullableFilter<"Tarea"> | string | null
    fechaPlazo?: DateTimeNullableFilter<"Tarea"> | Date | string | null
    createdAt?: DateTimeFilter<"Tarea"> | Date | string
    updatedAt?: DateTimeFilter<"Tarea"> | Date | string
    proyectoId?: IntFilter<"Tarea"> | number
    creadaPorId?: IntFilter<"Tarea"> | number
    asignadoAId?: IntNullableFilter<"Tarea"> | number | null
    proyecto?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creadaPor?: XOR<UserRelationFilter, UserWhereInput>
    asignadoA?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comentarios?: ComentarioBitacoraListRelationFilter
  }

  export type TareaOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaPlazo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrderInput | SortOrder
    proyecto?: ProjectOrderByWithRelationInput
    creadaPor?: UserOrderByWithRelationInput
    asignadoA?: UserOrderByWithRelationInput
    comentarios?: ComentarioBitacoraOrderByRelationAggregateInput
  }

  export type TareaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TareaWhereInput | TareaWhereInput[]
    OR?: TareaWhereInput[]
    NOT?: TareaWhereInput | TareaWhereInput[]
    titulo?: StringFilter<"Tarea"> | string
    descripcion?: StringNullableFilter<"Tarea"> | string | null
    fechaPlazo?: DateTimeNullableFilter<"Tarea"> | Date | string | null
    createdAt?: DateTimeFilter<"Tarea"> | Date | string
    updatedAt?: DateTimeFilter<"Tarea"> | Date | string
    proyectoId?: IntFilter<"Tarea"> | number
    creadaPorId?: IntFilter<"Tarea"> | number
    asignadoAId?: IntNullableFilter<"Tarea"> | number | null
    proyecto?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creadaPor?: XOR<UserRelationFilter, UserWhereInput>
    asignadoA?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comentarios?: ComentarioBitacoraListRelationFilter
  }, "id">

  export type TareaOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaPlazo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrderInput | SortOrder
    _count?: TareaCountOrderByAggregateInput
    _avg?: TareaAvgOrderByAggregateInput
    _max?: TareaMaxOrderByAggregateInput
    _min?: TareaMinOrderByAggregateInput
    _sum?: TareaSumOrderByAggregateInput
  }

  export type TareaScalarWhereWithAggregatesInput = {
    AND?: TareaScalarWhereWithAggregatesInput | TareaScalarWhereWithAggregatesInput[]
    OR?: TareaScalarWhereWithAggregatesInput[]
    NOT?: TareaScalarWhereWithAggregatesInput | TareaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tarea"> | number
    titulo?: StringWithAggregatesFilter<"Tarea"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Tarea"> | string | null
    fechaPlazo?: DateTimeNullableWithAggregatesFilter<"Tarea"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tarea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tarea"> | Date | string
    proyectoId?: IntWithAggregatesFilter<"Tarea"> | number
    creadaPorId?: IntWithAggregatesFilter<"Tarea"> | number
    asignadoAId?: IntNullableWithAggregatesFilter<"Tarea"> | number | null
  }

  export type ComentarioBitacoraWhereInput = {
    AND?: ComentarioBitacoraWhereInput | ComentarioBitacoraWhereInput[]
    OR?: ComentarioBitacoraWhereInput[]
    NOT?: ComentarioBitacoraWhereInput | ComentarioBitacoraWhereInput[]
    id?: IntFilter<"ComentarioBitacora"> | number
    contenido?: StringFilter<"ComentarioBitacora"> | string
    createdAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    tareaId?: IntFilter<"ComentarioBitacora"> | number
    creadoPorId?: IntFilter<"ComentarioBitacora"> | number
    tarea?: XOR<TareaRelationFilter, TareaWhereInput>
    creadoPor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ComentarioBitacoraOrderByWithRelationInput = {
    id?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
    tarea?: TareaOrderByWithRelationInput
    creadoPor?: UserOrderByWithRelationInput
  }

  export type ComentarioBitacoraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComentarioBitacoraWhereInput | ComentarioBitacoraWhereInput[]
    OR?: ComentarioBitacoraWhereInput[]
    NOT?: ComentarioBitacoraWhereInput | ComentarioBitacoraWhereInput[]
    contenido?: StringFilter<"ComentarioBitacora"> | string
    createdAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    tareaId?: IntFilter<"ComentarioBitacora"> | number
    creadoPorId?: IntFilter<"ComentarioBitacora"> | number
    tarea?: XOR<TareaRelationFilter, TareaWhereInput>
    creadoPor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ComentarioBitacoraOrderByWithAggregationInput = {
    id?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
    _count?: ComentarioBitacoraCountOrderByAggregateInput
    _avg?: ComentarioBitacoraAvgOrderByAggregateInput
    _max?: ComentarioBitacoraMaxOrderByAggregateInput
    _min?: ComentarioBitacoraMinOrderByAggregateInput
    _sum?: ComentarioBitacoraSumOrderByAggregateInput
  }

  export type ComentarioBitacoraScalarWhereWithAggregatesInput = {
    AND?: ComentarioBitacoraScalarWhereWithAggregatesInput | ComentarioBitacoraScalarWhereWithAggregatesInput[]
    OR?: ComentarioBitacoraScalarWhereWithAggregatesInput[]
    NOT?: ComentarioBitacoraScalarWhereWithAggregatesInput | ComentarioBitacoraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComentarioBitacora"> | number
    contenido?: StringWithAggregatesFilter<"ComentarioBitacora"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComentarioBitacora"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComentarioBitacora"> | Date | string
    tareaId?: IntWithAggregatesFilter<"ComentarioBitacora"> | number
    creadoPorId?: IntWithAggregatesFilter<"ComentarioBitacora"> | number
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtiquetaCreateInput = {
    nombre: string
    color?: string
    usuarios?: UserCreateNestedManyWithoutEtiquetasInput
  }

  export type EtiquetaUncheckedCreateInput = {
    id?: number
    nombre: string
    color?: string
    usuarios?: UserUncheckedCreateNestedManyWithoutEtiquetasInput
  }

  export type EtiquetaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usuarios?: UserUpdateManyWithoutEtiquetasNestedInput
  }

  export type EtiquetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usuarios?: UserUncheckedUpdateManyWithoutEtiquetasNestedInput
  }

  export type EtiquetaCreateManyInput = {
    id?: number
    nombre: string
    color?: string
  }

  export type EtiquetaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUpdateInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstadoProyectoCreateInput = {
    nombre: string
    proyectos?: ProjectCreateNestedManyWithoutEstadoInput
  }

  export type EstadoProyectoUncheckedCreateInput = {
    id?: number
    nombre: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutEstadoInput
  }

  export type EstadoProyectoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutEstadoNestedInput
  }

  export type EstadoProyectoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutEstadoNestedInput
  }

  export type EstadoProyectoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type EstadoProyectoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoProyectoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadMunicipalCreateInput = {
    nombre: string
    abreviacion: string
    proyectos?: ProjectCreateNestedManyWithoutUnidadInput
  }

  export type UnidadMunicipalUncheckedCreateInput = {
    id?: number
    nombre: string
    abreviacion: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutUnidadInput
  }

  export type UnidadMunicipalUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutUnidadNestedInput
  }

  export type UnidadMunicipalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutUnidadNestedInput
  }

  export type UnidadMunicipalCreateManyInput = {
    id?: number
    nombre: string
    abreviacion: string
  }

  export type UnidadMunicipalUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadMunicipalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
  }

  export type TipologiaProyectoCreateInput = {
    nombre: string
    abreviacion: string
    colorChip?: string
    proyectos?: ProjectCreateNestedManyWithoutTipologiaInput
  }

  export type TipologiaProyectoUncheckedCreateInput = {
    id?: number
    nombre: string
    abreviacion: string
    colorChip?: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutTipologiaInput
  }

  export type TipologiaProyectoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutTipologiaNestedInput
  }

  export type TipologiaProyectoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutTipologiaNestedInput
  }

  export type TipologiaProyectoCreateManyInput = {
    id?: number
    nombre: string
    abreviacion: string
    colorChip?: string
  }

  export type TipologiaProyectoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
  }

  export type TipologiaProyectoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
  }

  export type SectorCreateInput = {
    nombre: string
    proyectos?: ProjectCreateNestedManyWithoutSectorInput
  }

  export type SectorUncheckedCreateInput = {
    id?: number
    nombre: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutSectorNestedInput
  }

  export type SectorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type SectorCreateManyInput = {
    id?: number
    nombre: string
  }

  export type SectorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SectorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type LineaFinanciamientoCreateInput = {
    nombre: string
    programas?: ProgramaCreateNestedManyWithoutLineaFinanciamientoInput
    proyectos?: ProjectCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoUncheckedCreateInput = {
    id?: number
    nombre: string
    programas?: ProgramaUncheckedCreateNestedManyWithoutLineaFinanciamientoInput
    proyectos?: ProjectUncheckedCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    programas?: ProgramaUpdateManyWithoutLineaFinanciamientoNestedInput
    proyectos?: ProjectUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type LineaFinanciamientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    programas?: ProgramaUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput
    proyectos?: ProjectUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type LineaFinanciamientoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type LineaFinanciamientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type LineaFinanciamientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaCreateInput = {
    nombre: string
    lineaFinanciamiento: LineaFinanciamientoCreateNestedOneWithoutProgramasInput
    proyectos?: ProjectCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUncheckedCreateInput = {
    id?: number
    nombre: string
    lineaFinanciamientoId: number
    proyectos?: ProjectUncheckedCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneRequiredWithoutProgramasNestedInput
    proyectos?: ProjectUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    lineaFinanciamientoId?: IntFieldUpdateOperationsInput | number
    proyectos?: ProjectUncheckedUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaCreateManyInput = {
    id?: number
    nombre: string
    lineaFinanciamientoId: number
  }

  export type ProgramaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    lineaFinanciamientoId?: IntFieldUpdateOperationsInput | number
  }

  export type EtapaFinanciamientoCreateInput = {
    nombre: string
    proyectos?: ProjectCreateNestedManyWithoutEtapaActualFinanciamientoInput
  }

  export type EtapaFinanciamientoUncheckedCreateInput = {
    id?: number
    nombre: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutEtapaActualFinanciamientoInput
  }

  export type EtapaFinanciamientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutEtapaActualFinanciamientoNestedInput
  }

  export type EtapaFinanciamientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutEtapaActualFinanciamientoNestedInput
  }

  export type EtapaFinanciamientoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type EtapaFinanciamientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EtapaFinanciamientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TareaCreateInput = {
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyecto: ProjectCreateNestedOneWithoutTareasInput
    creadaPor: UserCreateNestedOneWithoutTareasCreadasInput
    asignadoA?: UserCreateNestedOneWithoutTareasAsignadasInput
    comentarios?: ComentarioBitacoraCreateNestedManyWithoutTareaInput
  }

  export type TareaUncheckedCreateInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    creadaPorId: number
    asignadoAId?: number | null
    comentarios?: ComentarioBitacoraUncheckedCreateNestedManyWithoutTareaInput
  }

  export type TareaUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProjectUpdateOneRequiredWithoutTareasNestedInput
    creadaPor?: UserUpdateOneRequiredWithoutTareasCreadasNestedInput
    asignadoA?: UserUpdateOneWithoutTareasAsignadasNestedInput
    comentarios?: ComentarioBitacoraUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    creadaPorId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: ComentarioBitacoraUncheckedUpdateManyWithoutTareaNestedInput
  }

  export type TareaCreateManyInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    creadaPorId: number
    asignadoAId?: number | null
  }

  export type TareaUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TareaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    creadaPorId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ComentarioBitacoraCreateInput = {
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tarea: TareaCreateNestedOneWithoutComentariosInput
    creadoPor: UserCreateNestedOneWithoutComentariosBitacoraInput
  }

  export type ComentarioBitacoraUncheckedCreateInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tareaId: number
    creadoPorId: number
  }

  export type ComentarioBitacoraUpdateInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tarea?: TareaUpdateOneRequiredWithoutComentariosNestedInput
    creadoPor?: UserUpdateOneRequiredWithoutComentariosBitacoraNestedInput
  }

  export type ComentarioBitacoraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tareaId?: IntFieldUpdateOperationsInput | number
    creadoPorId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioBitacoraCreateManyInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tareaId: number
    creadoPorId: number
  }

  export type ComentarioBitacoraUpdateManyMutationInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioBitacoraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tareaId?: IntFieldUpdateOperationsInput | number
    creadoPorId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EtiquetaListRelationFilter = {
    every?: EtiquetaWhereInput
    some?: EtiquetaWhereInput
    none?: EtiquetaWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TareaListRelationFilter = {
    every?: TareaWhereInput
    some?: TareaWhereInput
    none?: TareaWhereInput
  }

  export type ComentarioBitacoraListRelationFilter = {
    every?: ComentarioBitacoraWhereInput
    some?: ComentarioBitacoraWhereInput
    none?: ComentarioBitacoraWhereInput
  }

  export type EtiquetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TareaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioBitacoraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtiquetaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    color?: SortOrder
  }

  export type EtiquetaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EtiquetaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    color?: SortOrder
  }

  export type EtiquetaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    color?: SortOrder
  }

  export type EtiquetaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumTipoMonedaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMoneda | EnumTipoMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMonedaFilter<$PrismaModel> | $Enums.TipoMoneda
  }

  export type EstadoProyectoNullableRelationFilter = {
    is?: EstadoProyectoWhereInput | null
    isNot?: EstadoProyectoWhereInput | null
  }

  export type UnidadMunicipalNullableRelationFilter = {
    is?: UnidadMunicipalWhereInput | null
    isNot?: UnidadMunicipalWhereInput | null
  }

  export type TipologiaProyectoNullableRelationFilter = {
    is?: TipologiaProyectoWhereInput | null
    isNot?: TipologiaProyectoWhereInput | null
  }

  export type SectorNullableRelationFilter = {
    is?: SectorWhereInput | null
    isNot?: SectorWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LineaFinanciamientoNullableRelationFilter = {
    is?: LineaFinanciamientoWhereInput | null
    isNot?: LineaFinanciamientoWhereInput | null
  }

  export type ProgramaNullableRelationFilter = {
    is?: ProgramaWhereInput | null
    isNot?: ProgramaWhereInput | null
  }

  export type EtapaFinanciamientoNullableRelationFilter = {
    is?: EtapaFinanciamientoWhereInput | null
    isNot?: EtapaFinanciamientoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    superficieTerreno?: SortOrder
    superficieEdificacion?: SortOrder
    ano?: SortOrder
    proyectoPriorizado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estadoId?: SortOrder
    unidadId?: SortOrder
    tipologiaId?: SortOrder
    sectorId?: SortOrder
    proyectistaId?: SortOrder
    formuladorId?: SortOrder
    lineaFinanciamientoId?: SortOrder
    programaId?: SortOrder
    etapaFinanciamientoId?: SortOrder
    codigoExpediente?: SortOrder
    fechaPostulacion?: SortOrder
    monto?: SortOrder
    tipoMoneda?: SortOrder
    montoAdjudicado?: SortOrder
    codigoLicitacion?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    superficieTerreno?: SortOrder
    superficieEdificacion?: SortOrder
    ano?: SortOrder
    estadoId?: SortOrder
    unidadId?: SortOrder
    tipologiaId?: SortOrder
    sectorId?: SortOrder
    proyectistaId?: SortOrder
    formuladorId?: SortOrder
    lineaFinanciamientoId?: SortOrder
    programaId?: SortOrder
    etapaFinanciamientoId?: SortOrder
    monto?: SortOrder
    montoAdjudicado?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    superficieTerreno?: SortOrder
    superficieEdificacion?: SortOrder
    ano?: SortOrder
    proyectoPriorizado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estadoId?: SortOrder
    unidadId?: SortOrder
    tipologiaId?: SortOrder
    sectorId?: SortOrder
    proyectistaId?: SortOrder
    formuladorId?: SortOrder
    lineaFinanciamientoId?: SortOrder
    programaId?: SortOrder
    etapaFinanciamientoId?: SortOrder
    codigoExpediente?: SortOrder
    fechaPostulacion?: SortOrder
    monto?: SortOrder
    tipoMoneda?: SortOrder
    montoAdjudicado?: SortOrder
    codigoLicitacion?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    superficieTerreno?: SortOrder
    superficieEdificacion?: SortOrder
    ano?: SortOrder
    proyectoPriorizado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estadoId?: SortOrder
    unidadId?: SortOrder
    tipologiaId?: SortOrder
    sectorId?: SortOrder
    proyectistaId?: SortOrder
    formuladorId?: SortOrder
    lineaFinanciamientoId?: SortOrder
    programaId?: SortOrder
    etapaFinanciamientoId?: SortOrder
    codigoExpediente?: SortOrder
    fechaPostulacion?: SortOrder
    monto?: SortOrder
    tipoMoneda?: SortOrder
    montoAdjudicado?: SortOrder
    codigoLicitacion?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    superficieTerreno?: SortOrder
    superficieEdificacion?: SortOrder
    ano?: SortOrder
    estadoId?: SortOrder
    unidadId?: SortOrder
    tipologiaId?: SortOrder
    sectorId?: SortOrder
    proyectistaId?: SortOrder
    formuladorId?: SortOrder
    lineaFinanciamientoId?: SortOrder
    programaId?: SortOrder
    etapaFinanciamientoId?: SortOrder
    monto?: SortOrder
    montoAdjudicado?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumTipoMonedaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMoneda | EnumTipoMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMonedaWithAggregatesFilter<$PrismaModel> | $Enums.TipoMoneda
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMonedaFilter<$PrismaModel>
    _max?: NestedEnumTipoMonedaFilter<$PrismaModel>
  }

  export type EstadoProyectoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoProyectoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoProyectoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoProyectoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoProyectoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnidadMunicipalCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
  }

  export type UnidadMunicipalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnidadMunicipalMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
  }

  export type UnidadMunicipalMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
  }

  export type UnidadMunicipalSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipologiaProyectoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    colorChip?: SortOrder
  }

  export type TipologiaProyectoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipologiaProyectoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    colorChip?: SortOrder
  }

  export type TipologiaProyectoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    abreviacion?: SortOrder
    colorChip?: SortOrder
  }

  export type TipologiaProyectoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SectorCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SectorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SectorMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SectorMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SectorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProgramaListRelationFilter = {
    every?: ProgramaWhereInput
    some?: ProgramaWhereInput
    none?: ProgramaWhereInput
  }

  export type ProgramaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineaFinanciamientoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type LineaFinanciamientoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LineaFinanciamientoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type LineaFinanciamientoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type LineaFinanciamientoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LineaFinanciamientoRelationFilter = {
    is?: LineaFinanciamientoWhereInput
    isNot?: LineaFinanciamientoWhereInput
  }

  export type ProgramaNombreLineaFinanciamientoIdCompoundUniqueInput = {
    nombre: string
    lineaFinanciamientoId: number
  }

  export type ProgramaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    lineaFinanciamientoId?: SortOrder
  }

  export type ProgramaAvgOrderByAggregateInput = {
    id?: SortOrder
    lineaFinanciamientoId?: SortOrder
  }

  export type ProgramaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    lineaFinanciamientoId?: SortOrder
  }

  export type ProgramaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    lineaFinanciamientoId?: SortOrder
  }

  export type ProgramaSumOrderByAggregateInput = {
    id?: SortOrder
    lineaFinanciamientoId?: SortOrder
  }

  export type EtapaFinanciamientoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtapaFinanciamientoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EtapaFinanciamientoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtapaFinanciamientoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtapaFinanciamientoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TareaCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaPlazo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrder
  }

  export type TareaAvgOrderByAggregateInput = {
    id?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrder
  }

  export type TareaMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaPlazo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrder
  }

  export type TareaMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaPlazo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrder
  }

  export type TareaSumOrderByAggregateInput = {
    id?: SortOrder
    proyectoId?: SortOrder
    creadaPorId?: SortOrder
    asignadoAId?: SortOrder
  }

  export type TareaRelationFilter = {
    is?: TareaWhereInput
    isNot?: TareaWhereInput
  }

  export type ComentarioBitacoraCountOrderByAggregateInput = {
    id?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ComentarioBitacoraAvgOrderByAggregateInput = {
    id?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ComentarioBitacoraMaxOrderByAggregateInput = {
    id?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ComentarioBitacoraMinOrderByAggregateInput = {
    id?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ComentarioBitacoraSumOrderByAggregateInput = {
    id?: SortOrder
    tareaId?: SortOrder
    creadoPorId?: SortOrder
  }

  export type EtiquetaCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput> | EtiquetaCreateWithoutUsuariosInput[] | EtiquetaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: EtiquetaCreateOrConnectWithoutUsuariosInput | EtiquetaCreateOrConnectWithoutUsuariosInput[]
    connect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutProyectistaInput = {
    create?: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput> | ProjectCreateWithoutProyectistaInput[] | ProjectUncheckedCreateWithoutProyectistaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProyectistaInput | ProjectCreateOrConnectWithoutProyectistaInput[]
    createMany?: ProjectCreateManyProyectistaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutFormuladorInput = {
    create?: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput> | ProjectCreateWithoutFormuladorInput[] | ProjectUncheckedCreateWithoutFormuladorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFormuladorInput | ProjectCreateOrConnectWithoutFormuladorInput[]
    createMany?: ProjectCreateManyFormuladorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutColaboradoresInput = {
    create?: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput> | ProjectCreateWithoutColaboradoresInput[] | ProjectUncheckedCreateWithoutColaboradoresInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutColaboradoresInput | ProjectCreateOrConnectWithoutColaboradoresInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TareaCreateNestedManyWithoutCreadaPorInput = {
    create?: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput> | TareaCreateWithoutCreadaPorInput[] | TareaUncheckedCreateWithoutCreadaPorInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutCreadaPorInput | TareaCreateOrConnectWithoutCreadaPorInput[]
    createMany?: TareaCreateManyCreadaPorInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type TareaCreateNestedManyWithoutAsignadoAInput = {
    create?: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput> | TareaCreateWithoutAsignadoAInput[] | TareaUncheckedCreateWithoutAsignadoAInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutAsignadoAInput | TareaCreateOrConnectWithoutAsignadoAInput[]
    createMany?: TareaCreateManyAsignadoAInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput> | ComentarioBitacoraCreateWithoutCreadoPorInput[] | ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput | ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput[]
    createMany?: ComentarioBitacoraCreateManyCreadoPorInputEnvelope
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
  }

  export type EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput> | EtiquetaCreateWithoutUsuariosInput[] | EtiquetaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: EtiquetaCreateOrConnectWithoutUsuariosInput | EtiquetaCreateOrConnectWithoutUsuariosInput[]
    connect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProyectistaInput = {
    create?: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput> | ProjectCreateWithoutProyectistaInput[] | ProjectUncheckedCreateWithoutProyectistaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProyectistaInput | ProjectCreateOrConnectWithoutProyectistaInput[]
    createMany?: ProjectCreateManyProyectistaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutFormuladorInput = {
    create?: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput> | ProjectCreateWithoutFormuladorInput[] | ProjectUncheckedCreateWithoutFormuladorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFormuladorInput | ProjectCreateOrConnectWithoutFormuladorInput[]
    createMany?: ProjectCreateManyFormuladorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutColaboradoresInput = {
    create?: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput> | ProjectCreateWithoutColaboradoresInput[] | ProjectUncheckedCreateWithoutColaboradoresInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutColaboradoresInput | ProjectCreateOrConnectWithoutColaboradoresInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TareaUncheckedCreateNestedManyWithoutCreadaPorInput = {
    create?: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput> | TareaCreateWithoutCreadaPorInput[] | TareaUncheckedCreateWithoutCreadaPorInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutCreadaPorInput | TareaCreateOrConnectWithoutCreadaPorInput[]
    createMany?: TareaCreateManyCreadaPorInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type TareaUncheckedCreateNestedManyWithoutAsignadoAInput = {
    create?: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput> | TareaCreateWithoutAsignadoAInput[] | TareaUncheckedCreateWithoutAsignadoAInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutAsignadoAInput | TareaCreateOrConnectWithoutAsignadoAInput[]
    createMany?: TareaCreateManyAsignadoAInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput> | ComentarioBitacoraCreateWithoutCreadoPorInput[] | ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput | ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput[]
    createMany?: ComentarioBitacoraCreateManyCreadoPorInputEnvelope
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EtiquetaUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput> | EtiquetaCreateWithoutUsuariosInput[] | EtiquetaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: EtiquetaCreateOrConnectWithoutUsuariosInput | EtiquetaCreateOrConnectWithoutUsuariosInput[]
    upsert?: EtiquetaUpsertWithWhereUniqueWithoutUsuariosInput | EtiquetaUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    disconnect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    delete?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    connect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    update?: EtiquetaUpdateWithWhereUniqueWithoutUsuariosInput | EtiquetaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: EtiquetaUpdateManyWithWhereWithoutUsuariosInput | EtiquetaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: EtiquetaScalarWhereInput | EtiquetaScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutProyectistaNestedInput = {
    create?: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput> | ProjectCreateWithoutProyectistaInput[] | ProjectUncheckedCreateWithoutProyectistaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProyectistaInput | ProjectCreateOrConnectWithoutProyectistaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProyectistaInput | ProjectUpsertWithWhereUniqueWithoutProyectistaInput[]
    createMany?: ProjectCreateManyProyectistaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProyectistaInput | ProjectUpdateWithWhereUniqueWithoutProyectistaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProyectistaInput | ProjectUpdateManyWithWhereWithoutProyectistaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutFormuladorNestedInput = {
    create?: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput> | ProjectCreateWithoutFormuladorInput[] | ProjectUncheckedCreateWithoutFormuladorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFormuladorInput | ProjectCreateOrConnectWithoutFormuladorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFormuladorInput | ProjectUpsertWithWhereUniqueWithoutFormuladorInput[]
    createMany?: ProjectCreateManyFormuladorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFormuladorInput | ProjectUpdateWithWhereUniqueWithoutFormuladorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFormuladorInput | ProjectUpdateManyWithWhereWithoutFormuladorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutColaboradoresNestedInput = {
    create?: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput> | ProjectCreateWithoutColaboradoresInput[] | ProjectUncheckedCreateWithoutColaboradoresInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutColaboradoresInput | ProjectCreateOrConnectWithoutColaboradoresInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutColaboradoresInput | ProjectUpsertWithWhereUniqueWithoutColaboradoresInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutColaboradoresInput | ProjectUpdateWithWhereUniqueWithoutColaboradoresInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutColaboradoresInput | ProjectUpdateManyWithWhereWithoutColaboradoresInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TareaUpdateManyWithoutCreadaPorNestedInput = {
    create?: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput> | TareaCreateWithoutCreadaPorInput[] | TareaUncheckedCreateWithoutCreadaPorInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutCreadaPorInput | TareaCreateOrConnectWithoutCreadaPorInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutCreadaPorInput | TareaUpsertWithWhereUniqueWithoutCreadaPorInput[]
    createMany?: TareaCreateManyCreadaPorInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutCreadaPorInput | TareaUpdateWithWhereUniqueWithoutCreadaPorInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutCreadaPorInput | TareaUpdateManyWithWhereWithoutCreadaPorInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type TareaUpdateManyWithoutAsignadoANestedInput = {
    create?: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput> | TareaCreateWithoutAsignadoAInput[] | TareaUncheckedCreateWithoutAsignadoAInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutAsignadoAInput | TareaCreateOrConnectWithoutAsignadoAInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutAsignadoAInput | TareaUpsertWithWhereUniqueWithoutAsignadoAInput[]
    createMany?: TareaCreateManyAsignadoAInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutAsignadoAInput | TareaUpdateWithWhereUniqueWithoutAsignadoAInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutAsignadoAInput | TareaUpdateManyWithWhereWithoutAsignadoAInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput> | ComentarioBitacoraCreateWithoutCreadoPorInput[] | ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput | ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput[]
    upsert?: ComentarioBitacoraUpsertWithWhereUniqueWithoutCreadoPorInput | ComentarioBitacoraUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: ComentarioBitacoraCreateManyCreadoPorInputEnvelope
    set?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    disconnect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    delete?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    update?: ComentarioBitacoraUpdateWithWhereUniqueWithoutCreadoPorInput | ComentarioBitacoraUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: ComentarioBitacoraUpdateManyWithWhereWithoutCreadoPorInput | ComentarioBitacoraUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput> | EtiquetaCreateWithoutUsuariosInput[] | EtiquetaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: EtiquetaCreateOrConnectWithoutUsuariosInput | EtiquetaCreateOrConnectWithoutUsuariosInput[]
    upsert?: EtiquetaUpsertWithWhereUniqueWithoutUsuariosInput | EtiquetaUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    disconnect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    delete?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    connect?: EtiquetaWhereUniqueInput | EtiquetaWhereUniqueInput[]
    update?: EtiquetaUpdateWithWhereUniqueWithoutUsuariosInput | EtiquetaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: EtiquetaUpdateManyWithWhereWithoutUsuariosInput | EtiquetaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: EtiquetaScalarWhereInput | EtiquetaScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProyectistaNestedInput = {
    create?: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput> | ProjectCreateWithoutProyectistaInput[] | ProjectUncheckedCreateWithoutProyectistaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProyectistaInput | ProjectCreateOrConnectWithoutProyectistaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProyectistaInput | ProjectUpsertWithWhereUniqueWithoutProyectistaInput[]
    createMany?: ProjectCreateManyProyectistaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProyectistaInput | ProjectUpdateWithWhereUniqueWithoutProyectistaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProyectistaInput | ProjectUpdateManyWithWhereWithoutProyectistaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutFormuladorNestedInput = {
    create?: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput> | ProjectCreateWithoutFormuladorInput[] | ProjectUncheckedCreateWithoutFormuladorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFormuladorInput | ProjectCreateOrConnectWithoutFormuladorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFormuladorInput | ProjectUpsertWithWhereUniqueWithoutFormuladorInput[]
    createMany?: ProjectCreateManyFormuladorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFormuladorInput | ProjectUpdateWithWhereUniqueWithoutFormuladorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFormuladorInput | ProjectUpdateManyWithWhereWithoutFormuladorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput = {
    create?: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput> | ProjectCreateWithoutColaboradoresInput[] | ProjectUncheckedCreateWithoutColaboradoresInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutColaboradoresInput | ProjectCreateOrConnectWithoutColaboradoresInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutColaboradoresInput | ProjectUpsertWithWhereUniqueWithoutColaboradoresInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutColaboradoresInput | ProjectUpdateWithWhereUniqueWithoutColaboradoresInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutColaboradoresInput | ProjectUpdateManyWithWhereWithoutColaboradoresInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TareaUncheckedUpdateManyWithoutCreadaPorNestedInput = {
    create?: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput> | TareaCreateWithoutCreadaPorInput[] | TareaUncheckedCreateWithoutCreadaPorInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutCreadaPorInput | TareaCreateOrConnectWithoutCreadaPorInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutCreadaPorInput | TareaUpsertWithWhereUniqueWithoutCreadaPorInput[]
    createMany?: TareaCreateManyCreadaPorInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutCreadaPorInput | TareaUpdateWithWhereUniqueWithoutCreadaPorInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutCreadaPorInput | TareaUpdateManyWithWhereWithoutCreadaPorInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type TareaUncheckedUpdateManyWithoutAsignadoANestedInput = {
    create?: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput> | TareaCreateWithoutAsignadoAInput[] | TareaUncheckedCreateWithoutAsignadoAInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutAsignadoAInput | TareaCreateOrConnectWithoutAsignadoAInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutAsignadoAInput | TareaUpsertWithWhereUniqueWithoutAsignadoAInput[]
    createMany?: TareaCreateManyAsignadoAInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutAsignadoAInput | TareaUpdateWithWhereUniqueWithoutAsignadoAInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutAsignadoAInput | TareaUpdateManyWithWhereWithoutAsignadoAInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput> | ComentarioBitacoraCreateWithoutCreadoPorInput[] | ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput | ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput[]
    upsert?: ComentarioBitacoraUpsertWithWhereUniqueWithoutCreadoPorInput | ComentarioBitacoraUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: ComentarioBitacoraCreateManyCreadoPorInputEnvelope
    set?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    disconnect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    delete?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    update?: ComentarioBitacoraUpdateWithWhereUniqueWithoutCreadoPorInput | ComentarioBitacoraUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: ComentarioBitacoraUpdateManyWithWhereWithoutCreadoPorInput | ComentarioBitacoraUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutEtiquetasInput = {
    create?: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput> | UserCreateWithoutEtiquetasInput[] | UserUncheckedCreateWithoutEtiquetasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEtiquetasInput | UserCreateOrConnectWithoutEtiquetasInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutEtiquetasInput = {
    create?: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput> | UserCreateWithoutEtiquetasInput[] | UserUncheckedCreateWithoutEtiquetasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEtiquetasInput | UserCreateOrConnectWithoutEtiquetasInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutEtiquetasNestedInput = {
    create?: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput> | UserCreateWithoutEtiquetasInput[] | UserUncheckedCreateWithoutEtiquetasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEtiquetasInput | UserCreateOrConnectWithoutEtiquetasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEtiquetasInput | UserUpsertWithWhereUniqueWithoutEtiquetasInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEtiquetasInput | UserUpdateWithWhereUniqueWithoutEtiquetasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEtiquetasInput | UserUpdateManyWithWhereWithoutEtiquetasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutEtiquetasNestedInput = {
    create?: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput> | UserCreateWithoutEtiquetasInput[] | UserUncheckedCreateWithoutEtiquetasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEtiquetasInput | UserCreateOrConnectWithoutEtiquetasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEtiquetasInput | UserUpsertWithWhereUniqueWithoutEtiquetasInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEtiquetasInput | UserUpdateWithWhereUniqueWithoutEtiquetasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEtiquetasInput | UserUpdateManyWithWhereWithoutEtiquetasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EstadoProyectoCreateNestedOneWithoutProyectosInput = {
    create?: XOR<EstadoProyectoCreateWithoutProyectosInput, EstadoProyectoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: EstadoProyectoCreateOrConnectWithoutProyectosInput
    connect?: EstadoProyectoWhereUniqueInput
  }

  export type UnidadMunicipalCreateNestedOneWithoutProyectosInput = {
    create?: XOR<UnidadMunicipalCreateWithoutProyectosInput, UnidadMunicipalUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: UnidadMunicipalCreateOrConnectWithoutProyectosInput
    connect?: UnidadMunicipalWhereUniqueInput
  }

  export type TipologiaProyectoCreateNestedOneWithoutProyectosInput = {
    create?: XOR<TipologiaProyectoCreateWithoutProyectosInput, TipologiaProyectoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: TipologiaProyectoCreateOrConnectWithoutProyectosInput
    connect?: TipologiaProyectoWhereUniqueInput
  }

  export type SectorCreateNestedOneWithoutProyectosInput = {
    create?: XOR<SectorCreateWithoutProyectosInput, SectorUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: SectorCreateOrConnectWithoutProyectosInput
    connect?: SectorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput = {
    create?: XOR<UserCreateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedCreateWithoutProyectosAsignadosComoProyectistaInput>
    connectOrCreate?: UserCreateOrConnectWithoutProyectosAsignadosComoProyectistaInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput = {
    create?: XOR<UserCreateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedCreateWithoutProyectosAsignadosComoFormuladorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProyectosAsignadosComoFormuladorInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutProyectosComoColaboradorInput = {
    create?: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput> | UserCreateWithoutProyectosComoColaboradorInput[] | UserUncheckedCreateWithoutProyectosComoColaboradorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProyectosComoColaboradorInput | UserCreateOrConnectWithoutProyectosComoColaboradorInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LineaFinanciamientoCreateNestedOneWithoutProyectosInput = {
    create?: XOR<LineaFinanciamientoCreateWithoutProyectosInput, LineaFinanciamientoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: LineaFinanciamientoCreateOrConnectWithoutProyectosInput
    connect?: LineaFinanciamientoWhereUniqueInput
  }

  export type ProgramaCreateNestedOneWithoutProyectosInput = {
    create?: XOR<ProgramaCreateWithoutProyectosInput, ProgramaUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutProyectosInput
    connect?: ProgramaWhereUniqueInput
  }

  export type EtapaFinanciamientoCreateNestedOneWithoutProyectosInput = {
    create?: XOR<EtapaFinanciamientoCreateWithoutProyectosInput, EtapaFinanciamientoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: EtapaFinanciamientoCreateOrConnectWithoutProyectosInput
    connect?: EtapaFinanciamientoWhereUniqueInput
  }

  export type TareaCreateNestedManyWithoutProyectoInput = {
    create?: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput> | TareaCreateWithoutProyectoInput[] | TareaUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutProyectoInput | TareaCreateOrConnectWithoutProyectoInput[]
    createMany?: TareaCreateManyProyectoInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput = {
    create?: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput> | UserCreateWithoutProyectosComoColaboradorInput[] | UserUncheckedCreateWithoutProyectosComoColaboradorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProyectosComoColaboradorInput | UserCreateOrConnectWithoutProyectosComoColaboradorInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TareaUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput> | TareaCreateWithoutProyectoInput[] | TareaUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutProyectoInput | TareaCreateOrConnectWithoutProyectoInput[]
    createMany?: TareaCreateManyProyectoInputEnvelope
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumTipoMonedaFieldUpdateOperationsInput = {
    set?: $Enums.TipoMoneda
  }

  export type EstadoProyectoUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<EstadoProyectoCreateWithoutProyectosInput, EstadoProyectoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: EstadoProyectoCreateOrConnectWithoutProyectosInput
    upsert?: EstadoProyectoUpsertWithoutProyectosInput
    disconnect?: EstadoProyectoWhereInput | boolean
    delete?: EstadoProyectoWhereInput | boolean
    connect?: EstadoProyectoWhereUniqueInput
    update?: XOR<XOR<EstadoProyectoUpdateToOneWithWhereWithoutProyectosInput, EstadoProyectoUpdateWithoutProyectosInput>, EstadoProyectoUncheckedUpdateWithoutProyectosInput>
  }

  export type UnidadMunicipalUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<UnidadMunicipalCreateWithoutProyectosInput, UnidadMunicipalUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: UnidadMunicipalCreateOrConnectWithoutProyectosInput
    upsert?: UnidadMunicipalUpsertWithoutProyectosInput
    disconnect?: UnidadMunicipalWhereInput | boolean
    delete?: UnidadMunicipalWhereInput | boolean
    connect?: UnidadMunicipalWhereUniqueInput
    update?: XOR<XOR<UnidadMunicipalUpdateToOneWithWhereWithoutProyectosInput, UnidadMunicipalUpdateWithoutProyectosInput>, UnidadMunicipalUncheckedUpdateWithoutProyectosInput>
  }

  export type TipologiaProyectoUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<TipologiaProyectoCreateWithoutProyectosInput, TipologiaProyectoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: TipologiaProyectoCreateOrConnectWithoutProyectosInput
    upsert?: TipologiaProyectoUpsertWithoutProyectosInput
    disconnect?: TipologiaProyectoWhereInput | boolean
    delete?: TipologiaProyectoWhereInput | boolean
    connect?: TipologiaProyectoWhereUniqueInput
    update?: XOR<XOR<TipologiaProyectoUpdateToOneWithWhereWithoutProyectosInput, TipologiaProyectoUpdateWithoutProyectosInput>, TipologiaProyectoUncheckedUpdateWithoutProyectosInput>
  }

  export type SectorUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<SectorCreateWithoutProyectosInput, SectorUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: SectorCreateOrConnectWithoutProyectosInput
    upsert?: SectorUpsertWithoutProyectosInput
    disconnect?: SectorWhereInput | boolean
    delete?: SectorWhereInput | boolean
    connect?: SectorWhereUniqueInput
    update?: XOR<XOR<SectorUpdateToOneWithWhereWithoutProyectosInput, SectorUpdateWithoutProyectosInput>, SectorUncheckedUpdateWithoutProyectosInput>
  }

  export type UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput = {
    create?: XOR<UserCreateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedCreateWithoutProyectosAsignadosComoProyectistaInput>
    connectOrCreate?: UserCreateOrConnectWithoutProyectosAsignadosComoProyectistaInput
    upsert?: UserUpsertWithoutProyectosAsignadosComoProyectistaInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProyectosAsignadosComoProyectistaInput, UserUpdateWithoutProyectosAsignadosComoProyectistaInput>, UserUncheckedUpdateWithoutProyectosAsignadosComoProyectistaInput>
  }

  export type UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput = {
    create?: XOR<UserCreateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedCreateWithoutProyectosAsignadosComoFormuladorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProyectosAsignadosComoFormuladorInput
    upsert?: UserUpsertWithoutProyectosAsignadosComoFormuladorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProyectosAsignadosComoFormuladorInput, UserUpdateWithoutProyectosAsignadosComoFormuladorInput>, UserUncheckedUpdateWithoutProyectosAsignadosComoFormuladorInput>
  }

  export type UserUpdateManyWithoutProyectosComoColaboradorNestedInput = {
    create?: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput> | UserCreateWithoutProyectosComoColaboradorInput[] | UserUncheckedCreateWithoutProyectosComoColaboradorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProyectosComoColaboradorInput | UserCreateOrConnectWithoutProyectosComoColaboradorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProyectosComoColaboradorInput | UserUpsertWithWhereUniqueWithoutProyectosComoColaboradorInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProyectosComoColaboradorInput | UserUpdateWithWhereUniqueWithoutProyectosComoColaboradorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProyectosComoColaboradorInput | UserUpdateManyWithWhereWithoutProyectosComoColaboradorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LineaFinanciamientoUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<LineaFinanciamientoCreateWithoutProyectosInput, LineaFinanciamientoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: LineaFinanciamientoCreateOrConnectWithoutProyectosInput
    upsert?: LineaFinanciamientoUpsertWithoutProyectosInput
    disconnect?: LineaFinanciamientoWhereInput | boolean
    delete?: LineaFinanciamientoWhereInput | boolean
    connect?: LineaFinanciamientoWhereUniqueInput
    update?: XOR<XOR<LineaFinanciamientoUpdateToOneWithWhereWithoutProyectosInput, LineaFinanciamientoUpdateWithoutProyectosInput>, LineaFinanciamientoUncheckedUpdateWithoutProyectosInput>
  }

  export type ProgramaUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<ProgramaCreateWithoutProyectosInput, ProgramaUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutProyectosInput
    upsert?: ProgramaUpsertWithoutProyectosInput
    disconnect?: ProgramaWhereInput | boolean
    delete?: ProgramaWhereInput | boolean
    connect?: ProgramaWhereUniqueInput
    update?: XOR<XOR<ProgramaUpdateToOneWithWhereWithoutProyectosInput, ProgramaUpdateWithoutProyectosInput>, ProgramaUncheckedUpdateWithoutProyectosInput>
  }

  export type EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput = {
    create?: XOR<EtapaFinanciamientoCreateWithoutProyectosInput, EtapaFinanciamientoUncheckedCreateWithoutProyectosInput>
    connectOrCreate?: EtapaFinanciamientoCreateOrConnectWithoutProyectosInput
    upsert?: EtapaFinanciamientoUpsertWithoutProyectosInput
    disconnect?: EtapaFinanciamientoWhereInput | boolean
    delete?: EtapaFinanciamientoWhereInput | boolean
    connect?: EtapaFinanciamientoWhereUniqueInput
    update?: XOR<XOR<EtapaFinanciamientoUpdateToOneWithWhereWithoutProyectosInput, EtapaFinanciamientoUpdateWithoutProyectosInput>, EtapaFinanciamientoUncheckedUpdateWithoutProyectosInput>
  }

  export type TareaUpdateManyWithoutProyectoNestedInput = {
    create?: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput> | TareaCreateWithoutProyectoInput[] | TareaUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutProyectoInput | TareaCreateOrConnectWithoutProyectoInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutProyectoInput | TareaUpsertWithWhereUniqueWithoutProyectoInput[]
    createMany?: TareaCreateManyProyectoInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutProyectoInput | TareaUpdateWithWhereUniqueWithoutProyectoInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutProyectoInput | TareaUpdateManyWithWhereWithoutProyectoInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput = {
    create?: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput> | UserCreateWithoutProyectosComoColaboradorInput[] | UserUncheckedCreateWithoutProyectosComoColaboradorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProyectosComoColaboradorInput | UserCreateOrConnectWithoutProyectosComoColaboradorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProyectosComoColaboradorInput | UserUpsertWithWhereUniqueWithoutProyectosComoColaboradorInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProyectosComoColaboradorInput | UserUpdateWithWhereUniqueWithoutProyectosComoColaboradorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProyectosComoColaboradorInput | UserUpdateManyWithWhereWithoutProyectosComoColaboradorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TareaUncheckedUpdateManyWithoutProyectoNestedInput = {
    create?: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput> | TareaCreateWithoutProyectoInput[] | TareaUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: TareaCreateOrConnectWithoutProyectoInput | TareaCreateOrConnectWithoutProyectoInput[]
    upsert?: TareaUpsertWithWhereUniqueWithoutProyectoInput | TareaUpsertWithWhereUniqueWithoutProyectoInput[]
    createMany?: TareaCreateManyProyectoInputEnvelope
    set?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    disconnect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    delete?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    connect?: TareaWhereUniqueInput | TareaWhereUniqueInput[]
    update?: TareaUpdateWithWhereUniqueWithoutProyectoInput | TareaUpdateWithWhereUniqueWithoutProyectoInput[]
    updateMany?: TareaUpdateManyWithWhereWithoutProyectoInput | TareaUpdateManyWithWhereWithoutProyectoInput[]
    deleteMany?: TareaScalarWhereInput | TareaScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutEstadoInput = {
    create?: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput> | ProjectCreateWithoutEstadoInput[] | ProjectUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEstadoInput | ProjectCreateOrConnectWithoutEstadoInput[]
    createMany?: ProjectCreateManyEstadoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutEstadoInput = {
    create?: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput> | ProjectCreateWithoutEstadoInput[] | ProjectUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEstadoInput | ProjectCreateOrConnectWithoutEstadoInput[]
    createMany?: ProjectCreateManyEstadoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput> | ProjectCreateWithoutEstadoInput[] | ProjectUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEstadoInput | ProjectCreateOrConnectWithoutEstadoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutEstadoInput | ProjectUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: ProjectCreateManyEstadoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutEstadoInput | ProjectUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutEstadoInput | ProjectUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput> | ProjectCreateWithoutEstadoInput[] | ProjectUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEstadoInput | ProjectCreateOrConnectWithoutEstadoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutEstadoInput | ProjectUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: ProjectCreateManyEstadoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutEstadoInput | ProjectUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutEstadoInput | ProjectUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutUnidadInput = {
    create?: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput> | ProjectCreateWithoutUnidadInput[] | ProjectUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUnidadInput | ProjectCreateOrConnectWithoutUnidadInput[]
    createMany?: ProjectCreateManyUnidadInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUnidadInput = {
    create?: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput> | ProjectCreateWithoutUnidadInput[] | ProjectUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUnidadInput | ProjectCreateOrConnectWithoutUnidadInput[]
    createMany?: ProjectCreateManyUnidadInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutUnidadNestedInput = {
    create?: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput> | ProjectCreateWithoutUnidadInput[] | ProjectUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUnidadInput | ProjectCreateOrConnectWithoutUnidadInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUnidadInput | ProjectUpsertWithWhereUniqueWithoutUnidadInput[]
    createMany?: ProjectCreateManyUnidadInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUnidadInput | ProjectUpdateWithWhereUniqueWithoutUnidadInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUnidadInput | ProjectUpdateManyWithWhereWithoutUnidadInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUnidadNestedInput = {
    create?: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput> | ProjectCreateWithoutUnidadInput[] | ProjectUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUnidadInput | ProjectCreateOrConnectWithoutUnidadInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUnidadInput | ProjectUpsertWithWhereUniqueWithoutUnidadInput[]
    createMany?: ProjectCreateManyUnidadInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUnidadInput | ProjectUpdateWithWhereUniqueWithoutUnidadInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUnidadInput | ProjectUpdateManyWithWhereWithoutUnidadInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutTipologiaInput = {
    create?: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput> | ProjectCreateWithoutTipologiaInput[] | ProjectUncheckedCreateWithoutTipologiaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTipologiaInput | ProjectCreateOrConnectWithoutTipologiaInput[]
    createMany?: ProjectCreateManyTipologiaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutTipologiaInput = {
    create?: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput> | ProjectCreateWithoutTipologiaInput[] | ProjectUncheckedCreateWithoutTipologiaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTipologiaInput | ProjectCreateOrConnectWithoutTipologiaInput[]
    createMany?: ProjectCreateManyTipologiaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutTipologiaNestedInput = {
    create?: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput> | ProjectCreateWithoutTipologiaInput[] | ProjectUncheckedCreateWithoutTipologiaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTipologiaInput | ProjectCreateOrConnectWithoutTipologiaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTipologiaInput | ProjectUpsertWithWhereUniqueWithoutTipologiaInput[]
    createMany?: ProjectCreateManyTipologiaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTipologiaInput | ProjectUpdateWithWhereUniqueWithoutTipologiaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTipologiaInput | ProjectUpdateManyWithWhereWithoutTipologiaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutTipologiaNestedInput = {
    create?: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput> | ProjectCreateWithoutTipologiaInput[] | ProjectUncheckedCreateWithoutTipologiaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTipologiaInput | ProjectCreateOrConnectWithoutTipologiaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTipologiaInput | ProjectUpsertWithWhereUniqueWithoutTipologiaInput[]
    createMany?: ProjectCreateManyTipologiaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTipologiaInput | ProjectUpdateWithWhereUniqueWithoutTipologiaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTipologiaInput | ProjectUpdateManyWithWhereWithoutTipologiaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutSectorInput = {
    create?: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput> | ProjectCreateWithoutSectorInput[] | ProjectUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSectorInput | ProjectCreateOrConnectWithoutSectorInput[]
    createMany?: ProjectCreateManySectorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutSectorInput = {
    create?: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput> | ProjectCreateWithoutSectorInput[] | ProjectUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSectorInput | ProjectCreateOrConnectWithoutSectorInput[]
    createMany?: ProjectCreateManySectorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput> | ProjectCreateWithoutSectorInput[] | ProjectUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSectorInput | ProjectCreateOrConnectWithoutSectorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSectorInput | ProjectUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ProjectCreateManySectorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSectorInput | ProjectUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSectorInput | ProjectUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutSectorNestedInput = {
    create?: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput> | ProjectCreateWithoutSectorInput[] | ProjectUncheckedCreateWithoutSectorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSectorInput | ProjectCreateOrConnectWithoutSectorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSectorInput | ProjectUpsertWithWhereUniqueWithoutSectorInput[]
    createMany?: ProjectCreateManySectorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSectorInput | ProjectUpdateWithWhereUniqueWithoutSectorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSectorInput | ProjectUpdateManyWithWhereWithoutSectorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProgramaCreateNestedManyWithoutLineaFinanciamientoInput = {
    create?: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput> | ProgramaCreateWithoutLineaFinanciamientoInput[] | ProgramaUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProgramaCreateOrConnectWithoutLineaFinanciamientoInput | ProgramaCreateOrConnectWithoutLineaFinanciamientoInput[]
    createMany?: ProgramaCreateManyLineaFinanciamientoInputEnvelope
    connect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutLineaFinanciamientoInput = {
    create?: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput> | ProjectCreateWithoutLineaFinanciamientoInput[] | ProjectUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLineaFinanciamientoInput | ProjectCreateOrConnectWithoutLineaFinanciamientoInput[]
    createMany?: ProjectCreateManyLineaFinanciamientoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProgramaUncheckedCreateNestedManyWithoutLineaFinanciamientoInput = {
    create?: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput> | ProgramaCreateWithoutLineaFinanciamientoInput[] | ProgramaUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProgramaCreateOrConnectWithoutLineaFinanciamientoInput | ProgramaCreateOrConnectWithoutLineaFinanciamientoInput[]
    createMany?: ProgramaCreateManyLineaFinanciamientoInputEnvelope
    connect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutLineaFinanciamientoInput = {
    create?: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput> | ProjectCreateWithoutLineaFinanciamientoInput[] | ProjectUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLineaFinanciamientoInput | ProjectCreateOrConnectWithoutLineaFinanciamientoInput[]
    createMany?: ProjectCreateManyLineaFinanciamientoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProgramaUpdateManyWithoutLineaFinanciamientoNestedInput = {
    create?: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput> | ProgramaCreateWithoutLineaFinanciamientoInput[] | ProgramaUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProgramaCreateOrConnectWithoutLineaFinanciamientoInput | ProgramaCreateOrConnectWithoutLineaFinanciamientoInput[]
    upsert?: ProgramaUpsertWithWhereUniqueWithoutLineaFinanciamientoInput | ProgramaUpsertWithWhereUniqueWithoutLineaFinanciamientoInput[]
    createMany?: ProgramaCreateManyLineaFinanciamientoInputEnvelope
    set?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    disconnect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    delete?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    connect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    update?: ProgramaUpdateWithWhereUniqueWithoutLineaFinanciamientoInput | ProgramaUpdateWithWhereUniqueWithoutLineaFinanciamientoInput[]
    updateMany?: ProgramaUpdateManyWithWhereWithoutLineaFinanciamientoInput | ProgramaUpdateManyWithWhereWithoutLineaFinanciamientoInput[]
    deleteMany?: ProgramaScalarWhereInput | ProgramaScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutLineaFinanciamientoNestedInput = {
    create?: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput> | ProjectCreateWithoutLineaFinanciamientoInput[] | ProjectUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLineaFinanciamientoInput | ProjectCreateOrConnectWithoutLineaFinanciamientoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutLineaFinanciamientoInput | ProjectUpsertWithWhereUniqueWithoutLineaFinanciamientoInput[]
    createMany?: ProjectCreateManyLineaFinanciamientoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutLineaFinanciamientoInput | ProjectUpdateWithWhereUniqueWithoutLineaFinanciamientoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutLineaFinanciamientoInput | ProjectUpdateManyWithWhereWithoutLineaFinanciamientoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProgramaUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput = {
    create?: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput> | ProgramaCreateWithoutLineaFinanciamientoInput[] | ProgramaUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProgramaCreateOrConnectWithoutLineaFinanciamientoInput | ProgramaCreateOrConnectWithoutLineaFinanciamientoInput[]
    upsert?: ProgramaUpsertWithWhereUniqueWithoutLineaFinanciamientoInput | ProgramaUpsertWithWhereUniqueWithoutLineaFinanciamientoInput[]
    createMany?: ProgramaCreateManyLineaFinanciamientoInputEnvelope
    set?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    disconnect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    delete?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    connect?: ProgramaWhereUniqueInput | ProgramaWhereUniqueInput[]
    update?: ProgramaUpdateWithWhereUniqueWithoutLineaFinanciamientoInput | ProgramaUpdateWithWhereUniqueWithoutLineaFinanciamientoInput[]
    updateMany?: ProgramaUpdateManyWithWhereWithoutLineaFinanciamientoInput | ProgramaUpdateManyWithWhereWithoutLineaFinanciamientoInput[]
    deleteMany?: ProgramaScalarWhereInput | ProgramaScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput = {
    create?: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput> | ProjectCreateWithoutLineaFinanciamientoInput[] | ProjectUncheckedCreateWithoutLineaFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLineaFinanciamientoInput | ProjectCreateOrConnectWithoutLineaFinanciamientoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutLineaFinanciamientoInput | ProjectUpsertWithWhereUniqueWithoutLineaFinanciamientoInput[]
    createMany?: ProjectCreateManyLineaFinanciamientoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutLineaFinanciamientoInput | ProjectUpdateWithWhereUniqueWithoutLineaFinanciamientoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutLineaFinanciamientoInput | ProjectUpdateManyWithWhereWithoutLineaFinanciamientoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type LineaFinanciamientoCreateNestedOneWithoutProgramasInput = {
    create?: XOR<LineaFinanciamientoCreateWithoutProgramasInput, LineaFinanciamientoUncheckedCreateWithoutProgramasInput>
    connectOrCreate?: LineaFinanciamientoCreateOrConnectWithoutProgramasInput
    connect?: LineaFinanciamientoWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutProgramaInput = {
    create?: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput> | ProjectCreateWithoutProgramaInput[] | ProjectUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramaInput | ProjectCreateOrConnectWithoutProgramaInput[]
    createMany?: ProjectCreateManyProgramaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProgramaInput = {
    create?: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput> | ProjectCreateWithoutProgramaInput[] | ProjectUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramaInput | ProjectCreateOrConnectWithoutProgramaInput[]
    createMany?: ProjectCreateManyProgramaInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type LineaFinanciamientoUpdateOneRequiredWithoutProgramasNestedInput = {
    create?: XOR<LineaFinanciamientoCreateWithoutProgramasInput, LineaFinanciamientoUncheckedCreateWithoutProgramasInput>
    connectOrCreate?: LineaFinanciamientoCreateOrConnectWithoutProgramasInput
    upsert?: LineaFinanciamientoUpsertWithoutProgramasInput
    connect?: LineaFinanciamientoWhereUniqueInput
    update?: XOR<XOR<LineaFinanciamientoUpdateToOneWithWhereWithoutProgramasInput, LineaFinanciamientoUpdateWithoutProgramasInput>, LineaFinanciamientoUncheckedUpdateWithoutProgramasInput>
  }

  export type ProjectUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput> | ProjectCreateWithoutProgramaInput[] | ProjectUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramaInput | ProjectCreateOrConnectWithoutProgramaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProgramaInput | ProjectUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: ProjectCreateManyProgramaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProgramaInput | ProjectUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProgramaInput | ProjectUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput> | ProjectCreateWithoutProgramaInput[] | ProjectUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramaInput | ProjectCreateOrConnectWithoutProgramaInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProgramaInput | ProjectUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: ProjectCreateManyProgramaInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProgramaInput | ProjectUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProgramaInput | ProjectUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutEtapaActualFinanciamientoInput = {
    create?: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput> | ProjectCreateWithoutEtapaActualFinanciamientoInput[] | ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput | ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput[]
    createMany?: ProjectCreateManyEtapaActualFinanciamientoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutEtapaActualFinanciamientoInput = {
    create?: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput> | ProjectCreateWithoutEtapaActualFinanciamientoInput[] | ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput | ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput[]
    createMany?: ProjectCreateManyEtapaActualFinanciamientoInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutEtapaActualFinanciamientoNestedInput = {
    create?: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput> | ProjectCreateWithoutEtapaActualFinanciamientoInput[] | ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput | ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutEtapaActualFinanciamientoInput | ProjectUpsertWithWhereUniqueWithoutEtapaActualFinanciamientoInput[]
    createMany?: ProjectCreateManyEtapaActualFinanciamientoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutEtapaActualFinanciamientoInput | ProjectUpdateWithWhereUniqueWithoutEtapaActualFinanciamientoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutEtapaActualFinanciamientoInput | ProjectUpdateManyWithWhereWithoutEtapaActualFinanciamientoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutEtapaActualFinanciamientoNestedInput = {
    create?: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput> | ProjectCreateWithoutEtapaActualFinanciamientoInput[] | ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput | ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutEtapaActualFinanciamientoInput | ProjectUpsertWithWhereUniqueWithoutEtapaActualFinanciamientoInput[]
    createMany?: ProjectCreateManyEtapaActualFinanciamientoInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutEtapaActualFinanciamientoInput | ProjectUpdateWithWhereUniqueWithoutEtapaActualFinanciamientoInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutEtapaActualFinanciamientoInput | ProjectUpdateManyWithWhereWithoutEtapaActualFinanciamientoInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTareasInput = {
    create?: XOR<ProjectCreateWithoutTareasInput, ProjectUncheckedCreateWithoutTareasInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTareasInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTareasCreadasInput = {
    create?: XOR<UserCreateWithoutTareasCreadasInput, UserUncheckedCreateWithoutTareasCreadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutTareasCreadasInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTareasAsignadasInput = {
    create?: XOR<UserCreateWithoutTareasAsignadasInput, UserUncheckedCreateWithoutTareasAsignadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutTareasAsignadasInput
    connect?: UserWhereUniqueInput
  }

  export type ComentarioBitacoraCreateNestedManyWithoutTareaInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput> | ComentarioBitacoraCreateWithoutTareaInput[] | ComentarioBitacoraUncheckedCreateWithoutTareaInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutTareaInput | ComentarioBitacoraCreateOrConnectWithoutTareaInput[]
    createMany?: ComentarioBitacoraCreateManyTareaInputEnvelope
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
  }

  export type ComentarioBitacoraUncheckedCreateNestedManyWithoutTareaInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput> | ComentarioBitacoraCreateWithoutTareaInput[] | ComentarioBitacoraUncheckedCreateWithoutTareaInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutTareaInput | ComentarioBitacoraCreateOrConnectWithoutTareaInput[]
    createMany?: ComentarioBitacoraCreateManyTareaInputEnvelope
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTareasNestedInput = {
    create?: XOR<ProjectCreateWithoutTareasInput, ProjectUncheckedCreateWithoutTareasInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTareasInput
    upsert?: ProjectUpsertWithoutTareasInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTareasInput, ProjectUpdateWithoutTareasInput>, ProjectUncheckedUpdateWithoutTareasInput>
  }

  export type UserUpdateOneRequiredWithoutTareasCreadasNestedInput = {
    create?: XOR<UserCreateWithoutTareasCreadasInput, UserUncheckedCreateWithoutTareasCreadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutTareasCreadasInput
    upsert?: UserUpsertWithoutTareasCreadasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTareasCreadasInput, UserUpdateWithoutTareasCreadasInput>, UserUncheckedUpdateWithoutTareasCreadasInput>
  }

  export type UserUpdateOneWithoutTareasAsignadasNestedInput = {
    create?: XOR<UserCreateWithoutTareasAsignadasInput, UserUncheckedCreateWithoutTareasAsignadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutTareasAsignadasInput
    upsert?: UserUpsertWithoutTareasAsignadasInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTareasAsignadasInput, UserUpdateWithoutTareasAsignadasInput>, UserUncheckedUpdateWithoutTareasAsignadasInput>
  }

  export type ComentarioBitacoraUpdateManyWithoutTareaNestedInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput> | ComentarioBitacoraCreateWithoutTareaInput[] | ComentarioBitacoraUncheckedCreateWithoutTareaInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutTareaInput | ComentarioBitacoraCreateOrConnectWithoutTareaInput[]
    upsert?: ComentarioBitacoraUpsertWithWhereUniqueWithoutTareaInput | ComentarioBitacoraUpsertWithWhereUniqueWithoutTareaInput[]
    createMany?: ComentarioBitacoraCreateManyTareaInputEnvelope
    set?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    disconnect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    delete?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    update?: ComentarioBitacoraUpdateWithWhereUniqueWithoutTareaInput | ComentarioBitacoraUpdateWithWhereUniqueWithoutTareaInput[]
    updateMany?: ComentarioBitacoraUpdateManyWithWhereWithoutTareaInput | ComentarioBitacoraUpdateManyWithWhereWithoutTareaInput[]
    deleteMany?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
  }

  export type ComentarioBitacoraUncheckedUpdateManyWithoutTareaNestedInput = {
    create?: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput> | ComentarioBitacoraCreateWithoutTareaInput[] | ComentarioBitacoraUncheckedCreateWithoutTareaInput[]
    connectOrCreate?: ComentarioBitacoraCreateOrConnectWithoutTareaInput | ComentarioBitacoraCreateOrConnectWithoutTareaInput[]
    upsert?: ComentarioBitacoraUpsertWithWhereUniqueWithoutTareaInput | ComentarioBitacoraUpsertWithWhereUniqueWithoutTareaInput[]
    createMany?: ComentarioBitacoraCreateManyTareaInputEnvelope
    set?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    disconnect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    delete?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    connect?: ComentarioBitacoraWhereUniqueInput | ComentarioBitacoraWhereUniqueInput[]
    update?: ComentarioBitacoraUpdateWithWhereUniqueWithoutTareaInput | ComentarioBitacoraUpdateWithWhereUniqueWithoutTareaInput[]
    updateMany?: ComentarioBitacoraUpdateManyWithWhereWithoutTareaInput | ComentarioBitacoraUpdateManyWithWhereWithoutTareaInput[]
    deleteMany?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
  }

  export type TareaCreateNestedOneWithoutComentariosInput = {
    create?: XOR<TareaCreateWithoutComentariosInput, TareaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: TareaCreateOrConnectWithoutComentariosInput
    connect?: TareaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComentariosBitacoraInput = {
    create?: XOR<UserCreateWithoutComentariosBitacoraInput, UserUncheckedCreateWithoutComentariosBitacoraInput>
    connectOrCreate?: UserCreateOrConnectWithoutComentariosBitacoraInput
    connect?: UserWhereUniqueInput
  }

  export type TareaUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<TareaCreateWithoutComentariosInput, TareaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: TareaCreateOrConnectWithoutComentariosInput
    upsert?: TareaUpsertWithoutComentariosInput
    connect?: TareaWhereUniqueInput
    update?: XOR<XOR<TareaUpdateToOneWithWhereWithoutComentariosInput, TareaUpdateWithoutComentariosInput>, TareaUncheckedUpdateWithoutComentariosInput>
  }

  export type UserUpdateOneRequiredWithoutComentariosBitacoraNestedInput = {
    create?: XOR<UserCreateWithoutComentariosBitacoraInput, UserUncheckedCreateWithoutComentariosBitacoraInput>
    connectOrCreate?: UserCreateOrConnectWithoutComentariosBitacoraInput
    upsert?: UserUpsertWithoutComentariosBitacoraInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComentariosBitacoraInput, UserUpdateWithoutComentariosBitacoraInput>, UserUncheckedUpdateWithoutComentariosBitacoraInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumTipoMonedaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMoneda | EnumTipoMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMonedaFilter<$PrismaModel> | $Enums.TipoMoneda
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoMonedaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMoneda | EnumTipoMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMoneda[] | ListEnumTipoMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMonedaWithAggregatesFilter<$PrismaModel> | $Enums.TipoMoneda
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMonedaFilter<$PrismaModel>
    _max?: NestedEnumTipoMonedaFilter<$PrismaModel>
  }

  export type EtiquetaCreateWithoutUsuariosInput = {
    nombre: string
    color?: string
  }

  export type EtiquetaUncheckedCreateWithoutUsuariosInput = {
    id?: number
    nombre: string
    color?: string
  }

  export type EtiquetaCreateOrConnectWithoutUsuariosInput = {
    where: EtiquetaWhereUniqueInput
    create: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput>
  }

  export type ProjectCreateWithoutProyectistaInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutProyectistaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutProyectistaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput>
  }

  export type ProjectCreateManyProyectistaInputEnvelope = {
    data: ProjectCreateManyProyectistaInput | ProjectCreateManyProyectistaInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutFormuladorInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutFormuladorInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutFormuladorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput>
  }

  export type ProjectCreateManyFormuladorInputEnvelope = {
    data: ProjectCreateManyFormuladorInput | ProjectCreateManyFormuladorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutColaboradoresInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutColaboradoresInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutColaboradoresInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput>
  }

  export type TareaCreateWithoutCreadaPorInput = {
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyecto: ProjectCreateNestedOneWithoutTareasInput
    asignadoA?: UserCreateNestedOneWithoutTareasAsignadasInput
    comentarios?: ComentarioBitacoraCreateNestedManyWithoutTareaInput
  }

  export type TareaUncheckedCreateWithoutCreadaPorInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    asignadoAId?: number | null
    comentarios?: ComentarioBitacoraUncheckedCreateNestedManyWithoutTareaInput
  }

  export type TareaCreateOrConnectWithoutCreadaPorInput = {
    where: TareaWhereUniqueInput
    create: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput>
  }

  export type TareaCreateManyCreadaPorInputEnvelope = {
    data: TareaCreateManyCreadaPorInput | TareaCreateManyCreadaPorInput[]
    skipDuplicates?: boolean
  }

  export type TareaCreateWithoutAsignadoAInput = {
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyecto: ProjectCreateNestedOneWithoutTareasInput
    creadaPor: UserCreateNestedOneWithoutTareasCreadasInput
    comentarios?: ComentarioBitacoraCreateNestedManyWithoutTareaInput
  }

  export type TareaUncheckedCreateWithoutAsignadoAInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    creadaPorId: number
    comentarios?: ComentarioBitacoraUncheckedCreateNestedManyWithoutTareaInput
  }

  export type TareaCreateOrConnectWithoutAsignadoAInput = {
    where: TareaWhereUniqueInput
    create: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput>
  }

  export type TareaCreateManyAsignadoAInputEnvelope = {
    data: TareaCreateManyAsignadoAInput | TareaCreateManyAsignadoAInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioBitacoraCreateWithoutCreadoPorInput = {
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tarea: TareaCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tareaId: number
  }

  export type ComentarioBitacoraCreateOrConnectWithoutCreadoPorInput = {
    where: ComentarioBitacoraWhereUniqueInput
    create: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput>
  }

  export type ComentarioBitacoraCreateManyCreadoPorInputEnvelope = {
    data: ComentarioBitacoraCreateManyCreadoPorInput | ComentarioBitacoraCreateManyCreadoPorInput[]
    skipDuplicates?: boolean
  }

  export type EtiquetaUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: EtiquetaWhereUniqueInput
    update: XOR<EtiquetaUpdateWithoutUsuariosInput, EtiquetaUncheckedUpdateWithoutUsuariosInput>
    create: XOR<EtiquetaCreateWithoutUsuariosInput, EtiquetaUncheckedCreateWithoutUsuariosInput>
  }

  export type EtiquetaUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: EtiquetaWhereUniqueInput
    data: XOR<EtiquetaUpdateWithoutUsuariosInput, EtiquetaUncheckedUpdateWithoutUsuariosInput>
  }

  export type EtiquetaUpdateManyWithWhereWithoutUsuariosInput = {
    where: EtiquetaScalarWhereInput
    data: XOR<EtiquetaUpdateManyMutationInput, EtiquetaUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type EtiquetaScalarWhereInput = {
    AND?: EtiquetaScalarWhereInput | EtiquetaScalarWhereInput[]
    OR?: EtiquetaScalarWhereInput[]
    NOT?: EtiquetaScalarWhereInput | EtiquetaScalarWhereInput[]
    id?: IntFilter<"Etiqueta"> | number
    nombre?: StringFilter<"Etiqueta"> | string
    color?: StringFilter<"Etiqueta"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutProyectistaInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProyectistaInput, ProjectUncheckedUpdateWithoutProyectistaInput>
    create: XOR<ProjectCreateWithoutProyectistaInput, ProjectUncheckedCreateWithoutProyectistaInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProyectistaInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProyectistaInput, ProjectUncheckedUpdateWithoutProyectistaInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProyectistaInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProyectistaInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    codigoUnico?: StringFilter<"Project"> | string
    nombre?: StringFilter<"Project"> | string
    descripcion?: StringNullableFilter<"Project"> | string | null
    direccion?: StringNullableFilter<"Project"> | string | null
    superficieTerreno?: FloatNullableFilter<"Project"> | number | null
    superficieEdificacion?: FloatNullableFilter<"Project"> | number | null
    ano?: IntNullableFilter<"Project"> | number | null
    proyectoPriorizado?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    estadoId?: IntNullableFilter<"Project"> | number | null
    unidadId?: IntNullableFilter<"Project"> | number | null
    tipologiaId?: IntNullableFilter<"Project"> | number | null
    sectorId?: IntNullableFilter<"Project"> | number | null
    proyectistaId?: IntNullableFilter<"Project"> | number | null
    formuladorId?: IntNullableFilter<"Project"> | number | null
    lineaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    programaId?: IntNullableFilter<"Project"> | number | null
    etapaFinanciamientoId?: IntNullableFilter<"Project"> | number | null
    codigoExpediente?: StringNullableFilter<"Project"> | string | null
    fechaPostulacion?: DateTimeNullableFilter<"Project"> | Date | string | null
    monto?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFilter<"Project"> | $Enums.TipoMoneda
    montoAdjudicado?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutFormuladorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutFormuladorInput, ProjectUncheckedUpdateWithoutFormuladorInput>
    create: XOR<ProjectCreateWithoutFormuladorInput, ProjectUncheckedCreateWithoutFormuladorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutFormuladorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutFormuladorInput, ProjectUncheckedUpdateWithoutFormuladorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutFormuladorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutFormuladorInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutColaboradoresInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutColaboradoresInput, ProjectUncheckedUpdateWithoutColaboradoresInput>
    create: XOR<ProjectCreateWithoutColaboradoresInput, ProjectUncheckedCreateWithoutColaboradoresInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutColaboradoresInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutColaboradoresInput, ProjectUncheckedUpdateWithoutColaboradoresInput>
  }

  export type ProjectUpdateManyWithWhereWithoutColaboradoresInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutColaboradoresInput>
  }

  export type TareaUpsertWithWhereUniqueWithoutCreadaPorInput = {
    where: TareaWhereUniqueInput
    update: XOR<TareaUpdateWithoutCreadaPorInput, TareaUncheckedUpdateWithoutCreadaPorInput>
    create: XOR<TareaCreateWithoutCreadaPorInput, TareaUncheckedCreateWithoutCreadaPorInput>
  }

  export type TareaUpdateWithWhereUniqueWithoutCreadaPorInput = {
    where: TareaWhereUniqueInput
    data: XOR<TareaUpdateWithoutCreadaPorInput, TareaUncheckedUpdateWithoutCreadaPorInput>
  }

  export type TareaUpdateManyWithWhereWithoutCreadaPorInput = {
    where: TareaScalarWhereInput
    data: XOR<TareaUpdateManyMutationInput, TareaUncheckedUpdateManyWithoutCreadaPorInput>
  }

  export type TareaScalarWhereInput = {
    AND?: TareaScalarWhereInput | TareaScalarWhereInput[]
    OR?: TareaScalarWhereInput[]
    NOT?: TareaScalarWhereInput | TareaScalarWhereInput[]
    id?: IntFilter<"Tarea"> | number
    titulo?: StringFilter<"Tarea"> | string
    descripcion?: StringNullableFilter<"Tarea"> | string | null
    fechaPlazo?: DateTimeNullableFilter<"Tarea"> | Date | string | null
    createdAt?: DateTimeFilter<"Tarea"> | Date | string
    updatedAt?: DateTimeFilter<"Tarea"> | Date | string
    proyectoId?: IntFilter<"Tarea"> | number
    creadaPorId?: IntFilter<"Tarea"> | number
    asignadoAId?: IntNullableFilter<"Tarea"> | number | null
  }

  export type TareaUpsertWithWhereUniqueWithoutAsignadoAInput = {
    where: TareaWhereUniqueInput
    update: XOR<TareaUpdateWithoutAsignadoAInput, TareaUncheckedUpdateWithoutAsignadoAInput>
    create: XOR<TareaCreateWithoutAsignadoAInput, TareaUncheckedCreateWithoutAsignadoAInput>
  }

  export type TareaUpdateWithWhereUniqueWithoutAsignadoAInput = {
    where: TareaWhereUniqueInput
    data: XOR<TareaUpdateWithoutAsignadoAInput, TareaUncheckedUpdateWithoutAsignadoAInput>
  }

  export type TareaUpdateManyWithWhereWithoutAsignadoAInput = {
    where: TareaScalarWhereInput
    data: XOR<TareaUpdateManyMutationInput, TareaUncheckedUpdateManyWithoutAsignadoAInput>
  }

  export type ComentarioBitacoraUpsertWithWhereUniqueWithoutCreadoPorInput = {
    where: ComentarioBitacoraWhereUniqueInput
    update: XOR<ComentarioBitacoraUpdateWithoutCreadoPorInput, ComentarioBitacoraUncheckedUpdateWithoutCreadoPorInput>
    create: XOR<ComentarioBitacoraCreateWithoutCreadoPorInput, ComentarioBitacoraUncheckedCreateWithoutCreadoPorInput>
  }

  export type ComentarioBitacoraUpdateWithWhereUniqueWithoutCreadoPorInput = {
    where: ComentarioBitacoraWhereUniqueInput
    data: XOR<ComentarioBitacoraUpdateWithoutCreadoPorInput, ComentarioBitacoraUncheckedUpdateWithoutCreadoPorInput>
  }

  export type ComentarioBitacoraUpdateManyWithWhereWithoutCreadoPorInput = {
    where: ComentarioBitacoraScalarWhereInput
    data: XOR<ComentarioBitacoraUpdateManyMutationInput, ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorInput>
  }

  export type ComentarioBitacoraScalarWhereInput = {
    AND?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
    OR?: ComentarioBitacoraScalarWhereInput[]
    NOT?: ComentarioBitacoraScalarWhereInput | ComentarioBitacoraScalarWhereInput[]
    id?: IntFilter<"ComentarioBitacora"> | number
    contenido?: StringFilter<"ComentarioBitacora"> | string
    createdAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    updatedAt?: DateTimeFilter<"ComentarioBitacora"> | Date | string
    tareaId?: IntFilter<"ComentarioBitacora"> | number
    creadoPorId?: IntFilter<"ComentarioBitacora"> | number
  }

  export type UserCreateWithoutEtiquetasInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutEtiquetasInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutEtiquetasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput>
  }

  export type UserUpsertWithWhereUniqueWithoutEtiquetasInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutEtiquetasInput, UserUncheckedUpdateWithoutEtiquetasInput>
    create: XOR<UserCreateWithoutEtiquetasInput, UserUncheckedCreateWithoutEtiquetasInput>
  }

  export type UserUpdateWithWhereUniqueWithoutEtiquetasInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutEtiquetasInput, UserUncheckedUpdateWithoutEtiquetasInput>
  }

  export type UserUpdateManyWithWhereWithoutEtiquetasInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutEtiquetasInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type EstadoProyectoCreateWithoutProyectosInput = {
    nombre: string
  }

  export type EstadoProyectoUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
  }

  export type EstadoProyectoCreateOrConnectWithoutProyectosInput = {
    where: EstadoProyectoWhereUniqueInput
    create: XOR<EstadoProyectoCreateWithoutProyectosInput, EstadoProyectoUncheckedCreateWithoutProyectosInput>
  }

  export type UnidadMunicipalCreateWithoutProyectosInput = {
    nombre: string
    abreviacion: string
  }

  export type UnidadMunicipalUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
    abreviacion: string
  }

  export type UnidadMunicipalCreateOrConnectWithoutProyectosInput = {
    where: UnidadMunicipalWhereUniqueInput
    create: XOR<UnidadMunicipalCreateWithoutProyectosInput, UnidadMunicipalUncheckedCreateWithoutProyectosInput>
  }

  export type TipologiaProyectoCreateWithoutProyectosInput = {
    nombre: string
    abreviacion: string
    colorChip?: string
  }

  export type TipologiaProyectoUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
    abreviacion: string
    colorChip?: string
  }

  export type TipologiaProyectoCreateOrConnectWithoutProyectosInput = {
    where: TipologiaProyectoWhereUniqueInput
    create: XOR<TipologiaProyectoCreateWithoutProyectosInput, TipologiaProyectoUncheckedCreateWithoutProyectosInput>
  }

  export type SectorCreateWithoutProyectosInput = {
    nombre: string
  }

  export type SectorUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
  }

  export type SectorCreateOrConnectWithoutProyectosInput = {
    where: SectorWhereUniqueInput
    create: XOR<SectorCreateWithoutProyectosInput, SectorUncheckedCreateWithoutProyectosInput>
  }

  export type UserCreateWithoutProyectosAsignadosComoProyectistaInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutProyectosAsignadosComoProyectistaInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutProyectosAsignadosComoProyectistaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedCreateWithoutProyectosAsignadosComoProyectistaInput>
  }

  export type UserCreateWithoutProyectosAsignadosComoFormuladorInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutProyectosAsignadosComoFormuladorInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutProyectosAsignadosComoFormuladorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedCreateWithoutProyectosAsignadosComoFormuladorInput>
  }

  export type UserCreateWithoutProyectosComoColaboradorInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutProyectosComoColaboradorInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutProyectosComoColaboradorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput>
  }

  export type LineaFinanciamientoCreateWithoutProyectosInput = {
    nombre: string
    programas?: ProgramaCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
    programas?: ProgramaUncheckedCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoCreateOrConnectWithoutProyectosInput = {
    where: LineaFinanciamientoWhereUniqueInput
    create: XOR<LineaFinanciamientoCreateWithoutProyectosInput, LineaFinanciamientoUncheckedCreateWithoutProyectosInput>
  }

  export type ProgramaCreateWithoutProyectosInput = {
    nombre: string
    lineaFinanciamiento: LineaFinanciamientoCreateNestedOneWithoutProgramasInput
  }

  export type ProgramaUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
    lineaFinanciamientoId: number
  }

  export type ProgramaCreateOrConnectWithoutProyectosInput = {
    where: ProgramaWhereUniqueInput
    create: XOR<ProgramaCreateWithoutProyectosInput, ProgramaUncheckedCreateWithoutProyectosInput>
  }

  export type EtapaFinanciamientoCreateWithoutProyectosInput = {
    nombre: string
  }

  export type EtapaFinanciamientoUncheckedCreateWithoutProyectosInput = {
    id?: number
    nombre: string
  }

  export type EtapaFinanciamientoCreateOrConnectWithoutProyectosInput = {
    where: EtapaFinanciamientoWhereUniqueInput
    create: XOR<EtapaFinanciamientoCreateWithoutProyectosInput, EtapaFinanciamientoUncheckedCreateWithoutProyectosInput>
  }

  export type TareaCreateWithoutProyectoInput = {
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creadaPor: UserCreateNestedOneWithoutTareasCreadasInput
    asignadoA?: UserCreateNestedOneWithoutTareasAsignadasInput
    comentarios?: ComentarioBitacoraCreateNestedManyWithoutTareaInput
  }

  export type TareaUncheckedCreateWithoutProyectoInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creadaPorId: number
    asignadoAId?: number | null
    comentarios?: ComentarioBitacoraUncheckedCreateNestedManyWithoutTareaInput
  }

  export type TareaCreateOrConnectWithoutProyectoInput = {
    where: TareaWhereUniqueInput
    create: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput>
  }

  export type TareaCreateManyProyectoInputEnvelope = {
    data: TareaCreateManyProyectoInput | TareaCreateManyProyectoInput[]
    skipDuplicates?: boolean
  }

  export type EstadoProyectoUpsertWithoutProyectosInput = {
    update: XOR<EstadoProyectoUpdateWithoutProyectosInput, EstadoProyectoUncheckedUpdateWithoutProyectosInput>
    create: XOR<EstadoProyectoCreateWithoutProyectosInput, EstadoProyectoUncheckedCreateWithoutProyectosInput>
    where?: EstadoProyectoWhereInput
  }

  export type EstadoProyectoUpdateToOneWithWhereWithoutProyectosInput = {
    where?: EstadoProyectoWhereInput
    data: XOR<EstadoProyectoUpdateWithoutProyectosInput, EstadoProyectoUncheckedUpdateWithoutProyectosInput>
  }

  export type EstadoProyectoUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoProyectoUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadMunicipalUpsertWithoutProyectosInput = {
    update: XOR<UnidadMunicipalUpdateWithoutProyectosInput, UnidadMunicipalUncheckedUpdateWithoutProyectosInput>
    create: XOR<UnidadMunicipalCreateWithoutProyectosInput, UnidadMunicipalUncheckedCreateWithoutProyectosInput>
    where?: UnidadMunicipalWhereInput
  }

  export type UnidadMunicipalUpdateToOneWithWhereWithoutProyectosInput = {
    where?: UnidadMunicipalWhereInput
    data: XOR<UnidadMunicipalUpdateWithoutProyectosInput, UnidadMunicipalUncheckedUpdateWithoutProyectosInput>
  }

  export type UnidadMunicipalUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadMunicipalUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
  }

  export type TipologiaProyectoUpsertWithoutProyectosInput = {
    update: XOR<TipologiaProyectoUpdateWithoutProyectosInput, TipologiaProyectoUncheckedUpdateWithoutProyectosInput>
    create: XOR<TipologiaProyectoCreateWithoutProyectosInput, TipologiaProyectoUncheckedCreateWithoutProyectosInput>
    where?: TipologiaProyectoWhereInput
  }

  export type TipologiaProyectoUpdateToOneWithWhereWithoutProyectosInput = {
    where?: TipologiaProyectoWhereInput
    data: XOR<TipologiaProyectoUpdateWithoutProyectosInput, TipologiaProyectoUncheckedUpdateWithoutProyectosInput>
  }

  export type TipologiaProyectoUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
  }

  export type TipologiaProyectoUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    abreviacion?: StringFieldUpdateOperationsInput | string
    colorChip?: StringFieldUpdateOperationsInput | string
  }

  export type SectorUpsertWithoutProyectosInput = {
    update: XOR<SectorUpdateWithoutProyectosInput, SectorUncheckedUpdateWithoutProyectosInput>
    create: XOR<SectorCreateWithoutProyectosInput, SectorUncheckedCreateWithoutProyectosInput>
    where?: SectorWhereInput
  }

  export type SectorUpdateToOneWithWhereWithoutProyectosInput = {
    where?: SectorWhereInput
    data: XOR<SectorUpdateWithoutProyectosInput, SectorUncheckedUpdateWithoutProyectosInput>
  }

  export type SectorUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SectorUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutProyectosAsignadosComoProyectistaInput = {
    update: XOR<UserUpdateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedUpdateWithoutProyectosAsignadosComoProyectistaInput>
    create: XOR<UserCreateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedCreateWithoutProyectosAsignadosComoProyectistaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProyectosAsignadosComoProyectistaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProyectosAsignadosComoProyectistaInput, UserUncheckedUpdateWithoutProyectosAsignadosComoProyectistaInput>
  }

  export type UserUpdateWithoutProyectosAsignadosComoProyectistaInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutProyectosAsignadosComoProyectistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUpsertWithoutProyectosAsignadosComoFormuladorInput = {
    update: XOR<UserUpdateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedUpdateWithoutProyectosAsignadosComoFormuladorInput>
    create: XOR<UserCreateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedCreateWithoutProyectosAsignadosComoFormuladorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProyectosAsignadosComoFormuladorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProyectosAsignadosComoFormuladorInput, UserUncheckedUpdateWithoutProyectosAsignadosComoFormuladorInput>
  }

  export type UserUpdateWithoutProyectosAsignadosComoFormuladorInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutProyectosAsignadosComoFormuladorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutProyectosComoColaboradorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProyectosComoColaboradorInput, UserUncheckedUpdateWithoutProyectosComoColaboradorInput>
    create: XOR<UserCreateWithoutProyectosComoColaboradorInput, UserUncheckedCreateWithoutProyectosComoColaboradorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProyectosComoColaboradorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProyectosComoColaboradorInput, UserUncheckedUpdateWithoutProyectosComoColaboradorInput>
  }

  export type UserUpdateManyWithWhereWithoutProyectosComoColaboradorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProyectosComoColaboradorInput>
  }

  export type LineaFinanciamientoUpsertWithoutProyectosInput = {
    update: XOR<LineaFinanciamientoUpdateWithoutProyectosInput, LineaFinanciamientoUncheckedUpdateWithoutProyectosInput>
    create: XOR<LineaFinanciamientoCreateWithoutProyectosInput, LineaFinanciamientoUncheckedCreateWithoutProyectosInput>
    where?: LineaFinanciamientoWhereInput
  }

  export type LineaFinanciamientoUpdateToOneWithWhereWithoutProyectosInput = {
    where?: LineaFinanciamientoWhereInput
    data: XOR<LineaFinanciamientoUpdateWithoutProyectosInput, LineaFinanciamientoUncheckedUpdateWithoutProyectosInput>
  }

  export type LineaFinanciamientoUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    programas?: ProgramaUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type LineaFinanciamientoUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    programas?: ProgramaUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type ProgramaUpsertWithoutProyectosInput = {
    update: XOR<ProgramaUpdateWithoutProyectosInput, ProgramaUncheckedUpdateWithoutProyectosInput>
    create: XOR<ProgramaCreateWithoutProyectosInput, ProgramaUncheckedCreateWithoutProyectosInput>
    where?: ProgramaWhereInput
  }

  export type ProgramaUpdateToOneWithWhereWithoutProyectosInput = {
    where?: ProgramaWhereInput
    data: XOR<ProgramaUpdateWithoutProyectosInput, ProgramaUncheckedUpdateWithoutProyectosInput>
  }

  export type ProgramaUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneRequiredWithoutProgramasNestedInput
  }

  export type ProgramaUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    lineaFinanciamientoId?: IntFieldUpdateOperationsInput | number
  }

  export type EtapaFinanciamientoUpsertWithoutProyectosInput = {
    update: XOR<EtapaFinanciamientoUpdateWithoutProyectosInput, EtapaFinanciamientoUncheckedUpdateWithoutProyectosInput>
    create: XOR<EtapaFinanciamientoCreateWithoutProyectosInput, EtapaFinanciamientoUncheckedCreateWithoutProyectosInput>
    where?: EtapaFinanciamientoWhereInput
  }

  export type EtapaFinanciamientoUpdateToOneWithWhereWithoutProyectosInput = {
    where?: EtapaFinanciamientoWhereInput
    data: XOR<EtapaFinanciamientoUpdateWithoutProyectosInput, EtapaFinanciamientoUncheckedUpdateWithoutProyectosInput>
  }

  export type EtapaFinanciamientoUpdateWithoutProyectosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EtapaFinanciamientoUncheckedUpdateWithoutProyectosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TareaUpsertWithWhereUniqueWithoutProyectoInput = {
    where: TareaWhereUniqueInput
    update: XOR<TareaUpdateWithoutProyectoInput, TareaUncheckedUpdateWithoutProyectoInput>
    create: XOR<TareaCreateWithoutProyectoInput, TareaUncheckedCreateWithoutProyectoInput>
  }

  export type TareaUpdateWithWhereUniqueWithoutProyectoInput = {
    where: TareaWhereUniqueInput
    data: XOR<TareaUpdateWithoutProyectoInput, TareaUncheckedUpdateWithoutProyectoInput>
  }

  export type TareaUpdateManyWithWhereWithoutProyectoInput = {
    where: TareaScalarWhereInput
    data: XOR<TareaUpdateManyMutationInput, TareaUncheckedUpdateManyWithoutProyectoInput>
  }

  export type ProjectCreateWithoutEstadoInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutEstadoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutEstadoInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput>
  }

  export type ProjectCreateManyEstadoInputEnvelope = {
    data: ProjectCreateManyEstadoInput | ProjectCreateManyEstadoInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutEstadoInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutEstadoInput, ProjectUncheckedUpdateWithoutEstadoInput>
    create: XOR<ProjectCreateWithoutEstadoInput, ProjectUncheckedCreateWithoutEstadoInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutEstadoInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutEstadoInput, ProjectUncheckedUpdateWithoutEstadoInput>
  }

  export type ProjectUpdateManyWithWhereWithoutEstadoInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutEstadoInput>
  }

  export type ProjectCreateWithoutUnidadInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutUnidadInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutUnidadInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput>
  }

  export type ProjectCreateManyUnidadInputEnvelope = {
    data: ProjectCreateManyUnidadInput | ProjectCreateManyUnidadInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutUnidadInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUnidadInput, ProjectUncheckedUpdateWithoutUnidadInput>
    create: XOR<ProjectCreateWithoutUnidadInput, ProjectUncheckedCreateWithoutUnidadInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUnidadInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUnidadInput, ProjectUncheckedUpdateWithoutUnidadInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUnidadInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUnidadInput>
  }

  export type ProjectCreateWithoutTipologiaInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutTipologiaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutTipologiaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput>
  }

  export type ProjectCreateManyTipologiaInputEnvelope = {
    data: ProjectCreateManyTipologiaInput | ProjectCreateManyTipologiaInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutTipologiaInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutTipologiaInput, ProjectUncheckedUpdateWithoutTipologiaInput>
    create: XOR<ProjectCreateWithoutTipologiaInput, ProjectUncheckedCreateWithoutTipologiaInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutTipologiaInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutTipologiaInput, ProjectUncheckedUpdateWithoutTipologiaInput>
  }

  export type ProjectUpdateManyWithWhereWithoutTipologiaInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutTipologiaInput>
  }

  export type ProjectCreateWithoutSectorInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutSectorInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutSectorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput>
  }

  export type ProjectCreateManySectorInputEnvelope = {
    data: ProjectCreateManySectorInput | ProjectCreateManySectorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutSectorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutSectorInput, ProjectUncheckedUpdateWithoutSectorInput>
    create: XOR<ProjectCreateWithoutSectorInput, ProjectUncheckedCreateWithoutSectorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutSectorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutSectorInput, ProjectUncheckedUpdateWithoutSectorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutSectorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutSectorInput>
  }

  export type ProgramaCreateWithoutLineaFinanciamientoInput = {
    nombre: string
    proyectos?: ProjectCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUncheckedCreateWithoutLineaFinanciamientoInput = {
    id?: number
    nombre: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaCreateOrConnectWithoutLineaFinanciamientoInput = {
    where: ProgramaWhereUniqueInput
    create: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput>
  }

  export type ProgramaCreateManyLineaFinanciamientoInputEnvelope = {
    data: ProgramaCreateManyLineaFinanciamientoInput | ProgramaCreateManyLineaFinanciamientoInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutLineaFinanciamientoInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutLineaFinanciamientoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutLineaFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput>
  }

  export type ProjectCreateManyLineaFinanciamientoInputEnvelope = {
    data: ProjectCreateManyLineaFinanciamientoInput | ProjectCreateManyLineaFinanciamientoInput[]
    skipDuplicates?: boolean
  }

  export type ProgramaUpsertWithWhereUniqueWithoutLineaFinanciamientoInput = {
    where: ProgramaWhereUniqueInput
    update: XOR<ProgramaUpdateWithoutLineaFinanciamientoInput, ProgramaUncheckedUpdateWithoutLineaFinanciamientoInput>
    create: XOR<ProgramaCreateWithoutLineaFinanciamientoInput, ProgramaUncheckedCreateWithoutLineaFinanciamientoInput>
  }

  export type ProgramaUpdateWithWhereUniqueWithoutLineaFinanciamientoInput = {
    where: ProgramaWhereUniqueInput
    data: XOR<ProgramaUpdateWithoutLineaFinanciamientoInput, ProgramaUncheckedUpdateWithoutLineaFinanciamientoInput>
  }

  export type ProgramaUpdateManyWithWhereWithoutLineaFinanciamientoInput = {
    where: ProgramaScalarWhereInput
    data: XOR<ProgramaUpdateManyMutationInput, ProgramaUncheckedUpdateManyWithoutLineaFinanciamientoInput>
  }

  export type ProgramaScalarWhereInput = {
    AND?: ProgramaScalarWhereInput | ProgramaScalarWhereInput[]
    OR?: ProgramaScalarWhereInput[]
    NOT?: ProgramaScalarWhereInput | ProgramaScalarWhereInput[]
    id?: IntFilter<"Programa"> | number
    nombre?: StringFilter<"Programa"> | string
    lineaFinanciamientoId?: IntFilter<"Programa"> | number
  }

  export type ProjectUpsertWithWhereUniqueWithoutLineaFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutLineaFinanciamientoInput, ProjectUncheckedUpdateWithoutLineaFinanciamientoInput>
    create: XOR<ProjectCreateWithoutLineaFinanciamientoInput, ProjectUncheckedCreateWithoutLineaFinanciamientoInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutLineaFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutLineaFinanciamientoInput, ProjectUncheckedUpdateWithoutLineaFinanciamientoInput>
  }

  export type ProjectUpdateManyWithWhereWithoutLineaFinanciamientoInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutLineaFinanciamientoInput>
  }

  export type LineaFinanciamientoCreateWithoutProgramasInput = {
    nombre: string
    proyectos?: ProjectCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoUncheckedCreateWithoutProgramasInput = {
    id?: number
    nombre: string
    proyectos?: ProjectUncheckedCreateNestedManyWithoutLineaFinanciamientoInput
  }

  export type LineaFinanciamientoCreateOrConnectWithoutProgramasInput = {
    where: LineaFinanciamientoWhereUniqueInput
    create: XOR<LineaFinanciamientoCreateWithoutProgramasInput, LineaFinanciamientoUncheckedCreateWithoutProgramasInput>
  }

  export type ProjectCreateWithoutProgramaInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutProgramaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutProgramaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput>
  }

  export type ProjectCreateManyProgramaInputEnvelope = {
    data: ProjectCreateManyProgramaInput | ProjectCreateManyProgramaInput[]
    skipDuplicates?: boolean
  }

  export type LineaFinanciamientoUpsertWithoutProgramasInput = {
    update: XOR<LineaFinanciamientoUpdateWithoutProgramasInput, LineaFinanciamientoUncheckedUpdateWithoutProgramasInput>
    create: XOR<LineaFinanciamientoCreateWithoutProgramasInput, LineaFinanciamientoUncheckedCreateWithoutProgramasInput>
    where?: LineaFinanciamientoWhereInput
  }

  export type LineaFinanciamientoUpdateToOneWithWhereWithoutProgramasInput = {
    where?: LineaFinanciamientoWhereInput
    data: XOR<LineaFinanciamientoUpdateWithoutProgramasInput, LineaFinanciamientoUncheckedUpdateWithoutProgramasInput>
  }

  export type LineaFinanciamientoUpdateWithoutProgramasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type LineaFinanciamientoUncheckedUpdateWithoutProgramasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutLineaFinanciamientoNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutProgramaInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProgramaInput, ProjectUncheckedUpdateWithoutProgramaInput>
    create: XOR<ProjectCreateWithoutProgramaInput, ProjectUncheckedCreateWithoutProgramaInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProgramaInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProgramaInput, ProjectUncheckedUpdateWithoutProgramaInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProgramaInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProgramaInput>
  }

  export type ProjectCreateWithoutEtapaActualFinanciamientoInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    tareas?: TareaCreateNestedManyWithoutProyectoInput
  }

  export type ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
    tareas?: TareaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProjectCreateOrConnectWithoutEtapaActualFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput>
  }

  export type ProjectCreateManyEtapaActualFinanciamientoInputEnvelope = {
    data: ProjectCreateManyEtapaActualFinanciamientoInput | ProjectCreateManyEtapaActualFinanciamientoInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutEtapaActualFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedUpdateWithoutEtapaActualFinanciamientoInput>
    create: XOR<ProjectCreateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedCreateWithoutEtapaActualFinanciamientoInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutEtapaActualFinanciamientoInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutEtapaActualFinanciamientoInput, ProjectUncheckedUpdateWithoutEtapaActualFinanciamientoInput>
  }

  export type ProjectUpdateManyWithWhereWithoutEtapaActualFinanciamientoInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutEtapaActualFinanciamientoInput>
  }

  export type ProjectCreateWithoutTareasInput = {
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    estado?: EstadoProyectoCreateNestedOneWithoutProyectosInput
    unidad?: UnidadMunicipalCreateNestedOneWithoutProyectosInput
    tipologia?: TipologiaProyectoCreateNestedOneWithoutProyectosInput
    sector?: SectorCreateNestedOneWithoutProyectosInput
    proyectista?: UserCreateNestedOneWithoutProyectosAsignadosComoProyectistaInput
    formulador?: UserCreateNestedOneWithoutProyectosAsignadosComoFormuladorInput
    colaboradores?: UserCreateNestedManyWithoutProyectosComoColaboradorInput
    lineaFinanciamiento?: LineaFinanciamientoCreateNestedOneWithoutProyectosInput
    programa?: ProgramaCreateNestedOneWithoutProyectosInput
    etapaActualFinanciamiento?: EtapaFinanciamientoCreateNestedOneWithoutProyectosInput
  }

  export type ProjectUncheckedCreateWithoutTareasInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
    colaboradores?: UserUncheckedCreateNestedManyWithoutProyectosComoColaboradorInput
  }

  export type ProjectCreateOrConnectWithoutTareasInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTareasInput, ProjectUncheckedCreateWithoutTareasInput>
  }

  export type UserCreateWithoutTareasCreadasInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutTareasCreadasInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutTareasCreadasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTareasCreadasInput, UserUncheckedCreateWithoutTareasCreadasInput>
  }

  export type UserCreateWithoutTareasAsignadasInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    comentariosBitacora?: ComentarioBitacoraCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateWithoutTareasAsignadasInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    comentariosBitacora?: ComentarioBitacoraUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserCreateOrConnectWithoutTareasAsignadasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTareasAsignadasInput, UserUncheckedCreateWithoutTareasAsignadasInput>
  }

  export type ComentarioBitacoraCreateWithoutTareaInput = {
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creadoPor: UserCreateNestedOneWithoutComentariosBitacoraInput
  }

  export type ComentarioBitacoraUncheckedCreateWithoutTareaInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creadoPorId: number
  }

  export type ComentarioBitacoraCreateOrConnectWithoutTareaInput = {
    where: ComentarioBitacoraWhereUniqueInput
    create: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput>
  }

  export type ComentarioBitacoraCreateManyTareaInputEnvelope = {
    data: ComentarioBitacoraCreateManyTareaInput | ComentarioBitacoraCreateManyTareaInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTareasInput = {
    update: XOR<ProjectUpdateWithoutTareasInput, ProjectUncheckedUpdateWithoutTareasInput>
    create: XOR<ProjectCreateWithoutTareasInput, ProjectUncheckedCreateWithoutTareasInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTareasInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTareasInput, ProjectUncheckedUpdateWithoutTareasInput>
  }

  export type ProjectUpdateWithoutTareasInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTareasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
  }

  export type UserUpsertWithoutTareasCreadasInput = {
    update: XOR<UserUpdateWithoutTareasCreadasInput, UserUncheckedUpdateWithoutTareasCreadasInput>
    create: XOR<UserCreateWithoutTareasCreadasInput, UserUncheckedCreateWithoutTareasCreadasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTareasCreadasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTareasCreadasInput, UserUncheckedUpdateWithoutTareasCreadasInput>
  }

  export type UserUpdateWithoutTareasCreadasInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutTareasCreadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUpsertWithoutTareasAsignadasInput = {
    update: XOR<UserUpdateWithoutTareasAsignadasInput, UserUncheckedUpdateWithoutTareasAsignadasInput>
    create: XOR<UserCreateWithoutTareasAsignadasInput, UserUncheckedCreateWithoutTareasAsignadasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTareasAsignadasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTareasAsignadasInput, UserUncheckedUpdateWithoutTareasAsignadasInput>
  }

  export type UserUpdateWithoutTareasAsignadasInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutTareasAsignadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type ComentarioBitacoraUpsertWithWhereUniqueWithoutTareaInput = {
    where: ComentarioBitacoraWhereUniqueInput
    update: XOR<ComentarioBitacoraUpdateWithoutTareaInput, ComentarioBitacoraUncheckedUpdateWithoutTareaInput>
    create: XOR<ComentarioBitacoraCreateWithoutTareaInput, ComentarioBitacoraUncheckedCreateWithoutTareaInput>
  }

  export type ComentarioBitacoraUpdateWithWhereUniqueWithoutTareaInput = {
    where: ComentarioBitacoraWhereUniqueInput
    data: XOR<ComentarioBitacoraUpdateWithoutTareaInput, ComentarioBitacoraUncheckedUpdateWithoutTareaInput>
  }

  export type ComentarioBitacoraUpdateManyWithWhereWithoutTareaInput = {
    where: ComentarioBitacoraScalarWhereInput
    data: XOR<ComentarioBitacoraUpdateManyMutationInput, ComentarioBitacoraUncheckedUpdateManyWithoutTareaInput>
  }

  export type TareaCreateWithoutComentariosInput = {
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyecto: ProjectCreateNestedOneWithoutTareasInput
    creadaPor: UserCreateNestedOneWithoutTareasCreadasInput
    asignadoA?: UserCreateNestedOneWithoutTareasAsignadasInput
  }

  export type TareaUncheckedCreateWithoutComentariosInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    creadaPorId: number
    asignadoAId?: number | null
  }

  export type TareaCreateOrConnectWithoutComentariosInput = {
    where: TareaWhereUniqueInput
    create: XOR<TareaCreateWithoutComentariosInput, TareaUncheckedCreateWithoutComentariosInput>
  }

  export type UserCreateWithoutComentariosBitacoraInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaCreateNestedManyWithoutAsignadoAInput
  }

  export type UserUncheckedCreateWithoutComentariosBitacoraInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    etiquetas?: EtiquetaUncheckedCreateNestedManyWithoutUsuariosInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedCreateNestedManyWithoutProyectistaInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedCreateNestedManyWithoutFormuladorInput
    proyectosComoColaborador?: ProjectUncheckedCreateNestedManyWithoutColaboradoresInput
    tareasCreadas?: TareaUncheckedCreateNestedManyWithoutCreadaPorInput
    tareasAsignadas?: TareaUncheckedCreateNestedManyWithoutAsignadoAInput
  }

  export type UserCreateOrConnectWithoutComentariosBitacoraInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComentariosBitacoraInput, UserUncheckedCreateWithoutComentariosBitacoraInput>
  }

  export type TareaUpsertWithoutComentariosInput = {
    update: XOR<TareaUpdateWithoutComentariosInput, TareaUncheckedUpdateWithoutComentariosInput>
    create: XOR<TareaCreateWithoutComentariosInput, TareaUncheckedCreateWithoutComentariosInput>
    where?: TareaWhereInput
  }

  export type TareaUpdateToOneWithWhereWithoutComentariosInput = {
    where?: TareaWhereInput
    data: XOR<TareaUpdateWithoutComentariosInput, TareaUncheckedUpdateWithoutComentariosInput>
  }

  export type TareaUpdateWithoutComentariosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProjectUpdateOneRequiredWithoutTareasNestedInput
    creadaPor?: UserUpdateOneRequiredWithoutTareasCreadasNestedInput
    asignadoA?: UserUpdateOneWithoutTareasAsignadasNestedInput
  }

  export type TareaUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    creadaPorId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutComentariosBitacoraInput = {
    update: XOR<UserUpdateWithoutComentariosBitacoraInput, UserUncheckedUpdateWithoutComentariosBitacoraInput>
    create: XOR<UserCreateWithoutComentariosBitacoraInput, UserUncheckedCreateWithoutComentariosBitacoraInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComentariosBitacoraInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComentariosBitacoraInput, UserUncheckedUpdateWithoutComentariosBitacoraInput>
  }

  export type UserUpdateWithoutComentariosBitacoraInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
  }

  export type UserUncheckedUpdateWithoutComentariosBitacoraInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
  }

  export type ProjectCreateManyProyectistaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectCreateManyFormuladorInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type TareaCreateManyCreadaPorInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    asignadoAId?: number | null
  }

  export type TareaCreateManyAsignadoAInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proyectoId: number
    creadaPorId: number
  }

  export type ComentarioBitacoraCreateManyCreadoPorInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tareaId: number
  }

  export type EtiquetaUpdateWithoutUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutProyectistaInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProyectistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProyectistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutFormuladorInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFormuladorInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutFormuladorInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutColaboradoresInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutColaboradoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutColaboradoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TareaUpdateWithoutCreadaPorInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProjectUpdateOneRequiredWithoutTareasNestedInput
    asignadoA?: UserUpdateOneWithoutTareasAsignadasNestedInput
    comentarios?: ComentarioBitacoraUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateWithoutCreadaPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: ComentarioBitacoraUncheckedUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateManyWithoutCreadaPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TareaUpdateWithoutAsignadoAInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProjectUpdateOneRequiredWithoutTareasNestedInput
    creadaPor?: UserUpdateOneRequiredWithoutTareasCreadasNestedInput
    comentarios?: ComentarioBitacoraUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateWithoutAsignadoAInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    creadaPorId?: IntFieldUpdateOperationsInput | number
    comentarios?: ComentarioBitacoraUncheckedUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateManyWithoutAsignadoAInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    creadaPorId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioBitacoraUpdateWithoutCreadoPorInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tarea?: TareaUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioBitacoraUncheckedUpdateWithoutCreadoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tareaId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tareaId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutEtiquetasInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutEtiquetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    proyectosComoColaborador?: ProjectUncheckedUpdateManyWithoutColaboradoresNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutEtiquetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TareaCreateManyProyectoInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaPlazo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creadaPorId: number
    asignadoAId?: number | null
  }

  export type UserUpdateWithoutProyectosComoColaboradorInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUpdateManyWithoutFormuladorNestedInput
    tareasCreadas?: TareaUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateWithoutProyectosComoColaboradorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etiquetas?: EtiquetaUncheckedUpdateManyWithoutUsuariosNestedInput
    proyectosAsignadosComoProyectista?: ProjectUncheckedUpdateManyWithoutProyectistaNestedInput
    proyectosAsignadosComoFormulador?: ProjectUncheckedUpdateManyWithoutFormuladorNestedInput
    tareasCreadas?: TareaUncheckedUpdateManyWithoutCreadaPorNestedInput
    tareasAsignadas?: TareaUncheckedUpdateManyWithoutAsignadoANestedInput
    comentariosBitacora?: ComentarioBitacoraUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProyectosComoColaboradorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TareaUpdateWithoutProyectoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadaPor?: UserUpdateOneRequiredWithoutTareasCreadasNestedInput
    asignadoA?: UserUpdateOneWithoutTareasAsignadasNestedInput
    comentarios?: ComentarioBitacoraUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateWithoutProyectoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadaPorId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarios?: ComentarioBitacoraUncheckedUpdateManyWithoutTareaNestedInput
  }

  export type TareaUncheckedUpdateManyWithoutProyectoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPlazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadaPorId?: IntFieldUpdateOperationsInput | number
    asignadoAId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectCreateManyEstadoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutEstadoInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManyUnidadInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutUnidadInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUnidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUnidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManyTipologiaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutTipologiaInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTipologiaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutTipologiaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManySectorInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutSectorInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutSectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramaCreateManyLineaFinanciamientoInput = {
    id?: number
    nombre: string
  }

  export type ProjectCreateManyLineaFinanciamientoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    programaId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProgramaUpdateWithoutLineaFinanciamientoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateWithoutLineaFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proyectos?: ProjectUncheckedUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateManyWithoutLineaFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutLineaFinanciamientoInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLineaFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutLineaFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManyProgramaInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    etapaFinanciamientoId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutProgramaInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    etapaActualFinanciamiento?: EtapaFinanciamientoUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProgramaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProgramaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    etapaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManyEtapaActualFinanciamientoInput = {
    id?: number
    codigoUnico: string
    nombre: string
    descripcion?: string | null
    direccion?: string | null
    superficieTerreno?: number | null
    superficieEdificacion?: number | null
    ano?: number | null
    proyectoPriorizado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estadoId?: number | null
    unidadId?: number | null
    tipologiaId?: number | null
    sectorId?: number | null
    proyectistaId?: number | null
    formuladorId?: number | null
    lineaFinanciamientoId?: number | null
    programaId?: number | null
    codigoExpediente?: string | null
    fechaPostulacion?: Date | string | null
    monto?: Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: $Enums.TipoMoneda
    montoAdjudicado?: Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: string | null
  }

  export type ProjectUpdateWithoutEtapaActualFinanciamientoInput = {
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EstadoProyectoUpdateOneWithoutProyectosNestedInput
    unidad?: UnidadMunicipalUpdateOneWithoutProyectosNestedInput
    tipologia?: TipologiaProyectoUpdateOneWithoutProyectosNestedInput
    sector?: SectorUpdateOneWithoutProyectosNestedInput
    proyectista?: UserUpdateOneWithoutProyectosAsignadosComoProyectistaNestedInput
    formulador?: UserUpdateOneWithoutProyectosAsignadosComoFormuladorNestedInput
    colaboradores?: UserUpdateManyWithoutProyectosComoColaboradorNestedInput
    lineaFinanciamiento?: LineaFinanciamientoUpdateOneWithoutProyectosNestedInput
    programa?: ProgramaUpdateOneWithoutProyectosNestedInput
    tareas?: TareaUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEtapaActualFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
    colaboradores?: UserUncheckedUpdateManyWithoutProyectosComoColaboradorNestedInput
    tareas?: TareaUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutEtapaActualFinanciamientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoUnico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    superficieTerreno?: NullableFloatFieldUpdateOperationsInput | number | null
    superficieEdificacion?: NullableFloatFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    proyectoPriorizado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoId?: NullableIntFieldUpdateOperationsInput | number | null
    unidadId?: NullableIntFieldUpdateOperationsInput | number | null
    tipologiaId?: NullableIntFieldUpdateOperationsInput | number | null
    sectorId?: NullableIntFieldUpdateOperationsInput | number | null
    proyectistaId?: NullableIntFieldUpdateOperationsInput | number | null
    formuladorId?: NullableIntFieldUpdateOperationsInput | number | null
    lineaFinanciamientoId?: NullableIntFieldUpdateOperationsInput | number | null
    programaId?: NullableIntFieldUpdateOperationsInput | number | null
    codigoExpediente?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPostulacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tipoMoneda?: EnumTipoMonedaFieldUpdateOperationsInput | $Enums.TipoMoneda
    montoAdjudicado?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigoLicitacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioBitacoraCreateManyTareaInput = {
    id?: number
    contenido: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creadoPorId: number
  }

  export type ComentarioBitacoraUpdateWithoutTareaInput = {
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UserUpdateOneRequiredWithoutComentariosBitacoraNestedInput
  }

  export type ComentarioBitacoraUncheckedUpdateWithoutTareaInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioBitacoraUncheckedUpdateManyWithoutTareaInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtiquetaCountOutputTypeDefaultArgs instead
     */
    export type EtiquetaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtiquetaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoProyectoCountOutputTypeDefaultArgs instead
     */
    export type EstadoProyectoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoProyectoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnidadMunicipalCountOutputTypeDefaultArgs instead
     */
    export type UnidadMunicipalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnidadMunicipalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipologiaProyectoCountOutputTypeDefaultArgs instead
     */
    export type TipologiaProyectoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipologiaProyectoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectorCountOutputTypeDefaultArgs instead
     */
    export type SectorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LineaFinanciamientoCountOutputTypeDefaultArgs instead
     */
    export type LineaFinanciamientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LineaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramaCountOutputTypeDefaultArgs instead
     */
    export type ProgramaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtapaFinanciamientoCountOutputTypeDefaultArgs instead
     */
    export type EtapaFinanciamientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtapaFinanciamientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TareaCountOutputTypeDefaultArgs instead
     */
    export type TareaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TareaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtiquetaDefaultArgs instead
     */
    export type EtiquetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtiquetaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoProyectoDefaultArgs instead
     */
    export type EstadoProyectoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoProyectoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnidadMunicipalDefaultArgs instead
     */
    export type UnidadMunicipalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnidadMunicipalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipologiaProyectoDefaultArgs instead
     */
    export type TipologiaProyectoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipologiaProyectoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectorDefaultArgs instead
     */
    export type SectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LineaFinanciamientoDefaultArgs instead
     */
    export type LineaFinanciamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LineaFinanciamientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramaDefaultArgs instead
     */
    export type ProgramaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtapaFinanciamientoDefaultArgs instead
     */
    export type EtapaFinanciamientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtapaFinanciamientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TareaDefaultArgs instead
     */
    export type TareaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TareaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioBitacoraDefaultArgs instead
     */
    export type ComentarioBitacoraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioBitacoraDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}